{"ast":null,"code":"'use strict';\n\nconst Assert = require('@hapi/hoek/lib/assert');\n\nconst Uri = require('./uri');\n\nconst internals = {};\n\nexports.regex = function (options = {}) {\n  // CIDR\n  Assert(options.cidr === undefined || typeof options.cidr === 'string', 'options.cidr must be a string');\n  const cidr = options.cidr ? options.cidr.toLowerCase() : 'optional';\n  Assert(['required', 'optional', 'forbidden'].includes(cidr), 'options.cidr must be one of required, optional, forbidden'); // Versions\n\n  Assert(options.version === undefined || typeof options.version === 'string' || Array.isArray(options.version), 'options.version must be a string or an array of string');\n  let versions = options.version || ['ipv4', 'ipv6', 'ipvfuture'];\n\n  if (!Array.isArray(versions)) {\n    versions = [versions];\n  }\n\n  Assert(versions.length >= 1, 'options.version must have at least 1 version specified');\n\n  for (let i = 0; i < versions.length; ++i) {\n    Assert(typeof versions[i] === 'string', 'options.version must only contain strings');\n    versions[i] = versions[i].toLowerCase();\n    Assert(['ipv4', 'ipv6', 'ipvfuture'].includes(versions[i]), 'options.version contains unknown version ' + versions[i] + ' - must be one of ipv4, ipv6, ipvfuture');\n  }\n\n  versions = Array.from(new Set(versions)); // Regex\n\n  const parts = versions.map(version => {\n    // Forbidden\n    if (cidr === 'forbidden') {\n      return Uri.ip[version];\n    } // Required\n\n\n    const cidrpart = `\\\\/${version === 'ipv4' ? Uri.ip.v4Cidr : Uri.ip.v6Cidr}`;\n\n    if (cidr === 'required') {\n      return `${Uri.ip[version]}${cidrpart}`;\n    } // Optional\n\n\n    return `${Uri.ip[version]}(?:${cidrpart})?`;\n  });\n  const raw = `(?:${parts.join('|')})`;\n  const regex = new RegExp(`^${raw}$`);\n  return {\n    cidr,\n    versions,\n    regex,\n    raw\n  };\n};","map":{"version":3,"sources":["C:/scripting/jobs assignments/whist/backend/node_modules/@sideway/address/lib/ip.js"],"names":["Assert","require","Uri","internals","exports","regex","options","cidr","undefined","toLowerCase","includes","version","Array","isArray","versions","length","i","from","Set","parts","map","ip","cidrpart","v4Cidr","v6Cidr","raw","join","RegExp"],"mappings":"AAAA;;AAEA,MAAMA,MAAM,GAAGC,OAAO,CAAC,uBAAD,CAAtB;;AAEA,MAAMC,GAAG,GAAGD,OAAO,CAAC,OAAD,CAAnB;;AAGA,MAAME,SAAS,GAAG,EAAlB;;AAGAC,OAAO,CAACC,KAAR,GAAgB,UAAUC,OAAO,GAAG,EAApB,EAAwB;AAEpC;AAEAN,EAAAA,MAAM,CAACM,OAAO,CAACC,IAAR,KAAiBC,SAAjB,IAA8B,OAAOF,OAAO,CAACC,IAAf,KAAwB,QAAvD,EAAiE,+BAAjE,CAAN;AACA,QAAMA,IAAI,GAAGD,OAAO,CAACC,IAAR,GAAeD,OAAO,CAACC,IAAR,CAAaE,WAAb,EAAf,GAA4C,UAAzD;AACAT,EAAAA,MAAM,CAAC,CAAC,UAAD,EAAa,UAAb,EAAyB,WAAzB,EAAsCU,QAAtC,CAA+CH,IAA/C,CAAD,EAAuD,2DAAvD,CAAN,CANoC,CAQpC;;AAEAP,EAAAA,MAAM,CAACM,OAAO,CAACK,OAAR,KAAoBH,SAApB,IAAiC,OAAOF,OAAO,CAACK,OAAf,KAA2B,QAA5D,IAAwEC,KAAK,CAACC,OAAN,CAAcP,OAAO,CAACK,OAAtB,CAAzE,EAAyG,wDAAzG,CAAN;AACA,MAAIG,QAAQ,GAAGR,OAAO,CAACK,OAAR,IAAmB,CAAC,MAAD,EAAS,MAAT,EAAiB,WAAjB,CAAlC;;AACA,MAAI,CAACC,KAAK,CAACC,OAAN,CAAcC,QAAd,CAAL,EAA8B;AAC1BA,IAAAA,QAAQ,GAAG,CAACA,QAAD,CAAX;AACH;;AAEDd,EAAAA,MAAM,CAACc,QAAQ,CAACC,MAAT,IAAmB,CAApB,EAAuB,wDAAvB,CAAN;;AAEA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,QAAQ,CAACC,MAA7B,EAAqC,EAAEC,CAAvC,EAA0C;AACtChB,IAAAA,MAAM,CAAC,OAAOc,QAAQ,CAACE,CAAD,CAAf,KAAuB,QAAxB,EAAkC,2CAAlC,CAAN;AACAF,IAAAA,QAAQ,CAACE,CAAD,CAAR,GAAcF,QAAQ,CAACE,CAAD,CAAR,CAAYP,WAAZ,EAAd;AACAT,IAAAA,MAAM,CAAC,CAAC,MAAD,EAAS,MAAT,EAAiB,WAAjB,EAA8BU,QAA9B,CAAuCI,QAAQ,CAACE,CAAD,CAA/C,CAAD,EAAsD,8CAA8CF,QAAQ,CAACE,CAAD,CAAtD,GAA4D,yCAAlH,CAAN;AACH;;AAEDF,EAAAA,QAAQ,GAAGF,KAAK,CAACK,IAAN,CAAW,IAAIC,GAAJ,CAAQJ,QAAR,CAAX,CAAX,CAxBoC,CA0BpC;;AAEA,QAAMK,KAAK,GAAGL,QAAQ,CAACM,GAAT,CAAcT,OAAD,IAAa;AAEpC;AAEA,QAAIJ,IAAI,KAAK,WAAb,EAA0B;AACtB,aAAOL,GAAG,CAACmB,EAAJ,CAAOV,OAAP,CAAP;AACH,KANmC,CAQpC;;;AAEA,UAAMW,QAAQ,GAAI,MAAKX,OAAO,KAAK,MAAZ,GAAqBT,GAAG,CAACmB,EAAJ,CAAOE,MAA5B,GAAqCrB,GAAG,CAACmB,EAAJ,CAAOG,MAAO,EAA1E;;AAEA,QAAIjB,IAAI,KAAK,UAAb,EAAyB;AACrB,aAAQ,GAAEL,GAAG,CAACmB,EAAJ,CAAOV,OAAP,CAAgB,GAAEW,QAAS,EAArC;AACH,KAdmC,CAgBpC;;;AAEA,WAAQ,GAAEpB,GAAG,CAACmB,EAAJ,CAAOV,OAAP,CAAgB,MAAKW,QAAS,IAAxC;AACH,GAnBa,CAAd;AAqBA,QAAMG,GAAG,GAAI,MAAKN,KAAK,CAACO,IAAN,CAAW,GAAX,CAAgB,GAAlC;AACA,QAAMrB,KAAK,GAAG,IAAIsB,MAAJ,CAAY,IAAGF,GAAI,GAAnB,CAAd;AACA,SAAO;AAAElB,IAAAA,IAAF;AAAQO,IAAAA,QAAR;AAAkBT,IAAAA,KAAlB;AAAyBoB,IAAAA;AAAzB,GAAP;AACH,CApDD","sourcesContent":["'use strict';\n\nconst Assert = require('@hapi/hoek/lib/assert');\n\nconst Uri = require('./uri');\n\n\nconst internals = {};\n\n\nexports.regex = function (options = {}) {\n\n    // CIDR\n\n    Assert(options.cidr === undefined || typeof options.cidr === 'string', 'options.cidr must be a string');\n    const cidr = options.cidr ? options.cidr.toLowerCase() : 'optional';\n    Assert(['required', 'optional', 'forbidden'].includes(cidr), 'options.cidr must be one of required, optional, forbidden');\n\n    // Versions\n\n    Assert(options.version === undefined || typeof options.version === 'string' || Array.isArray(options.version), 'options.version must be a string or an array of string');\n    let versions = options.version || ['ipv4', 'ipv6', 'ipvfuture'];\n    if (!Array.isArray(versions)) {\n        versions = [versions];\n    }\n\n    Assert(versions.length >= 1, 'options.version must have at least 1 version specified');\n\n    for (let i = 0; i < versions.length; ++i) {\n        Assert(typeof versions[i] === 'string', 'options.version must only contain strings');\n        versions[i] = versions[i].toLowerCase();\n        Assert(['ipv4', 'ipv6', 'ipvfuture'].includes(versions[i]), 'options.version contains unknown version ' + versions[i] + ' - must be one of ipv4, ipv6, ipvfuture');\n    }\n\n    versions = Array.from(new Set(versions));\n\n    // Regex\n\n    const parts = versions.map((version) => {\n\n        // Forbidden\n\n        if (cidr === 'forbidden') {\n            return Uri.ip[version];\n        }\n\n        // Required\n\n        const cidrpart = `\\\\/${version === 'ipv4' ? Uri.ip.v4Cidr : Uri.ip.v6Cidr}`;\n\n        if (cidr === 'required') {\n            return `${Uri.ip[version]}${cidrpart}`;\n        }\n\n        // Optional\n\n        return `${Uri.ip[version]}(?:${cidrpart})?`;\n    });\n\n    const raw = `(?:${parts.join('|')})`;\n    const regex = new RegExp(`^${raw}$`);\n    return { cidr, versions, regex, raw };\n};\n"]},"metadata":{},"sourceType":"script"}