{"ast":null,"code":"'use strict';\n\nconst Assert = require('@hapi/hoek/lib/assert');\n\nconst Any = require('./any');\n\nconst Common = require('../common');\n\nconst internals = {};\nmodule.exports = Any.extend({\n  type: 'binary',\n  coerce: {\n    from: 'string',\n\n    method(value, {\n      schema\n    }) {\n      try {\n        return {\n          value: Buffer.from(value, schema._flags.encoding)\n        };\n      } catch (ignoreErr) {}\n    }\n\n  },\n\n  validate(value, {\n    error\n  }) {\n    if (!Buffer.isBuffer(value)) {\n      return {\n        value,\n        errors: error('binary.base')\n      };\n    }\n  },\n\n  rules: {\n    encoding: {\n      method(encoding) {\n        Assert(Buffer.isEncoding(encoding), 'Invalid encoding:', encoding);\n        return this.$_setFlag('encoding', encoding);\n      }\n\n    },\n    length: {\n      method(limit) {\n        return this.$_addRule({\n          name: 'length',\n          method: 'length',\n          args: {\n            limit\n          },\n          operator: '='\n        });\n      },\n\n      validate(value, helpers, {\n        limit\n      }, {\n        name,\n        operator,\n        args\n      }) {\n        if (Common.compare(value.length, limit, operator)) {\n          return value;\n        }\n\n        return helpers.error('binary.' + name, {\n          limit: args.limit,\n          value\n        });\n      },\n\n      args: [{\n        name: 'limit',\n        ref: true,\n        assert: Common.limit,\n        message: 'must be a positive integer'\n      }]\n    },\n    max: {\n      method(limit) {\n        return this.$_addRule({\n          name: 'max',\n          method: 'length',\n          args: {\n            limit\n          },\n          operator: '<='\n        });\n      }\n\n    },\n    min: {\n      method(limit) {\n        return this.$_addRule({\n          name: 'min',\n          method: 'length',\n          args: {\n            limit\n          },\n          operator: '>='\n        });\n      }\n\n    }\n  },\n  cast: {\n    string: {\n      from: value => Buffer.isBuffer(value),\n\n      to(value, helpers) {\n        return value.toString();\n      }\n\n    }\n  },\n  messages: {\n    'binary.base': '{{#label}} must be a buffer or a string',\n    'binary.length': '{{#label}} must be {{#limit}} bytes',\n    'binary.max': '{{#label}} must be less than or equal to {{#limit}} bytes',\n    'binary.min': '{{#label}} must be at least {{#limit}} bytes'\n  }\n});","map":{"version":3,"sources":["C:/scripting/jobs assignments/whist/backend/node_modules/joi/lib/types/binary.js"],"names":["Assert","require","Any","Common","internals","module","exports","extend","type","coerce","from","method","value","schema","Buffer","_flags","encoding","ignoreErr","validate","error","isBuffer","errors","rules","isEncoding","$_setFlag","length","limit","$_addRule","name","args","operator","helpers","compare","ref","assert","message","max","min","cast","string","to","toString","messages"],"mappings":"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","sourcesContent":["'use strict';\n\nconst Assert = require('@hapi/hoek/lib/assert');\n\nconst Any = require('./any');\nconst Common = require('../common');\n\n\nconst internals = {};\n\n\nmodule.exports = Any.extend({\n\n    type: 'binary',\n\n    coerce: {\n        from: 'string',\n        method(value, { schema }) {\n\n            try {\n                return { value: Buffer.from(value, schema._flags.encoding) };\n            }\n            catch (ignoreErr) { }\n        }\n    },\n\n    validate(value, { error }) {\n\n        if (!Buffer.isBuffer(value)) {\n            return { value, errors: error('binary.base') };\n        }\n    },\n\n    rules: {\n        encoding: {\n            method(encoding) {\n\n                Assert(Buffer.isEncoding(encoding), 'Invalid encoding:', encoding);\n\n                return this.$_setFlag('encoding', encoding);\n            }\n        },\n\n        length: {\n            method(limit) {\n\n                return this.$_addRule({ name: 'length', method: 'length', args: { limit }, operator: '=' });\n            },\n            validate(value, helpers, { limit }, { name, operator, args }) {\n\n                if (Common.compare(value.length, limit, operator)) {\n                    return value;\n                }\n\n                return helpers.error('binary.' + name, { limit: args.limit, value });\n            },\n            args: [\n                {\n                    name: 'limit',\n                    ref: true,\n                    assert: Common.limit,\n                    message: 'must be a positive integer'\n                }\n            ]\n        },\n\n        max: {\n            method(limit) {\n\n                return this.$_addRule({ name: 'max', method: 'length', args: { limit }, operator: '<=' });\n            }\n        },\n\n        min: {\n            method(limit) {\n\n                return this.$_addRule({ name: 'min', method: 'length', args: { limit }, operator: '>=' });\n            }\n        }\n    },\n\n    cast: {\n        string: {\n            from: (value) => Buffer.isBuffer(value),\n            to(value, helpers) {\n\n                return value.toString();\n            }\n        }\n    },\n\n    messages: {\n        'binary.base': '{{#label}} must be a buffer or a string',\n        'binary.length': '{{#label}} must be {{#limit}} bytes',\n        'binary.max': '{{#label}} must be less than or equal to {{#limit}} bytes',\n        'binary.min': '{{#label}} must be at least {{#limit}} bytes'\n    }\n});\n"]},"metadata":{},"sourceType":"script"}