{"ast":null,"code":"'use strict';\n\nconst Assert = require('@hapi/hoek/lib/assert');\n\nconst Common = require('./common');\n\nconst Ref = require('./ref');\n\nconst internals = {};\n\nexports.schema = function (Joi, config, options = {}) {\n  Common.assertOptions(options, ['appendPath', 'override']);\n\n  try {\n    return internals.schema(Joi, config, options);\n  } catch (err) {\n    if (options.appendPath && err.path !== undefined) {\n      err.message = `${err.message} (${err.path})`;\n    }\n\n    throw err;\n  }\n};\n\ninternals.schema = function (Joi, config, options) {\n  Assert(config !== undefined, 'Invalid undefined schema');\n\n  if (Array.isArray(config)) {\n    Assert(config.length, 'Invalid empty array schema');\n\n    if (config.length === 1) {\n      config = config[0];\n    }\n  }\n\n  const valid = (base, ...values) => {\n    if (options.override !== false) {\n      return base.valid(Joi.override, ...values);\n    }\n\n    return base.valid(...values);\n  };\n\n  if (internals.simple(config)) {\n    return valid(Joi, config);\n  }\n\n  if (typeof config === 'function') {\n    return Joi.custom(config);\n  }\n\n  Assert(typeof config === 'object', 'Invalid schema content:', typeof config);\n\n  if (Common.isResolvable(config)) {\n    return valid(Joi, config);\n  }\n\n  if (Common.isSchema(config)) {\n    return config;\n  }\n\n  if (Array.isArray(config)) {\n    for (const item of config) {\n      if (!internals.simple(item)) {\n        return Joi.alternatives().try(...config);\n      }\n    }\n\n    return valid(Joi, ...config);\n  }\n\n  if (config instanceof RegExp) {\n    return Joi.string().regex(config);\n  }\n\n  if (config instanceof Date) {\n    return valid(Joi.date(), config);\n  }\n\n  Assert(Object.getPrototypeOf(config) === Object.getPrototypeOf({}), 'Schema can only contain plain objects');\n  return Joi.object().keys(config);\n};\n\nexports.ref = function (id, options) {\n  return Ref.isRef(id) ? id : Ref.create(id, options);\n};\n\nexports.compile = function (root, schema, options = {}) {\n  Common.assertOptions(options, ['legacy']); // Compiled by any supported version\n\n  const any = schema && schema[Common.symbols.any];\n\n  if (any) {\n    Assert(options.legacy || any.version === Common.version, 'Cannot mix different versions of joi schemas:', any.version, Common.version);\n    return schema;\n  } // Uncompiled root\n\n\n  if (typeof schema !== 'object' || !options.legacy) {\n    return exports.schema(root, schema, {\n      appendPath: true\n    }); // Will error if schema contains other versions\n  } // Scan schema for compiled parts\n\n\n  const compiler = internals.walk(schema);\n\n  if (!compiler) {\n    return exports.schema(root, schema, {\n      appendPath: true\n    });\n  }\n\n  return compiler.compile(compiler.root, schema);\n};\n\ninternals.walk = function (schema) {\n  if (typeof schema !== 'object') {\n    return null;\n  }\n\n  if (Array.isArray(schema)) {\n    for (const item of schema) {\n      const compiler = internals.walk(item);\n\n      if (compiler) {\n        return compiler;\n      }\n    }\n\n    return null;\n  }\n\n  const any = schema[Common.symbols.any];\n\n  if (any) {\n    return {\n      root: schema[any.root],\n      compile: any.compile\n    };\n  }\n\n  Assert(Object.getPrototypeOf(schema) === Object.getPrototypeOf({}), 'Schema can only contain plain objects');\n\n  for (const key in schema) {\n    const compiler = internals.walk(schema[key]);\n\n    if (compiler) {\n      return compiler;\n    }\n  }\n\n  return null;\n};\n\ninternals.simple = function (value) {\n  return value === null || ['boolean', 'string', 'number'].includes(typeof value);\n};\n\nexports.when = function (schema, condition, options) {\n  if (options === undefined) {\n    Assert(condition && typeof condition === 'object', 'Missing options');\n    options = condition;\n    condition = Ref.create('.');\n  }\n\n  if (Array.isArray(options)) {\n    options = {\n      switch: options\n    };\n  }\n\n  Common.assertOptions(options, ['is', 'not', 'then', 'otherwise', 'switch', 'break']); // Schema condition\n\n  if (Common.isSchema(condition)) {\n    Assert(options.is === undefined, '\"is\" can not be used with a schema condition');\n    Assert(options.not === undefined, '\"not\" can not be used with a schema condition');\n    Assert(options.switch === undefined, '\"switch\" can not be used with a schema condition');\n    return internals.condition(schema, {\n      is: condition,\n      then: options.then,\n      otherwise: options.otherwise,\n      break: options.break\n    });\n  } // Single condition\n\n\n  Assert(Ref.isRef(condition) || typeof condition === 'string', 'Invalid condition:', condition);\n  Assert(options.not === undefined || options.is === undefined, 'Cannot combine \"is\" with \"not\"');\n\n  if (options.switch === undefined) {\n    let rule = options;\n\n    if (options.not !== undefined) {\n      rule = {\n        is: options.not,\n        then: options.otherwise,\n        otherwise: options.then,\n        break: options.break\n      };\n    }\n\n    let is = rule.is !== undefined ? schema.$_compile(rule.is) : schema.$_root.invalid(null, false, 0, '').required();\n    Assert(rule.then !== undefined || rule.otherwise !== undefined, 'options must have at least one of \"then\", \"otherwise\", or \"switch\"');\n    Assert(rule.break === undefined || rule.then === undefined || rule.otherwise === undefined, 'Cannot specify then, otherwise, and break all together');\n\n    if (options.is !== undefined && !Ref.isRef(options.is) && !Common.isSchema(options.is)) {\n      is = is.required(); // Only apply required if this wasn't already a schema or a ref\n    }\n\n    return internals.condition(schema, {\n      ref: exports.ref(condition),\n      is,\n      then: rule.then,\n      otherwise: rule.otherwise,\n      break: rule.break\n    });\n  } // Switch statement\n\n\n  Assert(Array.isArray(options.switch), '\"switch\" must be an array');\n  Assert(options.is === undefined, 'Cannot combine \"switch\" with \"is\"');\n  Assert(options.not === undefined, 'Cannot combine \"switch\" with \"not\"');\n  Assert(options.then === undefined, 'Cannot combine \"switch\" with \"then\"');\n  const rule = {\n    ref: exports.ref(condition),\n    switch: [],\n    break: options.break\n  };\n\n  for (let i = 0; i < options.switch.length; ++i) {\n    const test = options.switch[i];\n    const last = i === options.switch.length - 1;\n    Common.assertOptions(test, last ? ['is', 'then', 'otherwise'] : ['is', 'then']);\n    Assert(test.is !== undefined, 'Switch statement missing \"is\"');\n    Assert(test.then !== undefined, 'Switch statement missing \"then\"');\n    const item = {\n      is: schema.$_compile(test.is),\n      then: schema.$_compile(test.then)\n    };\n\n    if (!Ref.isRef(test.is) && !Common.isSchema(test.is)) {\n      item.is = item.is.required(); // Only apply required if this wasn't already a schema or a ref\n    }\n\n    if (last) {\n      Assert(options.otherwise === undefined || test.otherwise === undefined, 'Cannot specify \"otherwise\" inside and outside a \"switch\"');\n      const otherwise = options.otherwise !== undefined ? options.otherwise : test.otherwise;\n\n      if (otherwise !== undefined) {\n        Assert(rule.break === undefined, 'Cannot specify both otherwise and break');\n        item.otherwise = schema.$_compile(otherwise);\n      }\n    }\n\n    rule.switch.push(item);\n  }\n\n  return rule;\n};\n\ninternals.condition = function (schema, condition) {\n  for (const key of ['then', 'otherwise']) {\n    if (condition[key] === undefined) {\n      delete condition[key];\n    } else {\n      condition[key] = schema.$_compile(condition[key]);\n    }\n  }\n\n  return condition;\n};","map":{"version":3,"sources":["C:/scripting/jobs assignments/whist/backend/node_modules/joi/lib/compile.js"],"names":["Assert","require","Common","Ref","internals","exports","schema","Joi","config","options","assertOptions","err","appendPath","path","undefined","message","Array","isArray","length","valid","base","values","override","simple","custom","isResolvable","isSchema","item","alternatives","try","RegExp","string","regex","Date","date","Object","getPrototypeOf","object","keys","ref","id","isRef","create","compile","root","any","symbols","legacy","version","compiler","walk","key","value","includes","when","condition","switch","is","not","then","otherwise","break","rule","$_compile","$_root","invalid","required","i","test","last","push"],"mappings":"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","sourcesContent":["'use strict';\n\nconst Assert = require('@hapi/hoek/lib/assert');\n\nconst Common = require('./common');\nconst Ref = require('./ref');\n\n\nconst internals = {};\n\n\nexports.schema = function (Joi, config, options = {}) {\n\n    Common.assertOptions(options, ['appendPath', 'override']);\n\n    try {\n        return internals.schema(Joi, config, options);\n    }\n    catch (err) {\n        if (options.appendPath &&\n            err.path !== undefined) {\n\n            err.message = `${err.message} (${err.path})`;\n        }\n\n        throw err;\n    }\n};\n\n\ninternals.schema = function (Joi, config, options) {\n\n    Assert(config !== undefined, 'Invalid undefined schema');\n\n    if (Array.isArray(config)) {\n        Assert(config.length, 'Invalid empty array schema');\n\n        if (config.length === 1) {\n            config = config[0];\n        }\n    }\n\n    const valid = (base, ...values) => {\n\n        if (options.override !== false) {\n            return base.valid(Joi.override, ...values);\n        }\n\n        return base.valid(...values);\n    };\n\n    if (internals.simple(config)) {\n        return valid(Joi, config);\n    }\n\n    if (typeof config === 'function') {\n        return Joi.custom(config);\n    }\n\n    Assert(typeof config === 'object', 'Invalid schema content:', typeof config);\n\n    if (Common.isResolvable(config)) {\n        return valid(Joi, config);\n    }\n\n    if (Common.isSchema(config)) {\n        return config;\n    }\n\n    if (Array.isArray(config)) {\n        for (const item of config) {\n            if (!internals.simple(item)) {\n                return Joi.alternatives().try(...config);\n            }\n        }\n\n        return valid(Joi, ...config);\n    }\n\n    if (config instanceof RegExp) {\n        return Joi.string().regex(config);\n    }\n\n    if (config instanceof Date) {\n        return valid(Joi.date(), config);\n    }\n\n    Assert(Object.getPrototypeOf(config) === Object.getPrototypeOf({}), 'Schema can only contain plain objects');\n\n    return Joi.object().keys(config);\n};\n\n\nexports.ref = function (id, options) {\n\n    return Ref.isRef(id) ? id : Ref.create(id, options);\n};\n\n\nexports.compile = function (root, schema, options = {}) {\n\n    Common.assertOptions(options, ['legacy']);\n\n    // Compiled by any supported version\n\n    const any = schema && schema[Common.symbols.any];\n    if (any) {\n        Assert(options.legacy || any.version === Common.version, 'Cannot mix different versions of joi schemas:', any.version, Common.version);\n        return schema;\n    }\n\n    // Uncompiled root\n\n    if (typeof schema !== 'object' ||\n        !options.legacy) {\n\n        return exports.schema(root, schema, { appendPath: true });          // Will error if schema contains other versions\n    }\n\n    // Scan schema for compiled parts\n\n    const compiler = internals.walk(schema);\n    if (!compiler) {\n        return exports.schema(root, schema, { appendPath: true });\n    }\n\n    return compiler.compile(compiler.root, schema);\n};\n\n\ninternals.walk = function (schema) {\n\n    if (typeof schema !== 'object') {\n        return null;\n    }\n\n    if (Array.isArray(schema)) {\n        for (const item of schema) {\n            const compiler = internals.walk(item);\n            if (compiler) {\n                return compiler;\n            }\n        }\n\n        return null;\n    }\n\n    const any = schema[Common.symbols.any];\n    if (any) {\n        return { root: schema[any.root], compile: any.compile };\n    }\n\n    Assert(Object.getPrototypeOf(schema) === Object.getPrototypeOf({}), 'Schema can only contain plain objects');\n\n    for (const key in schema) {\n        const compiler = internals.walk(schema[key]);\n        if (compiler) {\n            return compiler;\n        }\n    }\n\n    return null;\n};\n\n\ninternals.simple = function (value) {\n\n    return value === null || ['boolean', 'string', 'number'].includes(typeof value);\n};\n\n\nexports.when = function (schema, condition, options) {\n\n    if (options === undefined) {\n        Assert(condition && typeof condition === 'object', 'Missing options');\n\n        options = condition;\n        condition = Ref.create('.');\n    }\n\n    if (Array.isArray(options)) {\n        options = { switch: options };\n    }\n\n    Common.assertOptions(options, ['is', 'not', 'then', 'otherwise', 'switch', 'break']);\n\n    // Schema condition\n\n    if (Common.isSchema(condition)) {\n        Assert(options.is === undefined, '\"is\" can not be used with a schema condition');\n        Assert(options.not === undefined, '\"not\" can not be used with a schema condition');\n        Assert(options.switch === undefined, '\"switch\" can not be used with a schema condition');\n\n        return internals.condition(schema, { is: condition, then: options.then, otherwise: options.otherwise, break: options.break });\n    }\n\n    // Single condition\n\n    Assert(Ref.isRef(condition) || typeof condition === 'string', 'Invalid condition:', condition);\n    Assert(options.not === undefined || options.is === undefined, 'Cannot combine \"is\" with \"not\"');\n\n    if (options.switch === undefined) {\n        let rule = options;\n        if (options.not !== undefined) {\n            rule = { is: options.not, then: options.otherwise, otherwise: options.then, break: options.break };\n        }\n\n        let is = rule.is !== undefined ? schema.$_compile(rule.is) : schema.$_root.invalid(null, false, 0, '').required();\n        Assert(rule.then !== undefined || rule.otherwise !== undefined, 'options must have at least one of \"then\", \"otherwise\", or \"switch\"');\n        Assert(rule.break === undefined || rule.then === undefined || rule.otherwise === undefined, 'Cannot specify then, otherwise, and break all together');\n\n        if (options.is !== undefined &&\n            !Ref.isRef(options.is) &&\n            !Common.isSchema(options.is)) {\n\n            is = is.required();                     // Only apply required if this wasn't already a schema or a ref\n        }\n\n        return internals.condition(schema, { ref: exports.ref(condition), is, then: rule.then, otherwise: rule.otherwise, break: rule.break });\n    }\n\n    // Switch statement\n\n    Assert(Array.isArray(options.switch), '\"switch\" must be an array');\n    Assert(options.is === undefined, 'Cannot combine \"switch\" with \"is\"');\n    Assert(options.not === undefined, 'Cannot combine \"switch\" with \"not\"');\n    Assert(options.then === undefined, 'Cannot combine \"switch\" with \"then\"');\n\n    const rule = {\n        ref: exports.ref(condition),\n        switch: [],\n        break: options.break\n    };\n\n    for (let i = 0; i < options.switch.length; ++i) {\n        const test = options.switch[i];\n        const last = i === options.switch.length - 1;\n\n        Common.assertOptions(test, last ? ['is', 'then', 'otherwise'] : ['is', 'then']);\n\n        Assert(test.is !== undefined, 'Switch statement missing \"is\"');\n        Assert(test.then !== undefined, 'Switch statement missing \"then\"');\n\n        const item = {\n            is: schema.$_compile(test.is),\n            then: schema.$_compile(test.then)\n        };\n\n        if (!Ref.isRef(test.is) &&\n            !Common.isSchema(test.is)) {\n\n            item.is = item.is.required();           // Only apply required if this wasn't already a schema or a ref\n        }\n\n        if (last) {\n            Assert(options.otherwise === undefined || test.otherwise === undefined, 'Cannot specify \"otherwise\" inside and outside a \"switch\"');\n            const otherwise = options.otherwise !== undefined ? options.otherwise : test.otherwise;\n            if (otherwise !== undefined) {\n                Assert(rule.break === undefined, 'Cannot specify both otherwise and break');\n                item.otherwise = schema.$_compile(otherwise);\n            }\n        }\n\n        rule.switch.push(item);\n    }\n\n    return rule;\n};\n\n\ninternals.condition = function (schema, condition) {\n\n    for (const key of ['then', 'otherwise']) {\n        if (condition[key] === undefined) {\n            delete condition[key];\n        }\n        else {\n            condition[key] = schema.$_compile(condition[key]);\n        }\n    }\n\n    return condition;\n};\n"]},"metadata":{},"sourceType":"script"}