{"ast":null,"code":"'use strict';\n\nconst Assert = require('@hapi/hoek/lib/assert');\n\nconst Any = require('./any');\n\nconst internals = {};\ninternals.Map = class extends Map {\n  slice() {\n    return new internals.Map(this);\n  }\n\n};\nmodule.exports = Any.extend({\n  type: 'symbol',\n  terms: {\n    map: {\n      init: new internals.Map()\n    }\n  },\n  coerce: {\n    method(value, {\n      schema,\n      error\n    }) {\n      const lookup = schema.$_terms.map.get(value);\n\n      if (lookup) {\n        value = lookup;\n      }\n\n      if (!schema._flags.only || typeof value === 'symbol') {\n        return {\n          value\n        };\n      }\n\n      return {\n        value,\n        errors: error('symbol.map', {\n          map: schema.$_terms.map\n        })\n      };\n    }\n\n  },\n\n  validate(value, {\n    error\n  }) {\n    if (typeof value !== 'symbol') {\n      return {\n        value,\n        errors: error('symbol.base')\n      };\n    }\n  },\n\n  rules: {\n    map: {\n      method(iterable) {\n        if (iterable && !iterable[Symbol.iterator] && typeof iterable === 'object') {\n          iterable = Object.entries(iterable);\n        }\n\n        Assert(iterable && iterable[Symbol.iterator], 'Iterable must be an iterable or object');\n        const obj = this.clone();\n        const symbols = [];\n\n        for (const entry of iterable) {\n          Assert(entry && entry[Symbol.iterator], 'Entry must be an iterable');\n          const [key, value] = entry;\n          Assert(typeof key !== 'object' && typeof key !== 'function' && typeof key !== 'symbol', 'Key must not be of type object, function, or Symbol');\n          Assert(typeof value === 'symbol', 'Value must be a Symbol');\n          obj.$_terms.map.set(key, value);\n          symbols.push(value);\n        }\n\n        return obj.valid(...symbols);\n      }\n\n    }\n  },\n  manifest: {\n    build(obj, desc) {\n      if (desc.map) {\n        obj = obj.map(desc.map);\n      }\n\n      return obj;\n    }\n\n  },\n  messages: {\n    'symbol.base': '{{#label}} must be a symbol',\n    'symbol.map': '{{#label}} must be one of {{#map}}'\n  }\n});","map":{"version":3,"sources":["C:/scripting/jobs assignments/whist/backend/node_modules/joi/lib/types/symbol.js"],"names":["Assert","require","Any","internals","Map","slice","module","exports","extend","type","terms","map","init","coerce","method","value","schema","error","lookup","$_terms","get","_flags","only","errors","validate","rules","iterable","Symbol","iterator","Object","entries","obj","clone","symbols","entry","key","set","push","valid","manifest","build","desc","messages"],"mappings":"AAAA;;AAEA,MAAMA,MAAM,GAAGC,OAAO,CAAC,uBAAD,CAAtB;;AAEA,MAAMC,GAAG,GAAGD,OAAO,CAAC,OAAD,CAAnB;;AAGA,MAAME,SAAS,GAAG,EAAlB;AAGAA,SAAS,CAACC,GAAV,GAAgB,cAAcA,GAAd,CAAkB;AAE9BC,EAAAA,KAAK,GAAG;AAEJ,WAAO,IAAIF,SAAS,CAACC,GAAd,CAAkB,IAAlB,CAAP;AACH;;AAL6B,CAAlC;AASAE,MAAM,CAACC,OAAP,GAAiBL,GAAG,CAACM,MAAJ,CAAW;AAExBC,EAAAA,IAAI,EAAE,QAFkB;AAIxBC,EAAAA,KAAK,EAAE;AAEHC,IAAAA,GAAG,EAAE;AAAEC,MAAAA,IAAI,EAAE,IAAIT,SAAS,CAACC,GAAd;AAAR;AAFF,GAJiB;AASxBS,EAAAA,MAAM,EAAE;AACJC,IAAAA,MAAM,CAACC,KAAD,EAAQ;AAAEC,MAAAA,MAAF;AAAUC,MAAAA;AAAV,KAAR,EAA2B;AAE7B,YAAMC,MAAM,GAAGF,MAAM,CAACG,OAAP,CAAeR,GAAf,CAAmBS,GAAnB,CAAuBL,KAAvB,CAAf;;AACA,UAAIG,MAAJ,EAAY;AACRH,QAAAA,KAAK,GAAGG,MAAR;AACH;;AAED,UAAI,CAACF,MAAM,CAACK,MAAP,CAAcC,IAAf,IACA,OAAOP,KAAP,KAAiB,QADrB,EAC+B;AAE3B,eAAO;AAAEA,UAAAA;AAAF,SAAP;AACH;;AAED,aAAO;AAAEA,QAAAA,KAAF;AAASQ,QAAAA,MAAM,EAAEN,KAAK,CAAC,YAAD,EAAe;AAAEN,UAAAA,GAAG,EAAEK,MAAM,CAACG,OAAP,CAAeR;AAAtB,SAAf;AAAtB,OAAP;AACH;;AAfG,GATgB;;AA2BxBa,EAAAA,QAAQ,CAACT,KAAD,EAAQ;AAAEE,IAAAA;AAAF,GAAR,EAAmB;AAEvB,QAAI,OAAOF,KAAP,KAAiB,QAArB,EAA+B;AAC3B,aAAO;AAAEA,QAAAA,KAAF;AAASQ,QAAAA,MAAM,EAAEN,KAAK,CAAC,aAAD;AAAtB,OAAP;AACH;AACJ,GAhCuB;;AAkCxBQ,EAAAA,KAAK,EAAE;AACHd,IAAAA,GAAG,EAAE;AACDG,MAAAA,MAAM,CAACY,QAAD,EAAW;AAEb,YAAIA,QAAQ,IACR,CAACA,QAAQ,CAACC,MAAM,CAACC,QAAR,CADT,IAEA,OAAOF,QAAP,KAAoB,QAFxB,EAEkC;AAE9BA,UAAAA,QAAQ,GAAGG,MAAM,CAACC,OAAP,CAAeJ,QAAf,CAAX;AACH;;AAED1B,QAAAA,MAAM,CAAC0B,QAAQ,IAAIA,QAAQ,CAACC,MAAM,CAACC,QAAR,CAArB,EAAwC,wCAAxC,CAAN;AAEA,cAAMG,GAAG,GAAG,KAAKC,KAAL,EAAZ;AAEA,cAAMC,OAAO,GAAG,EAAhB;;AACA,aAAK,MAAMC,KAAX,IAAoBR,QAApB,EAA8B;AAC1B1B,UAAAA,MAAM,CAACkC,KAAK,IAAIA,KAAK,CAACP,MAAM,CAACC,QAAR,CAAf,EAAkC,2BAAlC,CAAN;AACA,gBAAM,CAACO,GAAD,EAAMpB,KAAN,IAAemB,KAArB;AAEAlC,UAAAA,MAAM,CAAC,OAAOmC,GAAP,KAAe,QAAf,IAA2B,OAAOA,GAAP,KAAe,UAA1C,IAAwD,OAAOA,GAAP,KAAe,QAAxE,EAAkF,qDAAlF,CAAN;AACAnC,UAAAA,MAAM,CAAC,OAAOe,KAAP,KAAiB,QAAlB,EAA4B,wBAA5B,CAAN;AAEAgB,UAAAA,GAAG,CAACZ,OAAJ,CAAYR,GAAZ,CAAgByB,GAAhB,CAAoBD,GAApB,EAAyBpB,KAAzB;AACAkB,UAAAA,OAAO,CAACI,IAAR,CAAatB,KAAb;AACH;;AAED,eAAOgB,GAAG,CAACO,KAAJ,CAAU,GAAGL,OAAb,CAAP;AACH;;AA3BA;AADF,GAlCiB;AAkExBM,EAAAA,QAAQ,EAAE;AAENC,IAAAA,KAAK,CAACT,GAAD,EAAMU,IAAN,EAAY;AAEb,UAAIA,IAAI,CAAC9B,GAAT,EAAc;AACVoB,QAAAA,GAAG,GAAGA,GAAG,CAACpB,GAAJ,CAAQ8B,IAAI,CAAC9B,GAAb,CAAN;AACH;;AAED,aAAOoB,GAAP;AACH;;AATK,GAlEc;AA8ExBW,EAAAA,QAAQ,EAAE;AACN,mBAAe,6BADT;AAEN,kBAAc;AAFR;AA9Ec,CAAX,CAAjB","sourcesContent":["'use strict';\n\nconst Assert = require('@hapi/hoek/lib/assert');\n\nconst Any = require('./any');\n\n\nconst internals = {};\n\n\ninternals.Map = class extends Map {\n\n    slice() {\n\n        return new internals.Map(this);\n    }\n};\n\n\nmodule.exports = Any.extend({\n\n    type: 'symbol',\n\n    terms: {\n\n        map: { init: new internals.Map() }\n    },\n\n    coerce: {\n        method(value, { schema, error }) {\n\n            const lookup = schema.$_terms.map.get(value);\n            if (lookup) {\n                value = lookup;\n            }\n\n            if (!schema._flags.only ||\n                typeof value === 'symbol') {\n\n                return { value };\n            }\n\n            return { value, errors: error('symbol.map', { map: schema.$_terms.map }) };\n        }\n    },\n\n    validate(value, { error }) {\n\n        if (typeof value !== 'symbol') {\n            return { value, errors: error('symbol.base') };\n        }\n    },\n\n    rules: {\n        map: {\n            method(iterable) {\n\n                if (iterable &&\n                    !iterable[Symbol.iterator] &&\n                    typeof iterable === 'object') {\n\n                    iterable = Object.entries(iterable);\n                }\n\n                Assert(iterable && iterable[Symbol.iterator], 'Iterable must be an iterable or object');\n\n                const obj = this.clone();\n\n                const symbols = [];\n                for (const entry of iterable) {\n                    Assert(entry && entry[Symbol.iterator], 'Entry must be an iterable');\n                    const [key, value] = entry;\n\n                    Assert(typeof key !== 'object' && typeof key !== 'function' && typeof key !== 'symbol', 'Key must not be of type object, function, or Symbol');\n                    Assert(typeof value === 'symbol', 'Value must be a Symbol');\n\n                    obj.$_terms.map.set(key, value);\n                    symbols.push(value);\n                }\n\n                return obj.valid(...symbols);\n            }\n        }\n    },\n\n    manifest: {\n\n        build(obj, desc) {\n\n            if (desc.map) {\n                obj = obj.map(desc.map);\n            }\n\n            return obj;\n        }\n    },\n\n    messages: {\n        'symbol.base': '{{#label}} must be a symbol',\n        'symbol.map': '{{#label}} must be one of {{#map}}'\n    }\n});\n"]},"metadata":{},"sourceType":"script"}