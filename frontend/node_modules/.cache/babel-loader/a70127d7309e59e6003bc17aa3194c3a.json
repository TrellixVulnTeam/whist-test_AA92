{"ast":null,"code":"'use strict';\n\nconst Clone = require('@hapi/hoek/lib/clone');\n\nconst Common = require('./common');\n\nconst internals = {\n  annotations: Symbol('annotations')\n};\n\nexports.error = function (stripColorCodes) {\n  if (!this._original || typeof this._original !== 'object') {\n    return this.details[0].message;\n  }\n\n  const redFgEscape = stripColorCodes ? '' : '\\u001b[31m';\n  const redBgEscape = stripColorCodes ? '' : '\\u001b[41m';\n  const endColor = stripColorCodes ? '' : '\\u001b[0m';\n  const obj = Clone(this._original);\n\n  for (let i = this.details.length - 1; i >= 0; --i) {\n    // Reverse order to process deepest child first\n    const pos = i + 1;\n    const error = this.details[i];\n    const path = error.path;\n    let node = obj;\n\n    for (let j = 0;; ++j) {\n      const seg = path[j];\n\n      if (Common.isSchema(node)) {\n        node = node.clone(); // joi schemas are not cloned by hoek, we have to take this extra step\n      }\n\n      if (j + 1 < path.length && typeof node[seg] !== 'string') {\n        node = node[seg];\n      } else {\n        const refAnnotations = node[internals.annotations] || {\n          errors: {},\n          missing: {}\n        };\n        node[internals.annotations] = refAnnotations;\n        const cacheKey = seg || error.context.key;\n\n        if (node[seg] !== undefined) {\n          refAnnotations.errors[cacheKey] = refAnnotations.errors[cacheKey] || [];\n          refAnnotations.errors[cacheKey].push(pos);\n        } else {\n          refAnnotations.missing[cacheKey] = pos;\n        }\n\n        break;\n      }\n    }\n  }\n\n  const replacers = {\n    key: /_\\$key\\$_([, \\d]+)_\\$end\\$_\"/g,\n    missing: /\"_\\$miss\\$_([^|]+)\\|(\\d+)_\\$end\\$_\": \"__missing__\"/g,\n    arrayIndex: /\\s*\"_\\$idx\\$_([, \\d]+)_\\$end\\$_\",?\\n(.*)/g,\n    specials: /\"\\[(NaN|Symbol.*|-?Infinity|function.*|\\(.*)]\"/g\n  };\n  let message = internals.safeStringify(obj, 2).replace(replacers.key, ($0, $1) => `\" ${redFgEscape}[${$1}]${endColor}`).replace(replacers.missing, ($0, $1, $2) => `${redBgEscape}\"${$1}\"${endColor}${redFgEscape} [${$2}]: -- missing --${endColor}`).replace(replacers.arrayIndex, ($0, $1, $2) => `\\n${$2} ${redFgEscape}[${$1}]${endColor}`).replace(replacers.specials, ($0, $1) => $1);\n  message = `${message}\\n${redFgEscape}`;\n\n  for (let i = 0; i < this.details.length; ++i) {\n    const pos = i + 1;\n    message = `${message}\\n[${pos}] ${this.details[i].message}`;\n  }\n\n  message = message + endColor;\n  return message;\n}; // Inspired by json-stringify-safe\n\n\ninternals.safeStringify = function (obj, spaces) {\n  return JSON.stringify(obj, internals.serializer(), spaces);\n};\n\ninternals.serializer = function () {\n  const keys = [];\n  const stack = [];\n\n  const cycleReplacer = (key, value) => {\n    if (stack[0] === value) {\n      return '[Circular ~]';\n    }\n\n    return '[Circular ~.' + keys.slice(0, stack.indexOf(value)).join('.') + ']';\n  };\n\n  return function (key, value) {\n    if (stack.length > 0) {\n      const thisPos = stack.indexOf(this);\n\n      if (~thisPos) {\n        stack.length = thisPos + 1;\n        keys.length = thisPos + 1;\n        keys[thisPos] = key;\n      } else {\n        stack.push(this);\n        keys.push(key);\n      }\n\n      if (~stack.indexOf(value)) {\n        value = cycleReplacer.call(this, key, value);\n      }\n    } else {\n      stack.push(value);\n    }\n\n    if (value) {\n      const annotations = value[internals.annotations];\n\n      if (annotations) {\n        if (Array.isArray(value)) {\n          const annotated = [];\n\n          for (let i = 0; i < value.length; ++i) {\n            if (annotations.errors[i]) {\n              annotated.push(`_$idx$_${annotations.errors[i].sort().join(', ')}_$end$_`);\n            }\n\n            annotated.push(value[i]);\n          }\n\n          value = annotated;\n        } else {\n          for (const errorKey in annotations.errors) {\n            value[`${errorKey}_$key$_${annotations.errors[errorKey].sort().join(', ')}_$end$_`] = value[errorKey];\n            value[errorKey] = undefined;\n          }\n\n          for (const missingKey in annotations.missing) {\n            value[`_$miss$_${missingKey}|${annotations.missing[missingKey]}_$end$_`] = '__missing__';\n          }\n        }\n\n        return value;\n      }\n    }\n\n    if (value === Infinity || value === -Infinity || Number.isNaN(value) || typeof value === 'function' || typeof value === 'symbol') {\n      return '[' + value.toString() + ']';\n    }\n\n    return value;\n  };\n};","map":{"version":3,"sources":["C:/scripting/jobs assignments/whist/backend/node_modules/joi/lib/annotate.js"],"names":["Clone","require","Common","internals","annotations","Symbol","exports","error","stripColorCodes","_original","details","message","redFgEscape","redBgEscape","endColor","obj","i","length","pos","path","node","j","seg","isSchema","clone","refAnnotations","errors","missing","cacheKey","context","key","undefined","push","replacers","arrayIndex","specials","safeStringify","replace","$0","$1","$2","spaces","JSON","stringify","serializer","keys","stack","cycleReplacer","value","slice","indexOf","join","thisPos","call","Array","isArray","annotated","sort","errorKey","missingKey","Infinity","Number","isNaN","toString"],"mappings":"AAAA;;AAEA,MAAMA,KAAK,GAAGC,OAAO,CAAC,sBAAD,CAArB;;AAEA,MAAMC,MAAM,GAAGD,OAAO,CAAC,UAAD,CAAtB;;AAGA,MAAME,SAAS,GAAG;AACdC,EAAAA,WAAW,EAAEC,MAAM,CAAC,aAAD;AADL,CAAlB;;AAKAC,OAAO,CAACC,KAAR,GAAgB,UAAUC,eAAV,EAA2B;AAEvC,MAAI,CAAC,KAAKC,SAAN,IACA,OAAO,KAAKA,SAAZ,KAA0B,QAD9B,EACwC;AAEpC,WAAO,KAAKC,OAAL,CAAa,CAAb,EAAgBC,OAAvB;AACH;;AAED,QAAMC,WAAW,GAAGJ,eAAe,GAAG,EAAH,GAAQ,YAA3C;AACA,QAAMK,WAAW,GAAGL,eAAe,GAAG,EAAH,GAAQ,YAA3C;AACA,QAAMM,QAAQ,GAAGN,eAAe,GAAG,EAAH,GAAQ,WAAxC;AAEA,QAAMO,GAAG,GAAGf,KAAK,CAAC,KAAKS,SAAN,CAAjB;;AAEA,OAAK,IAAIO,CAAC,GAAG,KAAKN,OAAL,CAAaO,MAAb,GAAsB,CAAnC,EAAsCD,CAAC,IAAI,CAA3C,EAA8C,EAAEA,CAAhD,EAAmD;AAAS;AACxD,UAAME,GAAG,GAAGF,CAAC,GAAG,CAAhB;AACA,UAAMT,KAAK,GAAG,KAAKG,OAAL,CAAaM,CAAb,CAAd;AACA,UAAMG,IAAI,GAAGZ,KAAK,CAACY,IAAnB;AACA,QAAIC,IAAI,GAAGL,GAAX;;AACA,SAAK,IAAIM,CAAC,GAAG,CAAb,GAAkB,EAAEA,CAApB,EAAuB;AACnB,YAAMC,GAAG,GAAGH,IAAI,CAACE,CAAD,CAAhB;;AAEA,UAAInB,MAAM,CAACqB,QAAP,CAAgBH,IAAhB,CAAJ,EAA2B;AACvBA,QAAAA,IAAI,GAAGA,IAAI,CAACI,KAAL,EAAP,CADuB,CAC2B;AACrD;;AAED,UAAIH,CAAC,GAAG,CAAJ,GAAQF,IAAI,CAACF,MAAb,IACA,OAAOG,IAAI,CAACE,GAAD,CAAX,KAAqB,QADzB,EACmC;AAE/BF,QAAAA,IAAI,GAAGA,IAAI,CAACE,GAAD,CAAX;AACH,OAJD,MAKK;AACD,cAAMG,cAAc,GAAGL,IAAI,CAACjB,SAAS,CAACC,WAAX,CAAJ,IAA+B;AAAEsB,UAAAA,MAAM,EAAE,EAAV;AAAcC,UAAAA,OAAO,EAAE;AAAvB,SAAtD;AACAP,QAAAA,IAAI,CAACjB,SAAS,CAACC,WAAX,CAAJ,GAA8BqB,cAA9B;AAEA,cAAMG,QAAQ,GAAGN,GAAG,IAAIf,KAAK,CAACsB,OAAN,CAAcC,GAAtC;;AAEA,YAAIV,IAAI,CAACE,GAAD,CAAJ,KAAcS,SAAlB,EAA6B;AACzBN,UAAAA,cAAc,CAACC,MAAf,CAAsBE,QAAtB,IAAkCH,cAAc,CAACC,MAAf,CAAsBE,QAAtB,KAAmC,EAArE;AACAH,UAAAA,cAAc,CAACC,MAAf,CAAsBE,QAAtB,EAAgCI,IAAhC,CAAqCd,GAArC;AACH,SAHD,MAIK;AACDO,UAAAA,cAAc,CAACE,OAAf,CAAuBC,QAAvB,IAAmCV,GAAnC;AACH;;AAED;AACH;AACJ;AACJ;;AAED,QAAMe,SAAS,GAAG;AACdH,IAAAA,GAAG,EAAE,+BADS;AAEdH,IAAAA,OAAO,EAAE,qDAFK;AAGdO,IAAAA,UAAU,EAAE,2CAHE;AAIdC,IAAAA,QAAQ,EAAE;AAJI,GAAlB;AAOA,MAAIxB,OAAO,GAAGR,SAAS,CAACiC,aAAV,CAAwBrB,GAAxB,EAA6B,CAA7B,EACTsB,OADS,CACDJ,SAAS,CAACH,GADT,EACc,CAACQ,EAAD,EAAKC,EAAL,KAAa,KAAI3B,WAAY,IAAG2B,EAAG,IAAGzB,QAAS,EAD7D,EAETuB,OAFS,CAEDJ,SAAS,CAACN,OAFT,EAEkB,CAACW,EAAD,EAAKC,EAAL,EAASC,EAAT,KAAiB,GAAE3B,WAAY,IAAG0B,EAAG,IAAGzB,QAAS,GAAEF,WAAY,KAAI4B,EAAG,mBAAkB1B,QAAS,EAFnH,EAGTuB,OAHS,CAGDJ,SAAS,CAACC,UAHT,EAGqB,CAACI,EAAD,EAAKC,EAAL,EAASC,EAAT,KAAiB,KAAIA,EAAG,IAAG5B,WAAY,IAAG2B,EAAG,IAAGzB,QAAS,EAH9E,EAITuB,OAJS,CAIDJ,SAAS,CAACE,QAJT,EAImB,CAACG,EAAD,EAAKC,EAAL,KAAYA,EAJ/B,CAAd;AAMA5B,EAAAA,OAAO,GAAI,GAAEA,OAAQ,KAAIC,WAAY,EAArC;;AAEA,OAAK,IAAII,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKN,OAAL,CAAaO,MAAjC,EAAyC,EAAED,CAA3C,EAA8C;AAC1C,UAAME,GAAG,GAAGF,CAAC,GAAG,CAAhB;AACAL,IAAAA,OAAO,GAAI,GAAEA,OAAQ,MAAKO,GAAI,KAAI,KAAKR,OAAL,CAAaM,CAAb,EAAgBL,OAAQ,EAA1D;AACH;;AAEDA,EAAAA,OAAO,GAAGA,OAAO,GAAGG,QAApB;AAEA,SAAOH,OAAP;AACH,CAzED,C,CA4EA;;;AAEAR,SAAS,CAACiC,aAAV,GAA0B,UAAUrB,GAAV,EAAe0B,MAAf,EAAuB;AAE7C,SAAOC,IAAI,CAACC,SAAL,CAAe5B,GAAf,EAAoBZ,SAAS,CAACyC,UAAV,EAApB,EAA4CH,MAA5C,CAAP;AACH,CAHD;;AAMAtC,SAAS,CAACyC,UAAV,GAAuB,YAAY;AAE/B,QAAMC,IAAI,GAAG,EAAb;AACA,QAAMC,KAAK,GAAG,EAAd;;AAEA,QAAMC,aAAa,GAAG,CAACjB,GAAD,EAAMkB,KAAN,KAAgB;AAElC,QAAIF,KAAK,CAAC,CAAD,CAAL,KAAaE,KAAjB,EAAwB;AACpB,aAAO,cAAP;AACH;;AAED,WAAO,iBAAiBH,IAAI,CAACI,KAAL,CAAW,CAAX,EAAcH,KAAK,CAACI,OAAN,CAAcF,KAAd,CAAd,EAAoCG,IAApC,CAAyC,GAAzC,CAAjB,GAAiE,GAAxE;AACH,GAPD;;AASA,SAAO,UAAUrB,GAAV,EAAekB,KAAf,EAAsB;AAEzB,QAAIF,KAAK,CAAC7B,MAAN,GAAe,CAAnB,EAAsB;AAClB,YAAMmC,OAAO,GAAGN,KAAK,CAACI,OAAN,CAAc,IAAd,CAAhB;;AACA,UAAI,CAACE,OAAL,EAAc;AACVN,QAAAA,KAAK,CAAC7B,MAAN,GAAemC,OAAO,GAAG,CAAzB;AACAP,QAAAA,IAAI,CAAC5B,MAAL,GAAcmC,OAAO,GAAG,CAAxB;AACAP,QAAAA,IAAI,CAACO,OAAD,CAAJ,GAAgBtB,GAAhB;AACH,OAJD,MAKK;AACDgB,QAAAA,KAAK,CAACd,IAAN,CAAW,IAAX;AACAa,QAAAA,IAAI,CAACb,IAAL,CAAUF,GAAV;AACH;;AAED,UAAI,CAACgB,KAAK,CAACI,OAAN,CAAcF,KAAd,CAAL,EAA2B;AACvBA,QAAAA,KAAK,GAAGD,aAAa,CAACM,IAAd,CAAmB,IAAnB,EAAyBvB,GAAzB,EAA8BkB,KAA9B,CAAR;AACH;AACJ,KAfD,MAgBK;AACDF,MAAAA,KAAK,CAACd,IAAN,CAAWgB,KAAX;AACH;;AAED,QAAIA,KAAJ,EAAW;AACP,YAAM5C,WAAW,GAAG4C,KAAK,CAAC7C,SAAS,CAACC,WAAX,CAAzB;;AACA,UAAIA,WAAJ,EAAiB;AACb,YAAIkD,KAAK,CAACC,OAAN,CAAcP,KAAd,CAAJ,EAA0B;AACtB,gBAAMQ,SAAS,GAAG,EAAlB;;AAEA,eAAK,IAAIxC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGgC,KAAK,CAAC/B,MAA1B,EAAkC,EAAED,CAApC,EAAuC;AACnC,gBAAIZ,WAAW,CAACsB,MAAZ,CAAmBV,CAAnB,CAAJ,EAA2B;AACvBwC,cAAAA,SAAS,CAACxB,IAAV,CAAgB,UAAS5B,WAAW,CAACsB,MAAZ,CAAmBV,CAAnB,EAAsByC,IAAtB,GAA6BN,IAA7B,CAAkC,IAAlC,CAAwC,SAAjE;AACH;;AAEDK,YAAAA,SAAS,CAACxB,IAAV,CAAegB,KAAK,CAAChC,CAAD,CAApB;AACH;;AAEDgC,UAAAA,KAAK,GAAGQ,SAAR;AACH,SAZD,MAaK;AACD,eAAK,MAAME,QAAX,IAAuBtD,WAAW,CAACsB,MAAnC,EAA2C;AACvCsB,YAAAA,KAAK,CAAE,GAAEU,QAAS,UAAStD,WAAW,CAACsB,MAAZ,CAAmBgC,QAAnB,EAA6BD,IAA7B,GAAoCN,IAApC,CAAyC,IAAzC,CAA+C,SAArE,CAAL,GAAsFH,KAAK,CAACU,QAAD,CAA3F;AACAV,YAAAA,KAAK,CAACU,QAAD,CAAL,GAAkB3B,SAAlB;AACH;;AAED,eAAK,MAAM4B,UAAX,IAAyBvD,WAAW,CAACuB,OAArC,EAA8C;AAC1CqB,YAAAA,KAAK,CAAE,WAAUW,UAAW,IAAGvD,WAAW,CAACuB,OAAZ,CAAoBgC,UAApB,CAAgC,SAA1D,CAAL,GAA2E,aAA3E;AACH;AACJ;;AAED,eAAOX,KAAP;AACH;AACJ;;AAED,QAAIA,KAAK,KAAKY,QAAV,IACAZ,KAAK,KAAK,CAACY,QADX,IAEAC,MAAM,CAACC,KAAP,CAAad,KAAb,CAFA,IAGA,OAAOA,KAAP,KAAiB,UAHjB,IAIA,OAAOA,KAAP,KAAiB,QAJrB,EAI+B;AAE3B,aAAO,MAAMA,KAAK,CAACe,QAAN,EAAN,GAAyB,GAAhC;AACH;;AAED,WAAOf,KAAP;AACH,GA/DD;AAgEH,CA9ED","sourcesContent":["'use strict';\n\nconst Clone = require('@hapi/hoek/lib/clone');\n\nconst Common = require('./common');\n\n\nconst internals = {\n    annotations: Symbol('annotations')\n};\n\n\nexports.error = function (stripColorCodes) {\n\n    if (!this._original ||\n        typeof this._original !== 'object') {\n\n        return this.details[0].message;\n    }\n\n    const redFgEscape = stripColorCodes ? '' : '\\u001b[31m';\n    const redBgEscape = stripColorCodes ? '' : '\\u001b[41m';\n    const endColor = stripColorCodes ? '' : '\\u001b[0m';\n\n    const obj = Clone(this._original);\n\n    for (let i = this.details.length - 1; i >= 0; --i) {        // Reverse order to process deepest child first\n        const pos = i + 1;\n        const error = this.details[i];\n        const path = error.path;\n        let node = obj;\n        for (let j = 0; ; ++j) {\n            const seg = path[j];\n\n            if (Common.isSchema(node)) {\n                node = node.clone();                              // joi schemas are not cloned by hoek, we have to take this extra step\n            }\n\n            if (j + 1 < path.length &&\n                typeof node[seg] !== 'string') {\n\n                node = node[seg];\n            }\n            else {\n                const refAnnotations = node[internals.annotations] || { errors: {}, missing: {} };\n                node[internals.annotations] = refAnnotations;\n\n                const cacheKey = seg || error.context.key;\n\n                if (node[seg] !== undefined) {\n                    refAnnotations.errors[cacheKey] = refAnnotations.errors[cacheKey] || [];\n                    refAnnotations.errors[cacheKey].push(pos);\n                }\n                else {\n                    refAnnotations.missing[cacheKey] = pos;\n                }\n\n                break;\n            }\n        }\n    }\n\n    const replacers = {\n        key: /_\\$key\\$_([, \\d]+)_\\$end\\$_\"/g,\n        missing: /\"_\\$miss\\$_([^|]+)\\|(\\d+)_\\$end\\$_\": \"__missing__\"/g,\n        arrayIndex: /\\s*\"_\\$idx\\$_([, \\d]+)_\\$end\\$_\",?\\n(.*)/g,\n        specials: /\"\\[(NaN|Symbol.*|-?Infinity|function.*|\\(.*)]\"/g\n    };\n\n    let message = internals.safeStringify(obj, 2)\n        .replace(replacers.key, ($0, $1) => `\" ${redFgEscape}[${$1}]${endColor}`)\n        .replace(replacers.missing, ($0, $1, $2) => `${redBgEscape}\"${$1}\"${endColor}${redFgEscape} [${$2}]: -- missing --${endColor}`)\n        .replace(replacers.arrayIndex, ($0, $1, $2) => `\\n${$2} ${redFgEscape}[${$1}]${endColor}`)\n        .replace(replacers.specials, ($0, $1) => $1);\n\n    message = `${message}\\n${redFgEscape}`;\n\n    for (let i = 0; i < this.details.length; ++i) {\n        const pos = i + 1;\n        message = `${message}\\n[${pos}] ${this.details[i].message}`;\n    }\n\n    message = message + endColor;\n\n    return message;\n};\n\n\n// Inspired by json-stringify-safe\n\ninternals.safeStringify = function (obj, spaces) {\n\n    return JSON.stringify(obj, internals.serializer(), spaces);\n};\n\n\ninternals.serializer = function () {\n\n    const keys = [];\n    const stack = [];\n\n    const cycleReplacer = (key, value) => {\n\n        if (stack[0] === value) {\n            return '[Circular ~]';\n        }\n\n        return '[Circular ~.' + keys.slice(0, stack.indexOf(value)).join('.') + ']';\n    };\n\n    return function (key, value) {\n\n        if (stack.length > 0) {\n            const thisPos = stack.indexOf(this);\n            if (~thisPos) {\n                stack.length = thisPos + 1;\n                keys.length = thisPos + 1;\n                keys[thisPos] = key;\n            }\n            else {\n                stack.push(this);\n                keys.push(key);\n            }\n\n            if (~stack.indexOf(value)) {\n                value = cycleReplacer.call(this, key, value);\n            }\n        }\n        else {\n            stack.push(value);\n        }\n\n        if (value) {\n            const annotations = value[internals.annotations];\n            if (annotations) {\n                if (Array.isArray(value)) {\n                    const annotated = [];\n\n                    for (let i = 0; i < value.length; ++i) {\n                        if (annotations.errors[i]) {\n                            annotated.push(`_$idx$_${annotations.errors[i].sort().join(', ')}_$end$_`);\n                        }\n\n                        annotated.push(value[i]);\n                    }\n\n                    value = annotated;\n                }\n                else {\n                    for (const errorKey in annotations.errors) {\n                        value[`${errorKey}_$key$_${annotations.errors[errorKey].sort().join(', ')}_$end$_`] = value[errorKey];\n                        value[errorKey] = undefined;\n                    }\n\n                    for (const missingKey in annotations.missing) {\n                        value[`_$miss$_${missingKey}|${annotations.missing[missingKey]}_$end$_`] = '__missing__';\n                    }\n                }\n\n                return value;\n            }\n        }\n\n        if (value === Infinity ||\n            value === -Infinity ||\n            Number.isNaN(value) ||\n            typeof value === 'function' ||\n            typeof value === 'symbol') {\n\n            return '[' + value.toString() + ']';\n        }\n\n        return value;\n    };\n};\n"]},"metadata":{},"sourceType":"script"}