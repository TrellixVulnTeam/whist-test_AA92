{"ast":null,"code":"'use strict';\n\nconst Assert = require('@hapi/hoek/lib/assert');\n\nconst Common = require('./common');\n\nconst Ref = require('./ref');\n\nconst internals = {};\nexports.Ids = internals.Ids = class {\n  constructor() {\n    this._byId = new Map();\n    this._byKey = new Map();\n    this._schemaChain = false;\n  }\n\n  clone() {\n    const clone = new internals.Ids();\n    clone._byId = new Map(this._byId);\n    clone._byKey = new Map(this._byKey);\n    clone._schemaChain = this._schemaChain;\n    return clone;\n  }\n\n  concat(source) {\n    if (source._schemaChain) {\n      this._schemaChain = true;\n    }\n\n    for (const [id, value] of source._byId.entries()) {\n      Assert(!this._byKey.has(id), 'Schema id conflicts with existing key:', id);\n\n      this._byId.set(id, value);\n    }\n\n    for (const [key, value] of source._byKey.entries()) {\n      Assert(!this._byId.has(key), 'Schema key conflicts with existing id:', key);\n\n      this._byKey.set(key, value);\n    }\n  }\n\n  fork(path, adjuster, root) {\n    const chain = this._collect(path);\n\n    chain.push({\n      schema: root\n    });\n    const tail = chain.shift();\n    let adjusted = {\n      id: tail.id,\n      schema: adjuster(tail.schema)\n    };\n    Assert(Common.isSchema(adjusted.schema), 'adjuster function failed to return a joi schema type');\n\n    for (const node of chain) {\n      adjusted = {\n        id: node.id,\n        schema: internals.fork(node.schema, adjusted.id, adjusted.schema)\n      };\n    }\n\n    return adjusted.schema;\n  }\n\n  labels(path, behind = []) {\n    const current = path[0];\n\n    const node = this._get(current);\n\n    if (!node) {\n      return [...behind, ...path].join('.');\n    }\n\n    const forward = path.slice(1);\n    behind = [...behind, node.schema._flags.label || current];\n\n    if (!forward.length) {\n      return behind.join('.');\n    }\n\n    return node.schema._ids.labels(forward, behind);\n  }\n\n  reach(path, behind = []) {\n    const current = path[0];\n\n    const node = this._get(current);\n\n    Assert(node, 'Schema does not contain path', [...behind, ...path].join('.'));\n    const forward = path.slice(1);\n\n    if (!forward.length) {\n      return node.schema;\n    }\n\n    return node.schema._ids.reach(forward, [...behind, current]);\n  }\n\n  register(schema, {\n    key\n  } = {}) {\n    if (!schema || !Common.isSchema(schema)) {\n      return;\n    }\n\n    if (schema.$_property('schemaChain') || schema._ids._schemaChain) {\n      this._schemaChain = true;\n    }\n\n    const id = schema._flags.id;\n\n    if (id) {\n      const existing = this._byId.get(id);\n\n      Assert(!existing || existing.schema === schema, 'Cannot add different schemas with the same id:', id);\n      Assert(!this._byKey.has(id), 'Schema id conflicts with existing key:', id);\n\n      this._byId.set(id, {\n        schema,\n        id\n      });\n    }\n\n    if (key) {\n      Assert(!this._byKey.has(key), 'Schema already contains key:', key);\n      Assert(!this._byId.has(key), 'Schema key conflicts with existing id:', key);\n\n      this._byKey.set(key, {\n        schema,\n        id: key\n      });\n    }\n  }\n\n  reset() {\n    this._byId = new Map();\n    this._byKey = new Map();\n    this._schemaChain = false;\n  }\n\n  _collect(path, behind = [], nodes = []) {\n    const current = path[0];\n\n    const node = this._get(current);\n\n    Assert(node, 'Schema does not contain path', [...behind, ...path].join('.'));\n    nodes = [node, ...nodes];\n    const forward = path.slice(1);\n\n    if (!forward.length) {\n      return nodes;\n    }\n\n    return node.schema._ids._collect(forward, [...behind, current], nodes);\n  }\n\n  _get(id) {\n    return this._byId.get(id) || this._byKey.get(id);\n  }\n\n};\n\ninternals.fork = function (schema, id, replacement) {\n  const each = (item, {\n    key\n  }) => {\n    if (id === (item._flags.id || key)) {\n      return replacement;\n    }\n  };\n\n  const obj = exports.schema(schema, {\n    each,\n    ref: false\n  });\n  return obj ? obj.$_mutateRebuild() : schema;\n};\n\nexports.schema = function (schema, options) {\n  let obj;\n\n  for (const name in schema._flags) {\n    if (name[0] === '_') {\n      continue;\n    }\n\n    const result = internals.scan(schema._flags[name], {\n      source: 'flags',\n      name\n    }, options);\n\n    if (result !== undefined) {\n      obj = obj || schema.clone();\n      obj._flags[name] = result;\n    }\n  }\n\n  for (let i = 0; i < schema._rules.length; ++i) {\n    const rule = schema._rules[i];\n    const result = internals.scan(rule.args, {\n      source: 'rules',\n      name: rule.name\n    }, options);\n\n    if (result !== undefined) {\n      obj = obj || schema.clone();\n      const clone = Object.assign({}, rule);\n      clone.args = result;\n      obj._rules[i] = clone;\n\n      const existingUnique = obj._singleRules.get(rule.name);\n\n      if (existingUnique === rule) {\n        obj._singleRules.set(rule.name, clone);\n      }\n    }\n  }\n\n  for (const name in schema.$_terms) {\n    if (name[0] === '_') {\n      continue;\n    }\n\n    const result = internals.scan(schema.$_terms[name], {\n      source: 'terms',\n      name\n    }, options);\n\n    if (result !== undefined) {\n      obj = obj || schema.clone();\n      obj.$_terms[name] = result;\n    }\n  }\n\n  return obj;\n};\n\ninternals.scan = function (item, source, options, _path, _key) {\n  const path = _path || [];\n\n  if (item === null || typeof item !== 'object') {\n    return;\n  }\n\n  let clone;\n\n  if (Array.isArray(item)) {\n    for (let i = 0; i < item.length; ++i) {\n      const key = source.source === 'terms' && source.name === 'keys' && item[i].key;\n      const result = internals.scan(item[i], source, options, [i, ...path], key);\n\n      if (result !== undefined) {\n        clone = clone || item.slice();\n        clone[i] = result;\n      }\n    }\n\n    return clone;\n  }\n\n  if (options.schema !== false && Common.isSchema(item) || options.ref !== false && Ref.isRef(item)) {\n    const result = options.each(item, { ...source,\n      path,\n      key: _key\n    });\n\n    if (result === item) {\n      return;\n    }\n\n    return result;\n  }\n\n  for (const key in item) {\n    if (key[0] === '_') {\n      continue;\n    }\n\n    const result = internals.scan(item[key], source, options, [key, ...path], _key);\n\n    if (result !== undefined) {\n      clone = clone || Object.assign({}, item);\n      clone[key] = result;\n    }\n  }\n\n  return clone;\n};","map":{"version":3,"sources":["C:/scripting/jobs assignments/whist/backend/node_modules/joi/lib/modify.js"],"names":["Assert","require","Common","Ref","internals","exports","Ids","constructor","_byId","Map","_byKey","_schemaChain","clone","concat","source","id","value","entries","has","set","key","fork","path","adjuster","root","chain","_collect","push","schema","tail","shift","adjusted","isSchema","node","labels","behind","current","_get","join","forward","slice","_flags","label","length","_ids","reach","register","$_property","existing","get","reset","nodes","replacement","each","item","obj","ref","$_mutateRebuild","options","name","result","scan","undefined","i","_rules","rule","args","Object","assign","existingUnique","_singleRules","$_terms","_path","_key","Array","isArray","isRef"],"mappings":"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","sourcesContent":["'use strict';\n\nconst Assert = require('@hapi/hoek/lib/assert');\n\nconst Common = require('./common');\nconst Ref = require('./ref');\n\n\nconst internals = {};\n\n\n\nexports.Ids = internals.Ids = class {\n\n    constructor() {\n\n        this._byId = new Map();\n        this._byKey = new Map();\n        this._schemaChain = false;\n    }\n\n    clone() {\n\n        const clone = new internals.Ids();\n        clone._byId = new Map(this._byId);\n        clone._byKey = new Map(this._byKey);\n        clone._schemaChain = this._schemaChain;\n        return clone;\n    }\n\n    concat(source) {\n\n        if (source._schemaChain) {\n            this._schemaChain = true;\n        }\n\n        for (const [id, value] of source._byId.entries()) {\n            Assert(!this._byKey.has(id), 'Schema id conflicts with existing key:', id);\n            this._byId.set(id, value);\n        }\n\n        for (const [key, value] of source._byKey.entries()) {\n            Assert(!this._byId.has(key), 'Schema key conflicts with existing id:', key);\n            this._byKey.set(key, value);\n        }\n    }\n\n    fork(path, adjuster, root) {\n\n        const chain = this._collect(path);\n        chain.push({ schema: root });\n        const tail = chain.shift();\n        let adjusted = { id: tail.id, schema: adjuster(tail.schema) };\n\n        Assert(Common.isSchema(adjusted.schema), 'adjuster function failed to return a joi schema type');\n\n        for (const node of chain) {\n            adjusted = { id: node.id, schema: internals.fork(node.schema, adjusted.id, adjusted.schema) };\n        }\n\n        return adjusted.schema;\n    }\n\n    labels(path, behind = []) {\n\n        const current = path[0];\n        const node = this._get(current);\n        if (!node) {\n            return [...behind, ...path].join('.');\n        }\n\n        const forward = path.slice(1);\n        behind = [...behind, node.schema._flags.label || current];\n        if (!forward.length) {\n            return behind.join('.');\n        }\n\n        return node.schema._ids.labels(forward, behind);\n    }\n\n    reach(path, behind = []) {\n\n        const current = path[0];\n        const node = this._get(current);\n        Assert(node, 'Schema does not contain path', [...behind, ...path].join('.'));\n\n        const forward = path.slice(1);\n        if (!forward.length) {\n            return node.schema;\n        }\n\n        return node.schema._ids.reach(forward, [...behind, current]);\n    }\n\n    register(schema, { key } = {}) {\n\n        if (!schema ||\n            !Common.isSchema(schema)) {\n\n            return;\n        }\n\n        if (schema.$_property('schemaChain') ||\n            schema._ids._schemaChain) {\n\n            this._schemaChain = true;\n        }\n\n        const id = schema._flags.id;\n        if (id) {\n            const existing = this._byId.get(id);\n            Assert(!existing || existing.schema === schema, 'Cannot add different schemas with the same id:', id);\n            Assert(!this._byKey.has(id), 'Schema id conflicts with existing key:', id);\n\n            this._byId.set(id, { schema, id });\n        }\n\n        if (key) {\n            Assert(!this._byKey.has(key), 'Schema already contains key:', key);\n            Assert(!this._byId.has(key), 'Schema key conflicts with existing id:', key);\n\n            this._byKey.set(key, { schema, id: key });\n        }\n    }\n\n    reset() {\n\n        this._byId = new Map();\n        this._byKey = new Map();\n        this._schemaChain = false;\n    }\n\n    _collect(path, behind = [], nodes = []) {\n\n        const current = path[0];\n        const node = this._get(current);\n        Assert(node, 'Schema does not contain path', [...behind, ...path].join('.'));\n\n        nodes = [node, ...nodes];\n\n        const forward = path.slice(1);\n        if (!forward.length) {\n            return nodes;\n        }\n\n        return node.schema._ids._collect(forward, [...behind, current], nodes);\n    }\n\n    _get(id) {\n\n        return this._byId.get(id) || this._byKey.get(id);\n    }\n};\n\n\ninternals.fork = function (schema, id, replacement) {\n\n    const each = (item, { key }) => {\n\n        if (id === (item._flags.id || key)) {\n            return replacement;\n        }\n    };\n\n    const obj = exports.schema(schema, { each, ref: false });\n    return obj ? obj.$_mutateRebuild() : schema;\n};\n\n\nexports.schema = function (schema, options) {\n\n    let obj;\n\n    for (const name in schema._flags) {\n        if (name[0] === '_') {\n            continue;\n        }\n\n        const result = internals.scan(schema._flags[name], { source: 'flags', name }, options);\n        if (result !== undefined) {\n            obj = obj || schema.clone();\n            obj._flags[name] = result;\n        }\n    }\n\n    for (let i = 0; i < schema._rules.length; ++i) {\n        const rule = schema._rules[i];\n        const result = internals.scan(rule.args, { source: 'rules', name: rule.name }, options);\n        if (result !== undefined) {\n            obj = obj || schema.clone();\n            const clone = Object.assign({}, rule);\n            clone.args = result;\n            obj._rules[i] = clone;\n\n            const existingUnique = obj._singleRules.get(rule.name);\n            if (existingUnique === rule) {\n                obj._singleRules.set(rule.name, clone);\n            }\n        }\n    }\n\n    for (const name in schema.$_terms) {\n        if (name[0] === '_') {\n            continue;\n        }\n\n        const result = internals.scan(schema.$_terms[name], { source: 'terms', name }, options);\n        if (result !== undefined) {\n            obj = obj || schema.clone();\n            obj.$_terms[name] = result;\n        }\n    }\n\n    return obj;\n};\n\n\ninternals.scan = function (item, source, options, _path, _key) {\n\n    const path = _path || [];\n\n    if (item === null ||\n        typeof item !== 'object') {\n\n        return;\n    }\n\n    let clone;\n\n    if (Array.isArray(item)) {\n        for (let i = 0; i < item.length; ++i) {\n            const key = source.source === 'terms' && source.name === 'keys' && item[i].key;\n            const result = internals.scan(item[i], source, options, [i, ...path], key);\n            if (result !== undefined) {\n                clone = clone || item.slice();\n                clone[i] = result;\n            }\n        }\n\n        return clone;\n    }\n\n    if (options.schema !== false && Common.isSchema(item) ||\n        options.ref !== false && Ref.isRef(item)) {\n\n        const result = options.each(item, { ...source, path, key: _key });\n        if (result === item) {\n            return;\n        }\n\n        return result;\n    }\n\n    for (const key in item) {\n        if (key[0] === '_') {\n            continue;\n        }\n\n        const result = internals.scan(item[key], source, options, [key, ...path], _key);\n        if (result !== undefined) {\n            clone = clone || Object.assign({}, item);\n            clone[key] = result;\n        }\n    }\n\n    return clone;\n};\n"]},"metadata":{},"sourceType":"script"}