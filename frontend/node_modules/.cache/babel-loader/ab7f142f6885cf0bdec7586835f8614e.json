{"ast":null,"code":"'use strict';\n\nconst Util = require('util');\n\nconst Domain = require('./domain');\n\nconst Errors = require('./errors');\n\nconst internals = {\n  nonAsciiRx: /[^\\x00-\\x7f]/,\n  encoder: new (Util.TextEncoder || TextEncoder)() // $lab:coverage:ignore$\n\n};\n\nexports.analyze = function (email, options) {\n  return internals.email(email, options);\n};\n\nexports.isValid = function (email, options) {\n  return !internals.email(email, options);\n};\n\ninternals.email = function (email, options = {}) {\n  if (typeof email !== 'string') {\n    throw new Error('Invalid input: email must be a string');\n  }\n\n  if (!email) {\n    return Errors.code('EMPTY_STRING');\n  } // Unicode\n\n\n  const ascii = !internals.nonAsciiRx.test(email);\n\n  if (!ascii) {\n    if (options.allowUnicode === false) {\n      // Defaults to true\n      return Errors.code('FORBIDDEN_UNICODE');\n    }\n\n    email = email.normalize('NFC');\n  } // Basic structure\n\n\n  const parts = email.split('@');\n\n  if (parts.length !== 2) {\n    return parts.length > 2 ? Errors.code('MULTIPLE_AT_CHAR') : Errors.code('MISSING_AT_CHAR');\n  }\n\n  const [local, domain] = parts;\n\n  if (!local) {\n    return Errors.code('EMPTY_LOCAL');\n  }\n\n  if (!options.ignoreLength) {\n    if (email.length > 254) {\n      // http://tools.ietf.org/html/rfc5321#section-4.5.3.1.3\n      return Errors.code('ADDRESS_TOO_LONG');\n    }\n\n    if (internals.encoder.encode(local).length > 64) {\n      // http://tools.ietf.org/html/rfc5321#section-4.5.3.1.1\n      return Errors.code('LOCAL_TOO_LONG');\n    }\n  } // Validate parts\n\n\n  return internals.local(local, ascii) || Domain.analyze(domain, options);\n};\n\ninternals.local = function (local, ascii) {\n  const segments = local.split('.');\n\n  for (const segment of segments) {\n    if (!segment.length) {\n      return Errors.code('EMPTY_LOCAL_SEGMENT');\n    }\n\n    if (ascii) {\n      if (!internals.atextRx.test(segment)) {\n        return Errors.code('INVALID_LOCAL_CHARS');\n      }\n\n      continue;\n    }\n\n    for (const char of segment) {\n      if (internals.atextRx.test(char)) {\n        continue;\n      }\n\n      const binary = internals.binary(char);\n\n      if (!internals.atomRx.test(binary)) {\n        return Errors.code('INVALID_LOCAL_CHARS');\n      }\n    }\n  }\n};\n\ninternals.binary = function (char) {\n  return Array.from(internals.encoder.encode(char)).map(v => String.fromCharCode(v)).join('');\n};\n/*\n    From RFC 5321:\n\n        Mailbox         =   Local-part \"@\" ( Domain / address-literal )\n\n        Local-part      =   Dot-string / Quoted-string\n        Dot-string      =   Atom *(\".\"  Atom)\n        Atom            =   1*atext\n        atext           =   ALPHA / DIGIT / \"!\" / \"#\" / \"$\" / \"%\" / \"&\" / \"'\" / \"*\" / \"+\" / \"-\" / \"/\" / \"=\" / \"?\" / \"^\" / \"_\" / \"`\" / \"{\" / \"|\" / \"}\" / \"~\"\n\n        Domain          =   sub-domain *(\".\" sub-domain)\n        sub-domain      =   Let-dig [Ldh-str]\n        Let-dig         =   ALPHA / DIGIT\n        Ldh-str         =   *( ALPHA / DIGIT / \"-\" ) Let-dig\n\n        ALPHA           =   %x41-5A / %x61-7A        ; a-z, A-Z\n        DIGIT           =   %x30-39                  ; 0-9\n\n    From RFC 6531:\n\n        sub-domain      =/  U-label\n        atext           =/  UTF8-non-ascii\n\n        UTF8-non-ascii  =   UTF8-2 / UTF8-3 / UTF8-4\n\n        UTF8-2          =   %xC2-DF UTF8-tail\n        UTF8-3          =   %xE0 %xA0-BF UTF8-tail /\n                            %xE1-EC 2( UTF8-tail ) /\n                            %xED %x80-9F UTF8-tail /\n                            %xEE-EF 2( UTF8-tail )\n        UTF8-4          =   %xF0 %x90-BF 2( UTF8-tail ) /\n                            %xF1-F3 3( UTF8-tail ) /\n                            %xF4 %x80-8F 2( UTF8-tail )\n\n        UTF8-tail       =   %x80-BF\n\n    Note: The following are not supported:\n\n        RFC 5321: address-literal, Quoted-string\n        RFC 5322: obs-*, CFWS\n*/\n\n\ninternals.atextRx = /^[\\w!#\\$%&'\\*\\+\\-/=\\?\\^`\\{\\|\\}~]+$/; // _ included in \\w\n\ninternals.atomRx = new RegExp([//  %xC2-DF UTF8-tail\n'(?:[\\\\xc2-\\\\xdf][\\\\x80-\\\\xbf])', //  %xE0 %xA0-BF UTF8-tail              %xE1-EC 2( UTF8-tail )            %xED %x80-9F UTF8-tail              %xEE-EF 2( UTF8-tail )\n'(?:\\\\xe0[\\\\xa0-\\\\xbf][\\\\x80-\\\\xbf])|(?:[\\\\xe1-\\\\xec][\\\\x80-\\\\xbf]{2})|(?:\\\\xed[\\\\x80-\\\\x9f][\\\\x80-\\\\xbf])|(?:[\\\\xee-\\\\xef][\\\\x80-\\\\xbf]{2})', //  %xF0 %x90-BF 2( UTF8-tail )            %xF1-F3 3( UTF8-tail )            %xF4 %x80-8F 2( UTF8-tail )\n'(?:\\\\xf0[\\\\x90-\\\\xbf][\\\\x80-\\\\xbf]{2})|(?:[\\\\xf1-\\\\xf3][\\\\x80-\\\\xbf]{3})|(?:\\\\xf4[\\\\x80-\\\\x8f][\\\\x80-\\\\xbf]{2})'].join('|'));","map":{"version":3,"sources":["C:/scripting/jobs assignments/whist/backend/node_modules/@sideway/address/lib/email.js"],"names":["Util","require","Domain","Errors","internals","nonAsciiRx","encoder","TextEncoder","exports","analyze","email","options","isValid","Error","code","ascii","test","allowUnicode","normalize","parts","split","length","local","domain","ignoreLength","encode","segments","segment","atextRx","char","binary","atomRx","Array","from","map","v","String","fromCharCode","join","RegExp"],"mappings":"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","sourcesContent":["'use strict';\n\nconst Util = require('util');\n\nconst Domain = require('./domain');\nconst Errors = require('./errors');\n\n\nconst internals = {\n    nonAsciiRx: /[^\\x00-\\x7f]/,\n    encoder: new (Util.TextEncoder || TextEncoder)()                                            // $lab:coverage:ignore$\n};\n\n\nexports.analyze = function (email, options) {\n\n    return internals.email(email, options);\n};\n\n\nexports.isValid = function (email, options) {\n\n    return !internals.email(email, options);\n};\n\n\ninternals.email = function (email, options = {}) {\n\n    if (typeof email !== 'string') {\n        throw new Error('Invalid input: email must be a string');\n    }\n\n    if (!email) {\n        return Errors.code('EMPTY_STRING');\n    }\n\n    // Unicode\n\n    const ascii = !internals.nonAsciiRx.test(email);\n    if (!ascii) {\n        if (options.allowUnicode === false) {                                                   // Defaults to true\n            return Errors.code('FORBIDDEN_UNICODE');\n        }\n\n        email = email.normalize('NFC');\n    }\n\n    // Basic structure\n\n    const parts = email.split('@');\n    if (parts.length !== 2) {\n        return parts.length > 2 ? Errors.code('MULTIPLE_AT_CHAR') : Errors.code('MISSING_AT_CHAR');\n    }\n\n    const [local, domain] = parts;\n\n    if (!local) {\n        return Errors.code('EMPTY_LOCAL');\n    }\n\n    if (!options.ignoreLength) {\n        if (email.length > 254) {                                           // http://tools.ietf.org/html/rfc5321#section-4.5.3.1.3\n            return Errors.code('ADDRESS_TOO_LONG');\n        }\n\n        if (internals.encoder.encode(local).length > 64) {                  // http://tools.ietf.org/html/rfc5321#section-4.5.3.1.1\n            return Errors.code('LOCAL_TOO_LONG');\n        }\n    }\n\n    // Validate parts\n\n    return internals.local(local, ascii) || Domain.analyze(domain, options);\n};\n\n\ninternals.local = function (local, ascii) {\n\n    const segments = local.split('.');\n    for (const segment of segments) {\n        if (!segment.length) {\n            return Errors.code('EMPTY_LOCAL_SEGMENT');\n        }\n\n        if (ascii) {\n            if (!internals.atextRx.test(segment)) {\n                return Errors.code('INVALID_LOCAL_CHARS');\n            }\n\n            continue;\n        }\n\n        for (const char of segment) {\n            if (internals.atextRx.test(char)) {\n                continue;\n            }\n\n            const binary = internals.binary(char);\n            if (!internals.atomRx.test(binary)) {\n                return Errors.code('INVALID_LOCAL_CHARS');\n            }\n        }\n    }\n};\n\n\ninternals.binary = function (char) {\n\n    return Array.from(internals.encoder.encode(char)).map((v) => String.fromCharCode(v)).join('');\n};\n\n\n/*\n    From RFC 5321:\n\n        Mailbox         =   Local-part \"@\" ( Domain / address-literal )\n\n        Local-part      =   Dot-string / Quoted-string\n        Dot-string      =   Atom *(\".\"  Atom)\n        Atom            =   1*atext\n        atext           =   ALPHA / DIGIT / \"!\" / \"#\" / \"$\" / \"%\" / \"&\" / \"'\" / \"*\" / \"+\" / \"-\" / \"/\" / \"=\" / \"?\" / \"^\" / \"_\" / \"`\" / \"{\" / \"|\" / \"}\" / \"~\"\n\n        Domain          =   sub-domain *(\".\" sub-domain)\n        sub-domain      =   Let-dig [Ldh-str]\n        Let-dig         =   ALPHA / DIGIT\n        Ldh-str         =   *( ALPHA / DIGIT / \"-\" ) Let-dig\n\n        ALPHA           =   %x41-5A / %x61-7A        ; a-z, A-Z\n        DIGIT           =   %x30-39                  ; 0-9\n\n    From RFC 6531:\n\n        sub-domain      =/  U-label\n        atext           =/  UTF8-non-ascii\n\n        UTF8-non-ascii  =   UTF8-2 / UTF8-3 / UTF8-4\n\n        UTF8-2          =   %xC2-DF UTF8-tail\n        UTF8-3          =   %xE0 %xA0-BF UTF8-tail /\n                            %xE1-EC 2( UTF8-tail ) /\n                            %xED %x80-9F UTF8-tail /\n                            %xEE-EF 2( UTF8-tail )\n        UTF8-4          =   %xF0 %x90-BF 2( UTF8-tail ) /\n                            %xF1-F3 3( UTF8-tail ) /\n                            %xF4 %x80-8F 2( UTF8-tail )\n\n        UTF8-tail       =   %x80-BF\n\n    Note: The following are not supported:\n\n        RFC 5321: address-literal, Quoted-string\n        RFC 5322: obs-*, CFWS\n*/\n\n\ninternals.atextRx = /^[\\w!#\\$%&'\\*\\+\\-/=\\?\\^`\\{\\|\\}~]+$/;               // _ included in \\w\n\n\ninternals.atomRx = new RegExp([\n\n    //  %xC2-DF UTF8-tail\n    '(?:[\\\\xc2-\\\\xdf][\\\\x80-\\\\xbf])',\n\n    //  %xE0 %xA0-BF UTF8-tail              %xE1-EC 2( UTF8-tail )            %xED %x80-9F UTF8-tail              %xEE-EF 2( UTF8-tail )\n    '(?:\\\\xe0[\\\\xa0-\\\\xbf][\\\\x80-\\\\xbf])|(?:[\\\\xe1-\\\\xec][\\\\x80-\\\\xbf]{2})|(?:\\\\xed[\\\\x80-\\\\x9f][\\\\x80-\\\\xbf])|(?:[\\\\xee-\\\\xef][\\\\x80-\\\\xbf]{2})',\n\n    //  %xF0 %x90-BF 2( UTF8-tail )            %xF1-F3 3( UTF8-tail )            %xF4 %x80-8F 2( UTF8-tail )\n    '(?:\\\\xf0[\\\\x90-\\\\xbf][\\\\x80-\\\\xbf]{2})|(?:[\\\\xf1-\\\\xf3][\\\\x80-\\\\xbf]{3})|(?:\\\\xf4[\\\\x80-\\\\x8f][\\\\x80-\\\\xbf]{2})'\n\n].join('|'));\n"]},"metadata":{},"sourceType":"script"}