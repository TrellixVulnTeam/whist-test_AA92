{"ast":null,"code":"'use strict';\n\nconst Assert = require('@hapi/hoek/lib/assert');\n\nconst Clone = require('@hapi/hoek/lib/clone');\n\nconst Ignore = require('@hapi/hoek/lib/ignore');\n\nconst Reach = require('@hapi/hoek/lib/reach');\n\nconst Common = require('./common');\n\nconst Errors = require('./errors');\n\nconst State = require('./state');\n\nconst internals = {\n  result: Symbol('result')\n};\n\nexports.entry = function (value, schema, prefs) {\n  let settings = Common.defaults;\n\n  if (prefs) {\n    Assert(prefs.warnings === undefined, 'Cannot override warnings preference in synchronous validation');\n    Assert(prefs.artifacts === undefined, 'Cannot override artifacts preference in synchronous validation');\n    settings = Common.preferences(Common.defaults, prefs);\n  }\n\n  const result = internals.entry(value, schema, settings);\n  Assert(!result.mainstay.externals.length, 'Schema with external rules must use validateAsync()');\n  const outcome = {\n    value: result.value\n  };\n\n  if (result.error) {\n    outcome.error = result.error;\n  }\n\n  if (result.mainstay.warnings.length) {\n    outcome.warning = Errors.details(result.mainstay.warnings);\n  }\n\n  if (result.mainstay.debug) {\n    outcome.debug = result.mainstay.debug;\n  }\n\n  if (result.mainstay.artifacts) {\n    outcome.artifacts = result.mainstay.artifacts;\n  }\n\n  return outcome;\n};\n\nexports.entryAsync = async function (value, schema, prefs) {\n  let settings = Common.defaults;\n\n  if (prefs) {\n    settings = Common.preferences(Common.defaults, prefs);\n  }\n\n  const result = internals.entry(value, schema, settings);\n  const mainstay = result.mainstay;\n\n  if (result.error) {\n    if (mainstay.debug) {\n      result.error.debug = mainstay.debug;\n    }\n\n    throw result.error;\n  }\n\n  if (mainstay.externals.length) {\n    let root = result.value;\n\n    for (const {\n      method,\n      path,\n      label\n    } of mainstay.externals) {\n      let node = root;\n      let key;\n      let parent;\n\n      if (path.length) {\n        key = path[path.length - 1];\n        parent = Reach(root, path.slice(0, -1));\n        node = parent[key];\n      }\n\n      try {\n        const output = await method(node, {\n          prefs\n        });\n\n        if (output === undefined || output === node) {\n          continue;\n        }\n\n        if (parent) {\n          parent[key] = output;\n        } else {\n          root = output;\n        }\n      } catch (err) {\n        err.message += ` (${label})`; // Change message to include path\n\n        throw err;\n      }\n    }\n\n    result.value = root;\n  }\n\n  if (!settings.warnings && !settings.debug && !settings.artifacts) {\n    return result.value;\n  }\n\n  const outcome = {\n    value: result.value\n  };\n\n  if (mainstay.warnings.length) {\n    outcome.warning = Errors.details(mainstay.warnings);\n  }\n\n  if (mainstay.debug) {\n    outcome.debug = mainstay.debug;\n  }\n\n  if (mainstay.artifacts) {\n    outcome.artifacts = mainstay.artifacts;\n  }\n\n  return outcome;\n};\n\ninternals.entry = function (value, schema, prefs) {\n  // Prepare state\n  const {\n    tracer,\n    cleanup\n  } = internals.tracer(schema, prefs);\n  const debug = prefs.debug ? [] : null;\n  const links = schema._ids._schemaChain ? new Map() : null;\n  const mainstay = {\n    externals: [],\n    warnings: [],\n    tracer,\n    debug,\n    links\n  };\n  const schemas = schema._ids._schemaChain ? [{\n    schema\n  }] : null;\n  const state = new State([], [], {\n    mainstay,\n    schemas\n  }); // Validate value\n\n  const result = exports.validate(value, schema, state, prefs); // Process value and errors\n\n  if (cleanup) {\n    schema.$_root.untrace();\n  }\n\n  const error = Errors.process(result.errors, value, prefs);\n  return {\n    value: result.value,\n    error,\n    mainstay\n  };\n};\n\ninternals.tracer = function (schema, prefs) {\n  if (schema.$_root._tracer) {\n    return {\n      tracer: schema.$_root._tracer._register(schema)\n    };\n  }\n\n  if (prefs.debug) {\n    Assert(schema.$_root.trace, 'Debug mode not supported');\n    return {\n      tracer: schema.$_root.trace()._register(schema),\n      cleanup: true\n    };\n  }\n\n  return {\n    tracer: internals.ignore\n  };\n};\n\nexports.validate = function (value, schema, state, prefs, overrides = {}) {\n  if (schema.$_terms.whens) {\n    schema = schema._generate(value, state, prefs).schema;\n  } // Setup state and settings\n\n\n  if (schema._preferences) {\n    prefs = internals.prefs(schema, prefs);\n  } // Cache\n\n\n  if (schema._cache && prefs.cache) {\n    const result = schema._cache.get(value);\n\n    state.mainstay.tracer.debug(state, 'validate', 'cached', !!result);\n\n    if (result) {\n      return result;\n    }\n  } // Helpers\n\n\n  const createError = (code, local, localState) => schema.$_createError(code, value, local, localState || state, prefs);\n\n  const helpers = {\n    original: value,\n    prefs,\n    schema,\n    state,\n    error: createError,\n    errorsArray: internals.errorsArray,\n    warn: (code, local, localState) => state.mainstay.warnings.push(createError(code, local, localState)),\n    message: (messages, local) => schema.$_createError('custom', value, local, state, prefs, {\n      messages\n    })\n  }; // Prepare\n\n  state.mainstay.tracer.entry(schema, state);\n  const def = schema._definition;\n\n  if (def.prepare && value !== undefined && prefs.convert) {\n    const prepared = def.prepare(value, helpers);\n\n    if (prepared) {\n      state.mainstay.tracer.value(state, 'prepare', value, prepared.value);\n\n      if (prepared.errors) {\n        return internals.finalize(prepared.value, [].concat(prepared.errors), helpers); // Prepare error always aborts early\n      }\n\n      value = prepared.value;\n    }\n  } // Type coercion\n\n\n  if (def.coerce && value !== undefined && prefs.convert && (!def.coerce.from || def.coerce.from.includes(typeof value))) {\n    const coerced = def.coerce.method(value, helpers);\n\n    if (coerced) {\n      state.mainstay.tracer.value(state, 'coerced', value, coerced.value);\n\n      if (coerced.errors) {\n        return internals.finalize(coerced.value, [].concat(coerced.errors), helpers); // Coerce error always aborts early\n      }\n\n      value = coerced.value;\n    }\n  } // Empty value\n\n\n  const empty = schema._flags.empty;\n\n  if (empty && empty.$_match(internals.trim(value, schema), state.nest(empty), Common.defaults)) {\n    state.mainstay.tracer.value(state, 'empty', value, undefined);\n    value = undefined;\n  } // Presence requirements (required, optional, forbidden)\n\n\n  const presence = overrides.presence || schema._flags.presence || (schema._flags._endedSwitch ? null : prefs.presence);\n\n  if (value === undefined) {\n    if (presence === 'forbidden') {\n      return internals.finalize(value, null, helpers);\n    }\n\n    if (presence === 'required') {\n      return internals.finalize(value, [schema.$_createError('any.required', value, null, state, prefs)], helpers);\n    }\n\n    if (presence === 'optional') {\n      if (schema._flags.default !== Common.symbols.deepDefault) {\n        return internals.finalize(value, null, helpers);\n      }\n\n      state.mainstay.tracer.value(state, 'default', value, {});\n      value = {};\n    }\n  } else if (presence === 'forbidden') {\n    return internals.finalize(value, [schema.$_createError('any.unknown', value, null, state, prefs)], helpers);\n  } // Allowed values\n\n\n  const errors = [];\n\n  if (schema._valids) {\n    const match = schema._valids.get(value, state, prefs, schema._flags.insensitive);\n\n    if (match) {\n      if (prefs.convert) {\n        state.mainstay.tracer.value(state, 'valids', value, match.value);\n        value = match.value;\n      }\n\n      state.mainstay.tracer.filter(schema, state, 'valid', match);\n      return internals.finalize(value, null, helpers);\n    }\n\n    if (schema._flags.only) {\n      const report = schema.$_createError('any.only', value, {\n        valids: schema._valids.values({\n          display: true\n        })\n      }, state, prefs);\n\n      if (prefs.abortEarly) {\n        return internals.finalize(value, [report], helpers);\n      }\n\n      errors.push(report);\n    }\n  } // Denied values\n\n\n  if (schema._invalids) {\n    const match = schema._invalids.get(value, state, prefs, schema._flags.insensitive);\n\n    if (match) {\n      state.mainstay.tracer.filter(schema, state, 'invalid', match);\n      const report = schema.$_createError('any.invalid', value, {\n        invalids: schema._invalids.values({\n          display: true\n        })\n      }, state, prefs);\n\n      if (prefs.abortEarly) {\n        return internals.finalize(value, [report], helpers);\n      }\n\n      errors.push(report);\n    }\n  } // Base type\n\n\n  if (def.validate) {\n    const base = def.validate(value, helpers);\n\n    if (base) {\n      state.mainstay.tracer.value(state, 'base', value, base.value);\n      value = base.value;\n\n      if (base.errors) {\n        if (!Array.isArray(base.errors)) {\n          errors.push(base.errors);\n          return internals.finalize(value, errors, helpers); // Base error always aborts early\n        }\n\n        if (base.errors.length) {\n          errors.push(...base.errors);\n          return internals.finalize(value, errors, helpers); // Base error always aborts early\n        }\n      }\n    }\n  } // Validate tests\n\n\n  if (!schema._rules.length) {\n    return internals.finalize(value, errors, helpers);\n  }\n\n  return internals.rules(value, errors, helpers);\n};\n\ninternals.rules = function (value, errors, helpers) {\n  const {\n    schema,\n    state,\n    prefs\n  } = helpers;\n\n  for (const rule of schema._rules) {\n    const definition = schema._definition.rules[rule.method]; // Skip rules that are also applied in coerce step\n\n    if (definition.convert && prefs.convert) {\n      state.mainstay.tracer.log(schema, state, 'rule', rule.name, 'full');\n      continue;\n    } // Resolve references\n\n\n    let ret;\n    let args = rule.args;\n\n    if (rule._resolve.length) {\n      args = Object.assign({}, args); // Shallow copy\n\n      for (const key of rule._resolve) {\n        const resolver = definition.argsByName.get(key);\n        const resolved = args[key].resolve(value, state, prefs);\n        const normalized = resolver.normalize ? resolver.normalize(resolved) : resolved;\n        const invalid = Common.validateArg(normalized, null, resolver);\n\n        if (invalid) {\n          ret = schema.$_createError('any.ref', resolved, {\n            arg: key,\n            ref: args[key],\n            reason: invalid\n          }, state, prefs);\n          break;\n        }\n\n        args[key] = normalized;\n      }\n    } // Test rule\n\n\n    ret = ret || definition.validate(value, helpers, args, rule); // Use ret if already set to reference error\n\n    const result = internals.rule(ret, rule);\n\n    if (result.errors) {\n      state.mainstay.tracer.log(schema, state, 'rule', rule.name, 'error');\n\n      if (rule.warn) {\n        state.mainstay.warnings.push(...result.errors);\n        continue;\n      }\n\n      if (prefs.abortEarly) {\n        return internals.finalize(value, result.errors, helpers);\n      }\n\n      errors.push(...result.errors);\n    } else {\n      state.mainstay.tracer.log(schema, state, 'rule', rule.name, 'pass');\n      state.mainstay.tracer.value(state, 'rule', value, result.value, rule.name);\n      value = result.value;\n    }\n  }\n\n  return internals.finalize(value, errors, helpers);\n};\n\ninternals.rule = function (ret, rule) {\n  if (ret instanceof Errors.Report) {\n    internals.error(ret, rule);\n    return {\n      errors: [ret],\n      value: null\n    };\n  }\n\n  if (Array.isArray(ret) && ret[Common.symbols.errors]) {\n    ret.forEach(report => internals.error(report, rule));\n    return {\n      errors: ret,\n      value: null\n    };\n  }\n\n  return {\n    errors: null,\n    value: ret\n  };\n};\n\ninternals.error = function (report, rule) {\n  if (rule.message) {\n    report._setTemplate(rule.message);\n  }\n\n  return report;\n};\n\ninternals.finalize = function (value, errors, helpers) {\n  errors = errors || [];\n  const {\n    schema,\n    state,\n    prefs\n  } = helpers; // Failover value\n\n  if (errors.length) {\n    const failover = internals.default('failover', undefined, errors, helpers);\n\n    if (failover !== undefined) {\n      state.mainstay.tracer.value(state, 'failover', value, failover);\n      value = failover;\n      errors = [];\n    }\n  } // Error override\n\n\n  if (errors.length && schema._flags.error) {\n    if (typeof schema._flags.error === 'function') {\n      errors = schema._flags.error(errors);\n\n      if (!Array.isArray(errors)) {\n        errors = [errors];\n      }\n\n      for (const error of errors) {\n        Assert(error instanceof Error || error instanceof Errors.Report, 'error() must return an Error object');\n      }\n    } else {\n      errors = [schema._flags.error];\n    }\n  } // Default\n\n\n  if (value === undefined) {\n    const defaulted = internals.default('default', value, errors, helpers);\n    state.mainstay.tracer.value(state, 'default', value, defaulted);\n    value = defaulted;\n  } // Cast\n\n\n  if (schema._flags.cast && value !== undefined) {\n    const caster = schema._definition.cast[schema._flags.cast];\n\n    if (caster.from(value)) {\n      const casted = caster.to(value, helpers);\n      state.mainstay.tracer.value(state, 'cast', value, casted, schema._flags.cast);\n      value = casted;\n    }\n  } // Externals\n\n\n  if (schema.$_terms.externals && prefs.externals && prefs._externals !== false) {\n    // Disabled for matching\n    for (const {\n      method\n    } of schema.$_terms.externals) {\n      state.mainstay.externals.push({\n        method,\n        path: state.path,\n        label: Errors.label(schema._flags, state, prefs)\n      });\n    }\n  } // Result\n\n\n  const result = {\n    value,\n    errors: errors.length ? errors : null\n  };\n\n  if (schema._flags.result) {\n    result.value = schema._flags.result === 'strip' ? undefined :\n    /* raw */\n    helpers.original;\n    state.mainstay.tracer.value(state, schema._flags.result, value, result.value);\n    state.shadow(value, schema._flags.result);\n  } // Cache\n\n\n  if (schema._cache && prefs.cache !== false && !schema._refs.length) {\n    schema._cache.set(helpers.original, result);\n  } // Artifacts\n\n\n  if (value !== undefined && !result.errors && schema._flags.artifact !== undefined) {\n    state.mainstay.artifacts = state.mainstay.artifacts || new Map();\n\n    if (!state.mainstay.artifacts.has(schema._flags.artifact)) {\n      state.mainstay.artifacts.set(schema._flags.artifact, []);\n    }\n\n    state.mainstay.artifacts.get(schema._flags.artifact).push(state.path);\n  }\n\n  return result;\n};\n\ninternals.prefs = function (schema, prefs) {\n  const isDefaultOptions = prefs === Common.defaults;\n\n  if (isDefaultOptions && schema._preferences[Common.symbols.prefs]) {\n    return schema._preferences[Common.symbols.prefs];\n  }\n\n  prefs = Common.preferences(prefs, schema._preferences);\n\n  if (isDefaultOptions) {\n    schema._preferences[Common.symbols.prefs] = prefs;\n  }\n\n  return prefs;\n};\n\ninternals.default = function (flag, value, errors, helpers) {\n  const {\n    schema,\n    state,\n    prefs\n  } = helpers;\n  const source = schema._flags[flag];\n\n  if (prefs.noDefaults || source === undefined) {\n    return value;\n  }\n\n  state.mainstay.tracer.log(schema, state, 'rule', flag, 'full');\n\n  if (!source) {\n    return source;\n  }\n\n  if (typeof source === 'function') {\n    const args = source.length ? [Clone(state.ancestors[0]), helpers] : [];\n\n    try {\n      return source(...args);\n    } catch (err) {\n      errors.push(schema.$_createError(`any.${flag}`, null, {\n        error: err\n      }, state, prefs));\n      return;\n    }\n  }\n\n  if (typeof source !== 'object') {\n    return source;\n  }\n\n  if (source[Common.symbols.literal]) {\n    return source.literal;\n  }\n\n  if (Common.isResolvable(source)) {\n    return source.resolve(value, state, prefs);\n  }\n\n  return Clone(source);\n};\n\ninternals.trim = function (value, schema) {\n  if (typeof value !== 'string') {\n    return value;\n  }\n\n  const trim = schema.$_getRule('trim');\n\n  if (!trim || !trim.args.enabled) {\n    return value;\n  }\n\n  return value.trim();\n};\n\ninternals.ignore = {\n  active: false,\n  debug: Ignore,\n  entry: Ignore,\n  filter: Ignore,\n  log: Ignore,\n  resolve: Ignore,\n  value: Ignore\n};\n\ninternals.errorsArray = function () {\n  const errors = [];\n  errors[Common.symbols.errors] = true;\n  return errors;\n};","map":{"version":3,"sources":["C:/scripting/jobs assignments/whist/backend/node_modules/joi/lib/validator.js"],"names":["Assert","require","Clone","Ignore","Reach","Common","Errors","State","internals","result","Symbol","exports","entry","value","schema","prefs","settings","defaults","warnings","undefined","artifacts","preferences","mainstay","externals","length","outcome","error","warning","details","debug","entryAsync","root","method","path","label","node","key","parent","slice","output","err","message","tracer","cleanup","links","_ids","_schemaChain","Map","schemas","state","validate","$_root","untrace","process","errors","_tracer","_register","trace","ignore","overrides","$_terms","whens","_generate","_preferences","_cache","cache","get","createError","code","local","localState","$_createError","helpers","original","errorsArray","warn","push","messages","def","_definition","prepare","convert","prepared","finalize","concat","coerce","from","includes","coerced","empty","_flags","$_match","trim","nest","presence","_endedSwitch","default","symbols","deepDefault","_valids","match","insensitive","filter","only","report","valids","values","display","abortEarly","_invalids","invalids","base","Array","isArray","_rules","rules","rule","definition","log","name","ret","args","_resolve","Object","assign","resolver","argsByName","resolved","resolve","normalized","normalize","invalid","validateArg","arg","ref","reason","Report","forEach","_setTemplate","failover","Error","defaulted","cast","caster","casted","to","_externals","shadow","_refs","set","artifact","has","isDefaultOptions","flag","source","noDefaults","ancestors","literal","isResolvable","$_getRule","enabled","active"],"mappings":"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","sourcesContent":["'use strict';\n\nconst Assert = require('@hapi/hoek/lib/assert');\nconst Clone = require('@hapi/hoek/lib/clone');\nconst Ignore = require('@hapi/hoek/lib/ignore');\nconst Reach = require('@hapi/hoek/lib/reach');\n\nconst Common = require('./common');\nconst Errors = require('./errors');\nconst State = require('./state');\n\n\nconst internals = {\n    result: Symbol('result')\n};\n\n\nexports.entry = function (value, schema, prefs) {\n\n    let settings = Common.defaults;\n    if (prefs) {\n        Assert(prefs.warnings === undefined, 'Cannot override warnings preference in synchronous validation');\n        Assert(prefs.artifacts === undefined, 'Cannot override artifacts preference in synchronous validation');\n        settings = Common.preferences(Common.defaults, prefs);\n    }\n\n    const result = internals.entry(value, schema, settings);\n    Assert(!result.mainstay.externals.length, 'Schema with external rules must use validateAsync()');\n    const outcome = { value: result.value };\n\n    if (result.error) {\n        outcome.error = result.error;\n    }\n\n    if (result.mainstay.warnings.length) {\n        outcome.warning = Errors.details(result.mainstay.warnings);\n    }\n\n    if (result.mainstay.debug) {\n        outcome.debug = result.mainstay.debug;\n    }\n\n    if (result.mainstay.artifacts) {\n        outcome.artifacts = result.mainstay.artifacts;\n    }\n\n    return outcome;\n};\n\n\nexports.entryAsync = async function (value, schema, prefs) {\n\n    let settings = Common.defaults;\n    if (prefs) {\n        settings = Common.preferences(Common.defaults, prefs);\n    }\n\n    const result = internals.entry(value, schema, settings);\n    const mainstay = result.mainstay;\n    if (result.error) {\n        if (mainstay.debug) {\n            result.error.debug = mainstay.debug;\n        }\n\n        throw result.error;\n    }\n\n    if (mainstay.externals.length) {\n        let root = result.value;\n        for (const { method, path, label } of mainstay.externals) {\n            let node = root;\n            let key;\n            let parent;\n\n            if (path.length) {\n                key = path[path.length - 1];\n                parent = Reach(root, path.slice(0, -1));\n                node = parent[key];\n            }\n\n            try {\n                const output = await method(node, { prefs });\n                if (output === undefined ||\n                    output === node) {\n\n                    continue;\n                }\n\n                if (parent) {\n                    parent[key] = output;\n                }\n                else {\n                    root = output;\n                }\n            }\n            catch (err) {\n                err.message += ` (${label})`;       // Change message to include path\n                throw err;\n            }\n        }\n\n        result.value = root;\n    }\n\n    if (!settings.warnings &&\n        !settings.debug &&\n        !settings.artifacts) {\n\n        return result.value;\n    }\n\n    const outcome = { value: result.value };\n    if (mainstay.warnings.length) {\n        outcome.warning = Errors.details(mainstay.warnings);\n    }\n\n    if (mainstay.debug) {\n        outcome.debug = mainstay.debug;\n    }\n\n    if (mainstay.artifacts) {\n        outcome.artifacts = mainstay.artifacts;\n    }\n\n    return outcome;\n};\n\n\ninternals.entry = function (value, schema, prefs) {\n\n    // Prepare state\n\n    const { tracer, cleanup } = internals.tracer(schema, prefs);\n    const debug = prefs.debug ? [] : null;\n    const links = schema._ids._schemaChain ? new Map() : null;\n    const mainstay = { externals: [], warnings: [], tracer, debug, links };\n    const schemas = schema._ids._schemaChain ? [{ schema }] : null;\n    const state = new State([], [], { mainstay, schemas });\n\n    // Validate value\n\n    const result = exports.validate(value, schema, state, prefs);\n\n    // Process value and errors\n\n    if (cleanup) {\n        schema.$_root.untrace();\n    }\n\n    const error = Errors.process(result.errors, value, prefs);\n    return { value: result.value, error, mainstay };\n};\n\n\ninternals.tracer = function (schema, prefs) {\n\n    if (schema.$_root._tracer) {\n        return { tracer: schema.$_root._tracer._register(schema) };\n    }\n\n    if (prefs.debug) {\n        Assert(schema.$_root.trace, 'Debug mode not supported');\n        return { tracer: schema.$_root.trace()._register(schema), cleanup: true };\n    }\n\n    return { tracer: internals.ignore };\n};\n\n\nexports.validate = function (value, schema, state, prefs, overrides = {}) {\n\n    if (schema.$_terms.whens) {\n        schema = schema._generate(value, state, prefs).schema;\n    }\n\n    // Setup state and settings\n\n    if (schema._preferences) {\n        prefs = internals.prefs(schema, prefs);\n    }\n\n    // Cache\n\n    if (schema._cache &&\n        prefs.cache) {\n\n        const result = schema._cache.get(value);\n        state.mainstay.tracer.debug(state, 'validate', 'cached', !!result);\n        if (result) {\n            return result;\n        }\n    }\n\n    // Helpers\n\n    const createError = (code, local, localState) => schema.$_createError(code, value, local, localState || state, prefs);\n    const helpers = {\n        original: value,\n        prefs,\n        schema,\n        state,\n        error: createError,\n        errorsArray: internals.errorsArray,\n        warn: (code, local, localState) => state.mainstay.warnings.push(createError(code, local, localState)),\n        message: (messages, local) => schema.$_createError('custom', value, local, state, prefs, { messages })\n    };\n\n    // Prepare\n\n    state.mainstay.tracer.entry(schema, state);\n\n    const def = schema._definition;\n    if (def.prepare &&\n        value !== undefined &&\n        prefs.convert) {\n\n        const prepared = def.prepare(value, helpers);\n        if (prepared) {\n            state.mainstay.tracer.value(state, 'prepare', value, prepared.value);\n            if (prepared.errors) {\n                return internals.finalize(prepared.value, [].concat(prepared.errors), helpers);         // Prepare error always aborts early\n            }\n\n            value = prepared.value;\n        }\n    }\n\n    // Type coercion\n\n    if (def.coerce &&\n        value !== undefined &&\n        prefs.convert &&\n        (!def.coerce.from || def.coerce.from.includes(typeof value))) {\n\n        const coerced = def.coerce.method(value, helpers);\n        if (coerced) {\n            state.mainstay.tracer.value(state, 'coerced', value, coerced.value);\n            if (coerced.errors) {\n                return internals.finalize(coerced.value, [].concat(coerced.errors), helpers);           // Coerce error always aborts early\n            }\n\n            value = coerced.value;\n        }\n    }\n\n    // Empty value\n\n    const empty = schema._flags.empty;\n    if (empty &&\n        empty.$_match(internals.trim(value, schema), state.nest(empty), Common.defaults)) {\n\n        state.mainstay.tracer.value(state, 'empty', value, undefined);\n        value = undefined;\n    }\n\n    // Presence requirements (required, optional, forbidden)\n\n    const presence = overrides.presence || schema._flags.presence || (schema._flags._endedSwitch ? null : prefs.presence);\n    if (value === undefined) {\n        if (presence === 'forbidden') {\n            return internals.finalize(value, null, helpers);\n        }\n\n        if (presence === 'required') {\n            return internals.finalize(value, [schema.$_createError('any.required', value, null, state, prefs)], helpers);\n        }\n\n        if (presence === 'optional') {\n            if (schema._flags.default !== Common.symbols.deepDefault) {\n                return internals.finalize(value, null, helpers);\n            }\n\n            state.mainstay.tracer.value(state, 'default', value, {});\n            value = {};\n        }\n    }\n    else if (presence === 'forbidden') {\n        return internals.finalize(value, [schema.$_createError('any.unknown', value, null, state, prefs)], helpers);\n    }\n\n    // Allowed values\n\n    const errors = [];\n\n    if (schema._valids) {\n        const match = schema._valids.get(value, state, prefs, schema._flags.insensitive);\n        if (match) {\n            if (prefs.convert) {\n                state.mainstay.tracer.value(state, 'valids', value, match.value);\n                value = match.value;\n            }\n\n            state.mainstay.tracer.filter(schema, state, 'valid', match);\n            return internals.finalize(value, null, helpers);\n        }\n\n        if (schema._flags.only) {\n            const report = schema.$_createError('any.only', value, { valids: schema._valids.values({ display: true }) }, state, prefs);\n            if (prefs.abortEarly) {\n                return internals.finalize(value, [report], helpers);\n            }\n\n            errors.push(report);\n        }\n    }\n\n    // Denied values\n\n    if (schema._invalids) {\n        const match = schema._invalids.get(value, state, prefs, schema._flags.insensitive);\n        if (match) {\n            state.mainstay.tracer.filter(schema, state, 'invalid', match);\n            const report = schema.$_createError('any.invalid', value, { invalids: schema._invalids.values({ display: true }) }, state, prefs);\n            if (prefs.abortEarly) {\n                return internals.finalize(value, [report], helpers);\n            }\n\n            errors.push(report);\n        }\n    }\n\n    // Base type\n\n    if (def.validate) {\n        const base = def.validate(value, helpers);\n        if (base) {\n            state.mainstay.tracer.value(state, 'base', value, base.value);\n            value = base.value;\n\n            if (base.errors) {\n                if (!Array.isArray(base.errors)) {\n                    errors.push(base.errors);\n                    return internals.finalize(value, errors, helpers);          // Base error always aborts early\n                }\n\n                if (base.errors.length) {\n                    errors.push(...base.errors);\n                    return internals.finalize(value, errors, helpers);          // Base error always aborts early\n                }\n            }\n        }\n    }\n\n    // Validate tests\n\n    if (!schema._rules.length) {\n        return internals.finalize(value, errors, helpers);\n    }\n\n    return internals.rules(value, errors, helpers);\n};\n\n\ninternals.rules = function (value, errors, helpers) {\n\n    const { schema, state, prefs } = helpers;\n\n    for (const rule of schema._rules) {\n        const definition = schema._definition.rules[rule.method];\n\n        // Skip rules that are also applied in coerce step\n\n        if (definition.convert &&\n            prefs.convert) {\n\n            state.mainstay.tracer.log(schema, state, 'rule', rule.name, 'full');\n            continue;\n        }\n\n        // Resolve references\n\n        let ret;\n        let args = rule.args;\n        if (rule._resolve.length) {\n            args = Object.assign({}, args);                                     // Shallow copy\n            for (const key of rule._resolve) {\n                const resolver = definition.argsByName.get(key);\n\n                const resolved = args[key].resolve(value, state, prefs);\n                const normalized = resolver.normalize ? resolver.normalize(resolved) : resolved;\n\n                const invalid = Common.validateArg(normalized, null, resolver);\n                if (invalid) {\n                    ret = schema.$_createError('any.ref', resolved, { arg: key, ref: args[key], reason: invalid }, state, prefs);\n                    break;\n                }\n\n                args[key] = normalized;\n            }\n        }\n\n        // Test rule\n\n        ret = ret || definition.validate(value, helpers, args, rule);           // Use ret if already set to reference error\n\n        const result = internals.rule(ret, rule);\n        if (result.errors) {\n            state.mainstay.tracer.log(schema, state, 'rule', rule.name, 'error');\n\n            if (rule.warn) {\n                state.mainstay.warnings.push(...result.errors);\n                continue;\n            }\n\n            if (prefs.abortEarly) {\n                return internals.finalize(value, result.errors, helpers);\n            }\n\n            errors.push(...result.errors);\n        }\n        else {\n            state.mainstay.tracer.log(schema, state, 'rule', rule.name, 'pass');\n            state.mainstay.tracer.value(state, 'rule', value, result.value, rule.name);\n            value = result.value;\n        }\n    }\n\n    return internals.finalize(value, errors, helpers);\n};\n\n\ninternals.rule = function (ret, rule) {\n\n    if (ret instanceof Errors.Report) {\n        internals.error(ret, rule);\n        return { errors: [ret], value: null };\n    }\n\n    if (Array.isArray(ret) &&\n        ret[Common.symbols.errors]) {\n\n        ret.forEach((report) => internals.error(report, rule));\n        return { errors: ret, value: null };\n    }\n\n    return { errors: null, value: ret };\n};\n\n\ninternals.error = function (report, rule) {\n\n    if (rule.message) {\n        report._setTemplate(rule.message);\n    }\n\n    return report;\n};\n\n\ninternals.finalize = function (value, errors, helpers) {\n\n    errors = errors || [];\n    const { schema, state, prefs } = helpers;\n\n    // Failover value\n\n    if (errors.length) {\n        const failover = internals.default('failover', undefined, errors, helpers);\n        if (failover !== undefined) {\n            state.mainstay.tracer.value(state, 'failover', value, failover);\n            value = failover;\n            errors = [];\n        }\n    }\n\n    // Error override\n\n    if (errors.length &&\n        schema._flags.error) {\n\n        if (typeof schema._flags.error === 'function') {\n            errors = schema._flags.error(errors);\n            if (!Array.isArray(errors)) {\n                errors = [errors];\n            }\n\n            for (const error of errors) {\n                Assert(error instanceof Error || error instanceof Errors.Report, 'error() must return an Error object');\n            }\n        }\n        else {\n            errors = [schema._flags.error];\n        }\n    }\n\n    // Default\n\n    if (value === undefined) {\n        const defaulted = internals.default('default', value, errors, helpers);\n        state.mainstay.tracer.value(state, 'default', value, defaulted);\n        value = defaulted;\n    }\n\n    // Cast\n\n    if (schema._flags.cast &&\n        value !== undefined) {\n\n        const caster = schema._definition.cast[schema._flags.cast];\n        if (caster.from(value)) {\n            const casted = caster.to(value, helpers);\n            state.mainstay.tracer.value(state, 'cast', value, casted, schema._flags.cast);\n            value = casted;\n        }\n    }\n\n    // Externals\n\n    if (schema.$_terms.externals &&\n        prefs.externals &&\n        prefs._externals !== false) {                       // Disabled for matching\n\n        for (const { method } of schema.$_terms.externals) {\n            state.mainstay.externals.push({ method, path: state.path, label: Errors.label(schema._flags, state, prefs) });\n        }\n    }\n\n    // Result\n\n    const result = { value, errors: errors.length ? errors : null };\n\n    if (schema._flags.result) {\n        result.value = schema._flags.result === 'strip' ? undefined : /* raw */ helpers.original;\n        state.mainstay.tracer.value(state, schema._flags.result, value, result.value);\n        state.shadow(value, schema._flags.result);\n    }\n\n    // Cache\n\n    if (schema._cache &&\n        prefs.cache !== false &&\n        !schema._refs.length) {\n\n        schema._cache.set(helpers.original, result);\n    }\n\n    // Artifacts\n\n    if (value !== undefined &&\n        !result.errors &&\n        schema._flags.artifact !== undefined) {\n\n        state.mainstay.artifacts = state.mainstay.artifacts || new Map();\n        if (!state.mainstay.artifacts.has(schema._flags.artifact)) {\n            state.mainstay.artifacts.set(schema._flags.artifact, []);\n        }\n\n        state.mainstay.artifacts.get(schema._flags.artifact).push(state.path);\n    }\n\n    return result;\n};\n\n\ninternals.prefs = function (schema, prefs) {\n\n    const isDefaultOptions = prefs === Common.defaults;\n    if (isDefaultOptions &&\n        schema._preferences[Common.symbols.prefs]) {\n\n        return schema._preferences[Common.symbols.prefs];\n    }\n\n    prefs = Common.preferences(prefs, schema._preferences);\n    if (isDefaultOptions) {\n        schema._preferences[Common.symbols.prefs] = prefs;\n    }\n\n    return prefs;\n};\n\n\ninternals.default = function (flag, value, errors, helpers) {\n\n    const { schema, state, prefs } = helpers;\n    const source = schema._flags[flag];\n    if (prefs.noDefaults ||\n        source === undefined) {\n\n        return value;\n    }\n\n    state.mainstay.tracer.log(schema, state, 'rule', flag, 'full');\n\n    if (!source) {\n        return source;\n    }\n\n    if (typeof source === 'function') {\n        const args = source.length ? [Clone(state.ancestors[0]), helpers] : [];\n\n        try {\n            return source(...args);\n        }\n        catch (err) {\n            errors.push(schema.$_createError(`any.${flag}`, null, { error: err }, state, prefs));\n            return;\n        }\n    }\n\n    if (typeof source !== 'object') {\n        return source;\n    }\n\n    if (source[Common.symbols.literal]) {\n        return source.literal;\n    }\n\n    if (Common.isResolvable(source)) {\n        return source.resolve(value, state, prefs);\n    }\n\n    return Clone(source);\n};\n\n\ninternals.trim = function (value, schema) {\n\n    if (typeof value !== 'string') {\n        return value;\n    }\n\n    const trim = schema.$_getRule('trim');\n    if (!trim ||\n        !trim.args.enabled) {\n\n        return value;\n    }\n\n    return value.trim();\n};\n\n\ninternals.ignore = {\n    active: false,\n    debug: Ignore,\n    entry: Ignore,\n    filter: Ignore,\n    log: Ignore,\n    resolve: Ignore,\n    value: Ignore\n};\n\n\ninternals.errorsArray = function () {\n\n    const errors = [];\n    errors[Common.symbols.errors] = true;\n    return errors;\n};\n"]},"metadata":{},"sourceType":"script"}