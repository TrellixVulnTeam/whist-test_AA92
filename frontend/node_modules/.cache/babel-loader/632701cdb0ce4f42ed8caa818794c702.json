{"ast":null,"code":"'use strict';\n\nconst Assert = require('@hapi/hoek/lib/assert');\n\nconst internals = {};\nexports.Sorter = class {\n  constructor() {\n    this._items = [];\n    this.nodes = [];\n  }\n\n  add(nodes, options) {\n    options = options || {}; // Validate rules\n\n    const before = [].concat(options.before || []);\n    const after = [].concat(options.after || []);\n    const group = options.group || '?';\n    const sort = options.sort || 0; // Used for merging only\n\n    Assert(!before.includes(group), `Item cannot come before itself: ${group}`);\n    Assert(!before.includes('?'), 'Item cannot come before unassociated items');\n    Assert(!after.includes(group), `Item cannot come after itself: ${group}`);\n    Assert(!after.includes('?'), 'Item cannot come after unassociated items');\n\n    if (!Array.isArray(nodes)) {\n      nodes = [nodes];\n    }\n\n    for (const node of nodes) {\n      const item = {\n        seq: this._items.length,\n        sort,\n        before,\n        after,\n        group,\n        node\n      };\n\n      this._items.push(item);\n    } // Insert event\n\n\n    if (!options.manual) {\n      const valid = this._sort();\n\n      Assert(valid, 'item', group !== '?' ? `added into group ${group}` : '', 'created a dependencies error');\n    }\n\n    return this.nodes;\n  }\n\n  merge(others) {\n    if (!Array.isArray(others)) {\n      others = [others];\n    }\n\n    for (const other of others) {\n      if (other) {\n        for (const item of other._items) {\n          this._items.push(Object.assign({}, item)); // Shallow cloned\n\n        }\n      }\n    } // Sort items\n\n\n    this._items.sort(internals.mergeSort);\n\n    for (let i = 0; i < this._items.length; ++i) {\n      this._items[i].seq = i;\n    }\n\n    const valid = this._sort();\n\n    Assert(valid, 'merge created a dependencies error');\n    return this.nodes;\n  }\n\n  sort() {\n    const valid = this._sort();\n\n    Assert(valid, 'sort created a dependencies error');\n    return this.nodes;\n  }\n\n  _sort() {\n    // Construct graph\n    const graph = {};\n    const graphAfters = Object.create(null); // A prototype can bungle lookups w/ false positives\n\n    const groups = Object.create(null);\n\n    for (const item of this._items) {\n      const seq = item.seq; // Unique across all items\n\n      const group = item.group; // Determine Groups\n\n      groups[group] = groups[group] || [];\n      groups[group].push(seq); // Build intermediary graph using 'before'\n\n      graph[seq] = item.before; // Build second intermediary graph with 'after'\n\n      for (const after of item.after) {\n        graphAfters[after] = graphAfters[after] || [];\n        graphAfters[after].push(seq);\n      }\n    } // Expand intermediary graph\n\n\n    for (const node in graph) {\n      const expandedGroups = [];\n\n      for (const graphNodeItem in graph[node]) {\n        const group = graph[node][graphNodeItem];\n        groups[group] = groups[group] || [];\n        expandedGroups.push(...groups[group]);\n      }\n\n      graph[node] = expandedGroups;\n    } // Merge intermediary graph using graphAfters into final graph\n\n\n    for (const group in graphAfters) {\n      if (groups[group]) {\n        for (const node of groups[group]) {\n          graph[node].push(...graphAfters[group]);\n        }\n      }\n    } // Compile ancestors\n\n\n    const ancestors = {};\n\n    for (const node in graph) {\n      const children = graph[node];\n\n      for (const child of children) {\n        ancestors[child] = ancestors[child] || [];\n        ancestors[child].push(node);\n      }\n    } // Topo sort\n\n\n    const visited = {};\n    const sorted = [];\n\n    for (let i = 0; i < this._items.length; ++i) {\n      // Looping through item.seq values out of order\n      let next = i;\n\n      if (ancestors[i]) {\n        next = null;\n\n        for (let j = 0; j < this._items.length; ++j) {\n          // As above, these are item.seq values\n          if (visited[j] === true) {\n            continue;\n          }\n\n          if (!ancestors[j]) {\n            ancestors[j] = [];\n          }\n\n          const shouldSeeCount = ancestors[j].length;\n          let seenCount = 0;\n\n          for (let k = 0; k < shouldSeeCount; ++k) {\n            if (visited[ancestors[j][k]]) {\n              ++seenCount;\n            }\n          }\n\n          if (seenCount === shouldSeeCount) {\n            next = j;\n            break;\n          }\n        }\n      }\n\n      if (next !== null) {\n        visited[next] = true;\n        sorted.push(next);\n      }\n    }\n\n    if (sorted.length !== this._items.length) {\n      return false;\n    }\n\n    const seqIndex = {};\n\n    for (const item of this._items) {\n      seqIndex[item.seq] = item;\n    }\n\n    this._items = [];\n    this.nodes = [];\n\n    for (const value of sorted) {\n      const sortedItem = seqIndex[value];\n      this.nodes.push(sortedItem.node);\n\n      this._items.push(sortedItem);\n    }\n\n    return true;\n  }\n\n};\n\ninternals.mergeSort = (a, b) => {\n  return a.sort === b.sort ? 0 : a.sort < b.sort ? -1 : 1;\n};","map":{"version":3,"sources":["C:/scripting/jobs assignments/whist/backend/node_modules/@hapi/topo/lib/index.js"],"names":["Assert","require","internals","exports","Sorter","constructor","_items","nodes","add","options","before","concat","after","group","sort","includes","Array","isArray","node","item","seq","length","push","manual","valid","_sort","merge","others","other","Object","assign","mergeSort","i","graph","graphAfters","create","groups","expandedGroups","graphNodeItem","ancestors","children","child","visited","sorted","next","j","shouldSeeCount","seenCount","k","seqIndex","value","sortedItem","a","b"],"mappings":"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","sourcesContent":["'use strict';\n\nconst Assert = require('@hapi/hoek/lib/assert');\n\n\nconst internals = {};\n\n\nexports.Sorter = class {\n\n    constructor() {\n\n        this._items = [];\n        this.nodes = [];\n    }\n\n    add(nodes, options) {\n\n        options = options || {};\n\n        // Validate rules\n\n        const before = [].concat(options.before || []);\n        const after = [].concat(options.after || []);\n        const group = options.group || '?';\n        const sort = options.sort || 0;                   // Used for merging only\n\n        Assert(!before.includes(group), `Item cannot come before itself: ${group}`);\n        Assert(!before.includes('?'), 'Item cannot come before unassociated items');\n        Assert(!after.includes(group), `Item cannot come after itself: ${group}`);\n        Assert(!after.includes('?'), 'Item cannot come after unassociated items');\n\n        if (!Array.isArray(nodes)) {\n            nodes = [nodes];\n        }\n\n        for (const node of nodes) {\n            const item = {\n                seq: this._items.length,\n                sort,\n                before,\n                after,\n                group,\n                node\n            };\n\n            this._items.push(item);\n        }\n\n        // Insert event\n\n        if (!options.manual) {\n            const valid = this._sort();\n            Assert(valid, 'item', group !== '?' ? `added into group ${group}` : '', 'created a dependencies error');\n        }\n\n        return this.nodes;\n    }\n\n    merge(others) {\n\n        if (!Array.isArray(others)) {\n            others = [others];\n        }\n\n        for (const other of others) {\n            if (other) {\n                for (const item of other._items) {\n                    this._items.push(Object.assign({}, item));      // Shallow cloned\n                }\n            }\n        }\n\n        // Sort items\n\n        this._items.sort(internals.mergeSort);\n        for (let i = 0; i < this._items.length; ++i) {\n            this._items[i].seq = i;\n        }\n\n        const valid = this._sort();\n        Assert(valid, 'merge created a dependencies error');\n\n        return this.nodes;\n    }\n\n    sort() {\n\n        const valid = this._sort();\n        Assert(valid, 'sort created a dependencies error');\n\n        return this.nodes;\n    }\n\n    _sort() {\n\n        // Construct graph\n\n        const graph = {};\n        const graphAfters = Object.create(null);            // A prototype can bungle lookups w/ false positives\n        const groups = Object.create(null);\n\n        for (const item of this._items) {\n            const seq = item.seq;                           // Unique across all items\n            const group = item.group;\n\n            // Determine Groups\n\n            groups[group] = groups[group] || [];\n            groups[group].push(seq);\n\n            // Build intermediary graph using 'before'\n\n            graph[seq] = item.before;\n\n            // Build second intermediary graph with 'after'\n\n            for (const after of item.after) {\n                graphAfters[after] = graphAfters[after] || [];\n                graphAfters[after].push(seq);\n            }\n        }\n\n        // Expand intermediary graph\n\n        for (const node in graph) {\n            const expandedGroups = [];\n\n            for (const graphNodeItem in graph[node]) {\n                const group = graph[node][graphNodeItem];\n                groups[group] = groups[group] || [];\n                expandedGroups.push(...groups[group]);\n            }\n\n            graph[node] = expandedGroups;\n        }\n\n        // Merge intermediary graph using graphAfters into final graph\n\n        for (const group in graphAfters) {\n            if (groups[group]) {\n                for (const node of groups[group]) {\n                    graph[node].push(...graphAfters[group]);\n                }\n            }\n        }\n\n        // Compile ancestors\n\n        const ancestors = {};\n        for (const node in graph) {\n            const children = graph[node];\n            for (const child of children) {\n                ancestors[child] = ancestors[child] || [];\n                ancestors[child].push(node);\n            }\n        }\n\n        // Topo sort\n\n        const visited = {};\n        const sorted = [];\n\n        for (let i = 0; i < this._items.length; ++i) {          // Looping through item.seq values out of order\n            let next = i;\n\n            if (ancestors[i]) {\n                next = null;\n                for (let j = 0; j < this._items.length; ++j) {  // As above, these are item.seq values\n                    if (visited[j] === true) {\n                        continue;\n                    }\n\n                    if (!ancestors[j]) {\n                        ancestors[j] = [];\n                    }\n\n                    const shouldSeeCount = ancestors[j].length;\n                    let seenCount = 0;\n                    for (let k = 0; k < shouldSeeCount; ++k) {\n                        if (visited[ancestors[j][k]]) {\n                            ++seenCount;\n                        }\n                    }\n\n                    if (seenCount === shouldSeeCount) {\n                        next = j;\n                        break;\n                    }\n                }\n            }\n\n            if (next !== null) {\n                visited[next] = true;\n                sorted.push(next);\n            }\n        }\n\n        if (sorted.length !== this._items.length) {\n            return false;\n        }\n\n        const seqIndex = {};\n        for (const item of this._items) {\n            seqIndex[item.seq] = item;\n        }\n\n        this._items = [];\n        this.nodes = [];\n\n        for (const value of sorted) {\n            const sortedItem = seqIndex[value];\n            this.nodes.push(sortedItem.node);\n            this._items.push(sortedItem);\n        }\n\n        return true;\n    }\n};\n\n\ninternals.mergeSort = (a, b) => {\n\n    return a.sort === b.sort ? 0 : (a.sort < b.sort ? -1 : 1);\n};\n"]},"metadata":{},"sourceType":"script"}