{"ast":null,"code":"'use strict';\n\nconst Assert = require('@hapi/hoek/lib/assert');\n\nconst Domain = require('@sideway/address/lib/domain');\n\nconst Email = require('@sideway/address/lib/email');\n\nconst Ip = require('@sideway/address/lib/ip');\n\nconst EscapeRegex = require('@hapi/hoek/lib/escapeRegex');\n\nconst Tlds = require('@sideway/address/lib/tlds');\n\nconst Uri = require('@sideway/address/lib/uri');\n\nconst Any = require('./any');\n\nconst Common = require('../common');\n\nconst internals = {\n  tlds: Tlds instanceof Set ? {\n    tlds: {\n      allow: Tlds,\n      deny: null\n    }\n  } : false,\n  // $lab:coverage:ignore$\n  base64Regex: {\n    // paddingRequired\n    true: {\n      // urlSafe\n      true: /^(?:[\\w\\-]{2}[\\w\\-]{2})*(?:[\\w\\-]{2}==|[\\w\\-]{3}=)?$/,\n      false: /^(?:[A-Za-z0-9+\\/]{2}[A-Za-z0-9+\\/]{2})*(?:[A-Za-z0-9+\\/]{2}==|[A-Za-z0-9+\\/]{3}=)?$/\n    },\n    false: {\n      true: /^(?:[\\w\\-]{2}[\\w\\-]{2})*(?:[\\w\\-]{2}(==)?|[\\w\\-]{3}=?)?$/,\n      false: /^(?:[A-Za-z0-9+\\/]{2}[A-Za-z0-9+\\/]{2})*(?:[A-Za-z0-9+\\/]{2}(==)?|[A-Za-z0-9+\\/]{3}=?)?$/\n    }\n  },\n  dataUriRegex: /^data:[\\w+.-]+\\/[\\w+.-]+;((charset=[\\w-]+|base64),)?(.*)$/,\n  hexRegex: /^[a-f0-9]+$/i,\n  ipRegex: Ip.regex().regex,\n  isoDurationRegex: /^P(?!$)(\\d+Y)?(\\d+M)?(\\d+W)?(\\d+D)?(T(?=\\d)(\\d+H)?(\\d+M)?(\\d+S)?)?$/,\n  guidBrackets: {\n    '{': '}',\n    '[': ']',\n    '(': ')',\n    '': ''\n  },\n  guidVersions: {\n    uuidv1: '1',\n    uuidv2: '2',\n    uuidv3: '3',\n    uuidv4: '4',\n    uuidv5: '5'\n  },\n  guidSeparators: new Set([undefined, true, false, '-', ':']),\n  normalizationForms: ['NFC', 'NFD', 'NFKC', 'NFKD']\n};\nmodule.exports = Any.extend({\n  type: 'string',\n  flags: {\n    insensitive: {\n      default: false\n    },\n    truncate: {\n      default: false\n    }\n  },\n  terms: {\n    replacements: {\n      init: null\n    }\n  },\n  coerce: {\n    from: 'string',\n\n    method(value, {\n      schema,\n      state,\n      prefs\n    }) {\n      const normalize = schema.$_getRule('normalize');\n\n      if (normalize) {\n        value = value.normalize(normalize.args.form);\n      }\n\n      const casing = schema.$_getRule('case');\n\n      if (casing) {\n        value = casing.args.direction === 'upper' ? value.toLocaleUpperCase() : value.toLocaleLowerCase();\n      }\n\n      const trim = schema.$_getRule('trim');\n\n      if (trim && trim.args.enabled) {\n        value = value.trim();\n      }\n\n      if (schema.$_terms.replacements) {\n        for (const replacement of schema.$_terms.replacements) {\n          value = value.replace(replacement.pattern, replacement.replacement);\n        }\n      }\n\n      const hex = schema.$_getRule('hex');\n\n      if (hex && hex.args.options.byteAligned && value.length % 2 !== 0) {\n        value = `0${value}`;\n      }\n\n      if (schema.$_getRule('isoDate')) {\n        const iso = internals.isoDate(value);\n\n        if (iso) {\n          value = iso;\n        }\n      }\n\n      if (schema._flags.truncate) {\n        const rule = schema.$_getRule('max');\n\n        if (rule) {\n          let limit = rule.args.limit;\n\n          if (Common.isResolvable(limit)) {\n            limit = limit.resolve(value, state, prefs);\n\n            if (!Common.limit(limit)) {\n              return {\n                value,\n                errors: schema.$_createError('any.ref', limit, {\n                  ref: rule.args.limit,\n                  arg: 'limit',\n                  reason: 'must be a positive integer'\n                }, state, prefs)\n              };\n            }\n          }\n\n          value = value.slice(0, limit);\n        }\n      }\n\n      return {\n        value\n      };\n    }\n\n  },\n\n  validate(value, {\n    error\n  }) {\n    if (typeof value !== 'string') {\n      return {\n        value,\n        errors: error('string.base')\n      };\n    }\n\n    if (value === '') {\n      return {\n        value,\n        errors: error('string.empty')\n      };\n    }\n  },\n\n  rules: {\n    alphanum: {\n      method() {\n        return this.$_addRule('alphanum');\n      },\n\n      validate(value, helpers) {\n        if (/^[a-zA-Z0-9]+$/.test(value)) {\n          return value;\n        }\n\n        return helpers.error('string.alphanum');\n      }\n\n    },\n    base64: {\n      method(options = {}) {\n        Common.assertOptions(options, ['paddingRequired', 'urlSafe']);\n        options = {\n          urlSafe: false,\n          paddingRequired: true,\n          ...options\n        };\n        Assert(typeof options.paddingRequired === 'boolean', 'paddingRequired must be boolean');\n        Assert(typeof options.urlSafe === 'boolean', 'urlSafe must be boolean');\n        return this.$_addRule({\n          name: 'base64',\n          args: {\n            options\n          }\n        });\n      },\n\n      validate(value, helpers, {\n        options\n      }) {\n        const regex = internals.base64Regex[options.paddingRequired][options.urlSafe];\n\n        if (regex.test(value)) {\n          return value;\n        }\n\n        return helpers.error('string.base64');\n      }\n\n    },\n    case: {\n      method(direction) {\n        Assert(['lower', 'upper'].includes(direction), 'Invalid case:', direction);\n        return this.$_addRule({\n          name: 'case',\n          args: {\n            direction\n          }\n        });\n      },\n\n      validate(value, helpers, {\n        direction\n      }) {\n        if (direction === 'lower' && value === value.toLocaleLowerCase() || direction === 'upper' && value === value.toLocaleUpperCase()) {\n          return value;\n        }\n\n        return helpers.error(`string.${direction}case`);\n      },\n\n      convert: true\n    },\n    creditCard: {\n      method() {\n        return this.$_addRule('creditCard');\n      },\n\n      validate(value, helpers) {\n        let i = value.length;\n        let sum = 0;\n        let mul = 1;\n\n        while (i--) {\n          const char = value.charAt(i) * mul;\n          sum = sum + (char - (char > 9) * 9);\n          mul = mul ^ 3;\n        }\n\n        if (sum > 0 && sum % 10 === 0) {\n          return value;\n        }\n\n        return helpers.error('string.creditCard');\n      }\n\n    },\n    dataUri: {\n      method(options = {}) {\n        Common.assertOptions(options, ['paddingRequired']);\n        options = {\n          paddingRequired: true,\n          ...options\n        };\n        Assert(typeof options.paddingRequired === 'boolean', 'paddingRequired must be boolean');\n        return this.$_addRule({\n          name: 'dataUri',\n          args: {\n            options\n          }\n        });\n      },\n\n      validate(value, helpers, {\n        options\n      }) {\n        const matches = value.match(internals.dataUriRegex);\n\n        if (matches) {\n          if (!matches[2]) {\n            return value;\n          }\n\n          if (matches[2] !== 'base64') {\n            return value;\n          }\n\n          const base64regex = internals.base64Regex[options.paddingRequired].false;\n\n          if (base64regex.test(matches[3])) {\n            return value;\n          }\n        }\n\n        return helpers.error('string.dataUri');\n      }\n\n    },\n    domain: {\n      method(options) {\n        if (options) {\n          Common.assertOptions(options, ['allowUnicode', 'maxDomainSegments', 'minDomainSegments', 'tlds']);\n        }\n\n        const address = internals.addressOptions(options);\n        return this.$_addRule({\n          name: 'domain',\n          args: {\n            options\n          },\n          address\n        });\n      },\n\n      validate(value, helpers, args, {\n        address\n      }) {\n        if (Domain.isValid(value, address)) {\n          return value;\n        }\n\n        return helpers.error('string.domain');\n      }\n\n    },\n    email: {\n      method(options = {}) {\n        Common.assertOptions(options, ['allowUnicode', 'ignoreLength', 'maxDomainSegments', 'minDomainSegments', 'multiple', 'separator', 'tlds']);\n        Assert(options.multiple === undefined || typeof options.multiple === 'boolean', 'multiple option must be an boolean');\n        const address = internals.addressOptions(options);\n        const regex = new RegExp(`\\\\s*[${options.separator ? EscapeRegex(options.separator) : ','}]\\\\s*`);\n        return this.$_addRule({\n          name: 'email',\n          args: {\n            options\n          },\n          regex,\n          address\n        });\n      },\n\n      validate(value, helpers, {\n        options\n      }, {\n        regex,\n        address\n      }) {\n        const emails = options.multiple ? value.split(regex) : [value];\n        const invalids = [];\n\n        for (const email of emails) {\n          if (!Email.isValid(email, address)) {\n            invalids.push(email);\n          }\n        }\n\n        if (!invalids.length) {\n          return value;\n        }\n\n        return helpers.error('string.email', {\n          value,\n          invalids\n        });\n      }\n\n    },\n    guid: {\n      alias: 'uuid',\n\n      method(options = {}) {\n        Common.assertOptions(options, ['version', 'separator']);\n        let versionNumbers = '';\n\n        if (options.version) {\n          const versions = [].concat(options.version);\n          Assert(versions.length >= 1, 'version must have at least 1 valid version specified');\n          const set = new Set();\n\n          for (let i = 0; i < versions.length; ++i) {\n            const version = versions[i];\n            Assert(typeof version === 'string', 'version at position ' + i + ' must be a string');\n            const versionNumber = internals.guidVersions[version.toLowerCase()];\n            Assert(versionNumber, 'version at position ' + i + ' must be one of ' + Object.keys(internals.guidVersions).join(', '));\n            Assert(!set.has(versionNumber), 'version at position ' + i + ' must not be a duplicate');\n            versionNumbers += versionNumber;\n            set.add(versionNumber);\n          }\n        }\n\n        Assert(internals.guidSeparators.has(options.separator), 'separator must be one of true, false, \"-\", or \":\"');\n        const separator = options.separator === undefined ? '[:-]?' : options.separator === true ? '[:-]' : options.separator === false ? '[]?' : `\\\\${options.separator}`;\n        const regex = new RegExp(`^([\\\\[{\\\\(]?)[0-9A-F]{8}(${separator})[0-9A-F]{4}\\\\2?[${versionNumbers || '0-9A-F'}][0-9A-F]{3}\\\\2?[${versionNumbers ? '89AB' : '0-9A-F'}][0-9A-F]{3}\\\\2?[0-9A-F]{12}([\\\\]}\\\\)]?)$`, 'i');\n        return this.$_addRule({\n          name: 'guid',\n          args: {\n            options\n          },\n          regex\n        });\n      },\n\n      validate(value, helpers, args, {\n        regex\n      }) {\n        const results = regex.exec(value);\n\n        if (!results) {\n          return helpers.error('string.guid');\n        } // Matching braces\n\n\n        if (internals.guidBrackets[results[1]] !== results[results.length - 1]) {\n          return helpers.error('string.guid');\n        }\n\n        return value;\n      }\n\n    },\n    hex: {\n      method(options = {}) {\n        Common.assertOptions(options, ['byteAligned']);\n        options = {\n          byteAligned: false,\n          ...options\n        };\n        Assert(typeof options.byteAligned === 'boolean', 'byteAligned must be boolean');\n        return this.$_addRule({\n          name: 'hex',\n          args: {\n            options\n          }\n        });\n      },\n\n      validate(value, helpers, {\n        options\n      }) {\n        if (!internals.hexRegex.test(value)) {\n          return helpers.error('string.hex');\n        }\n\n        if (options.byteAligned && value.length % 2 !== 0) {\n          return helpers.error('string.hexAlign');\n        }\n\n        return value;\n      }\n\n    },\n    hostname: {\n      method() {\n        return this.$_addRule('hostname');\n      },\n\n      validate(value, helpers) {\n        if (Domain.isValid(value, {\n          minDomainSegments: 1\n        }) || internals.ipRegex.test(value)) {\n          return value;\n        }\n\n        return helpers.error('string.hostname');\n      }\n\n    },\n    insensitive: {\n      method() {\n        return this.$_setFlag('insensitive', true);\n      }\n\n    },\n    ip: {\n      method(options = {}) {\n        Common.assertOptions(options, ['cidr', 'version']);\n        const {\n          cidr,\n          versions,\n          regex\n        } = Ip.regex(options);\n        const version = options.version ? versions : undefined;\n        return this.$_addRule({\n          name: 'ip',\n          args: {\n            options: {\n              cidr,\n              version\n            }\n          },\n          regex\n        });\n      },\n\n      validate(value, helpers, {\n        options\n      }, {\n        regex\n      }) {\n        if (regex.test(value)) {\n          return value;\n        }\n\n        if (options.version) {\n          return helpers.error('string.ipVersion', {\n            value,\n            cidr: options.cidr,\n            version: options.version\n          });\n        }\n\n        return helpers.error('string.ip', {\n          value,\n          cidr: options.cidr\n        });\n      }\n\n    },\n    isoDate: {\n      method() {\n        return this.$_addRule('isoDate');\n      },\n\n      validate(value, {\n        error\n      }) {\n        if (internals.isoDate(value)) {\n          return value;\n        }\n\n        return error('string.isoDate');\n      }\n\n    },\n    isoDuration: {\n      method() {\n        return this.$_addRule('isoDuration');\n      },\n\n      validate(value, helpers) {\n        if (internals.isoDurationRegex.test(value)) {\n          return value;\n        }\n\n        return helpers.error('string.isoDuration');\n      }\n\n    },\n    length: {\n      method(limit, encoding) {\n        return internals.length(this, 'length', limit, '=', encoding);\n      },\n\n      validate(value, helpers, {\n        limit,\n        encoding\n      }, {\n        name,\n        operator,\n        args\n      }) {\n        const length = encoding ? Buffer && Buffer.byteLength(value, encoding) : value.length; // $lab:coverage:ignore$\n\n        if (Common.compare(length, limit, operator)) {\n          return value;\n        }\n\n        return helpers.error('string.' + name, {\n          limit: args.limit,\n          value,\n          encoding\n        });\n      },\n\n      args: [{\n        name: 'limit',\n        ref: true,\n        assert: Common.limit,\n        message: 'must be a positive integer'\n      }, 'encoding']\n    },\n    lowercase: {\n      method() {\n        return this.case('lower');\n      }\n\n    },\n    max: {\n      method(limit, encoding) {\n        return internals.length(this, 'max', limit, '<=', encoding);\n      },\n\n      args: ['limit', 'encoding']\n    },\n    min: {\n      method(limit, encoding) {\n        return internals.length(this, 'min', limit, '>=', encoding);\n      },\n\n      args: ['limit', 'encoding']\n    },\n    normalize: {\n      method(form = 'NFC') {\n        Assert(internals.normalizationForms.includes(form), 'normalization form must be one of ' + internals.normalizationForms.join(', '));\n        return this.$_addRule({\n          name: 'normalize',\n          args: {\n            form\n          }\n        });\n      },\n\n      validate(value, {\n        error\n      }, {\n        form\n      }) {\n        if (value === value.normalize(form)) {\n          return value;\n        }\n\n        return error('string.normalize', {\n          value,\n          form\n        });\n      },\n\n      convert: true\n    },\n    pattern: {\n      alias: 'regex',\n\n      method(regex, options = {}) {\n        Assert(regex instanceof RegExp, 'regex must be a RegExp');\n        Assert(!regex.flags.includes('g') && !regex.flags.includes('y'), 'regex should not use global or sticky mode');\n\n        if (typeof options === 'string') {\n          options = {\n            name: options\n          };\n        }\n\n        Common.assertOptions(options, ['invert', 'name']);\n        const errorCode = ['string.pattern', options.invert ? '.invert' : '', options.name ? '.name' : '.base'].join('');\n        return this.$_addRule({\n          name: 'pattern',\n          args: {\n            regex,\n            options\n          },\n          errorCode\n        });\n      },\n\n      validate(value, helpers, {\n        regex,\n        options\n      }, {\n        errorCode\n      }) {\n        const patternMatch = regex.test(value);\n\n        if (patternMatch ^ options.invert) {\n          return value;\n        }\n\n        return helpers.error(errorCode, {\n          name: options.name,\n          regex,\n          value\n        });\n      },\n\n      args: ['regex', 'options'],\n      multi: true\n    },\n    replace: {\n      method(pattern, replacement) {\n        if (typeof pattern === 'string') {\n          pattern = new RegExp(EscapeRegex(pattern), 'g');\n        }\n\n        Assert(pattern instanceof RegExp, 'pattern must be a RegExp');\n        Assert(typeof replacement === 'string', 'replacement must be a String');\n        const obj = this.clone();\n\n        if (!obj.$_terms.replacements) {\n          obj.$_terms.replacements = [];\n        }\n\n        obj.$_terms.replacements.push({\n          pattern,\n          replacement\n        });\n        return obj;\n      }\n\n    },\n    token: {\n      method() {\n        return this.$_addRule('token');\n      },\n\n      validate(value, helpers) {\n        if (/^\\w+$/.test(value)) {\n          return value;\n        }\n\n        return helpers.error('string.token');\n      }\n\n    },\n    trim: {\n      method(enabled = true) {\n        Assert(typeof enabled === 'boolean', 'enabled must be a boolean');\n        return this.$_addRule({\n          name: 'trim',\n          args: {\n            enabled\n          }\n        });\n      },\n\n      validate(value, helpers, {\n        enabled\n      }) {\n        if (!enabled || value === value.trim()) {\n          return value;\n        }\n\n        return helpers.error('string.trim');\n      },\n\n      convert: true\n    },\n    truncate: {\n      method(enabled = true) {\n        Assert(typeof enabled === 'boolean', 'enabled must be a boolean');\n        return this.$_setFlag('truncate', enabled);\n      }\n\n    },\n    uppercase: {\n      method() {\n        return this.case('upper');\n      }\n\n    },\n    uri: {\n      method(options = {}) {\n        Common.assertOptions(options, ['allowRelative', 'allowQuerySquareBrackets', 'domain', 'relativeOnly', 'scheme']);\n\n        if (options.domain) {\n          Common.assertOptions(options.domain, ['allowUnicode', 'maxDomainSegments', 'minDomainSegments', 'tlds']);\n        }\n\n        const {\n          regex,\n          scheme\n        } = Uri.regex(options);\n        const domain = options.domain ? internals.addressOptions(options.domain) : null;\n        return this.$_addRule({\n          name: 'uri',\n          args: {\n            options\n          },\n          regex,\n          domain,\n          scheme\n        });\n      },\n\n      validate(value, helpers, {\n        options\n      }, {\n        regex,\n        domain,\n        scheme\n      }) {\n        if (['http:/', 'https:/'].includes(value)) {\n          // scheme:/ is technically valid but makes no sense\n          return helpers.error('string.uri');\n        }\n\n        const match = regex.exec(value);\n\n        if (match) {\n          const matched = match[1] || match[2];\n\n          if (domain && (!options.allowRelative || matched) && !Domain.isValid(matched, domain)) {\n            return helpers.error('string.domain', {\n              value: matched\n            });\n          }\n\n          return value;\n        }\n\n        if (options.relativeOnly) {\n          return helpers.error('string.uriRelativeOnly');\n        }\n\n        if (options.scheme) {\n          return helpers.error('string.uriCustomScheme', {\n            scheme,\n            value\n          });\n        }\n\n        return helpers.error('string.uri');\n      }\n\n    }\n  },\n  manifest: {\n    build(obj, desc) {\n      if (desc.replacements) {\n        for (const {\n          pattern,\n          replacement\n        } of desc.replacements) {\n          obj = obj.replace(pattern, replacement);\n        }\n      }\n\n      return obj;\n    }\n\n  },\n  messages: {\n    'string.alphanum': '{{#label}} must only contain alpha-numeric characters',\n    'string.base': '{{#label}} must be a string',\n    'string.base64': '{{#label}} must be a valid base64 string',\n    'string.creditCard': '{{#label}} must be a credit card',\n    'string.dataUri': '{{#label}} must be a valid dataUri string',\n    'string.domain': '{{#label}} must contain a valid domain name',\n    'string.email': '{{#label}} must be a valid email',\n    'string.empty': '{{#label}} is not allowed to be empty',\n    'string.guid': '{{#label}} must be a valid GUID',\n    'string.hex': '{{#label}} must only contain hexadecimal characters',\n    'string.hexAlign': '{{#label}} hex decoded representation must be byte aligned',\n    'string.hostname': '{{#label}} must be a valid hostname',\n    'string.ip': '{{#label}} must be a valid ip address with a {{#cidr}} CIDR',\n    'string.ipVersion': '{{#label}} must be a valid ip address of one of the following versions {{#version}} with a {{#cidr}} CIDR',\n    'string.isoDate': '{{#label}} must be in iso format',\n    'string.isoDuration': '{{#label}} must be a valid ISO 8601 duration',\n    'string.length': '{{#label}} length must be {{#limit}} characters long',\n    'string.lowercase': '{{#label}} must only contain lowercase characters',\n    'string.max': '{{#label}} length must be less than or equal to {{#limit}} characters long',\n    'string.min': '{{#label}} length must be at least {{#limit}} characters long',\n    'string.normalize': '{{#label}} must be unicode normalized in the {{#form}} form',\n    'string.token': '{{#label}} must only contain alpha-numeric and underscore characters',\n    'string.pattern.base': '{{#label}} with value {:[.]} fails to match the required pattern: {{#regex}}',\n    'string.pattern.name': '{{#label}} with value {:[.]} fails to match the {{#name}} pattern',\n    'string.pattern.invert.base': '{{#label}} with value {:[.]} matches the inverted pattern: {{#regex}}',\n    'string.pattern.invert.name': '{{#label}} with value {:[.]} matches the inverted {{#name}} pattern',\n    'string.trim': '{{#label}} must not have leading or trailing whitespace',\n    'string.uri': '{{#label}} must be a valid uri',\n    'string.uriCustomScheme': '{{#label}} must be a valid uri with a scheme matching the {{#scheme}} pattern',\n    'string.uriRelativeOnly': '{{#label}} must be a valid relative uri',\n    'string.uppercase': '{{#label}} must only contain uppercase characters'\n  }\n}); // Helpers\n\ninternals.addressOptions = function (options) {\n  if (!options) {\n    return options;\n  } // minDomainSegments\n\n\n  Assert(options.minDomainSegments === undefined || Number.isSafeInteger(options.minDomainSegments) && options.minDomainSegments > 0, 'minDomainSegments must be a positive integer'); // maxDomainSegments\n\n  Assert(options.maxDomainSegments === undefined || Number.isSafeInteger(options.maxDomainSegments) && options.maxDomainSegments > 0, 'maxDomainSegments must be a positive integer'); // tlds\n\n  if (options.tlds === false) {\n    return options;\n  }\n\n  if (options.tlds === true || options.tlds === undefined) {\n    Assert(internals.tlds, 'Built-in TLD list disabled');\n    return Object.assign({}, options, internals.tlds);\n  }\n\n  Assert(typeof options.tlds === 'object', 'tlds must be true, false, or an object');\n  const deny = options.tlds.deny;\n\n  if (deny) {\n    if (Array.isArray(deny)) {\n      options = Object.assign({}, options, {\n        tlds: {\n          deny: new Set(deny)\n        }\n      });\n    }\n\n    Assert(options.tlds.deny instanceof Set, 'tlds.deny must be an array, Set, or boolean');\n    Assert(!options.tlds.allow, 'Cannot specify both tlds.allow and tlds.deny lists');\n    internals.validateTlds(options.tlds.deny, 'tlds.deny');\n    return options;\n  }\n\n  const allow = options.tlds.allow;\n\n  if (!allow) {\n    return options;\n  }\n\n  if (allow === true) {\n    Assert(internals.tlds, 'Built-in TLD list disabled');\n    return Object.assign({}, options, internals.tlds);\n  }\n\n  if (Array.isArray(allow)) {\n    options = Object.assign({}, options, {\n      tlds: {\n        allow: new Set(allow)\n      }\n    });\n  }\n\n  Assert(options.tlds.allow instanceof Set, 'tlds.allow must be an array, Set, or boolean');\n  internals.validateTlds(options.tlds.allow, 'tlds.allow');\n  return options;\n};\n\ninternals.validateTlds = function (set, source) {\n  for (const tld of set) {\n    Assert(Domain.isValid(tld, {\n      minDomainSegments: 1,\n      maxDomainSegments: 1\n    }), `${source} must contain valid top level domain names`);\n  }\n};\n\ninternals.isoDate = function (value) {\n  if (!Common.isIsoDate(value)) {\n    return null;\n  }\n\n  if (/.*T.*[+-]\\d\\d$/.test(value)) {\n    // Add missing trailing zeros to timeshift\n    value += '00';\n  }\n\n  const date = new Date(value);\n\n  if (isNaN(date.getTime())) {\n    return null;\n  }\n\n  return date.toISOString();\n};\n\ninternals.length = function (schema, name, limit, operator, encoding) {\n  Assert(!encoding || Buffer && Buffer.isEncoding(encoding), 'Invalid encoding:', encoding); // $lab:coverage:ignore$\n\n  return schema.$_addRule({\n    name,\n    method: 'length',\n    args: {\n      limit,\n      encoding\n    },\n    operator\n  });\n};","map":{"version":3,"sources":["C:/scripting/jobs assignments/whist/backend/node_modules/joi/lib/types/string.js"],"names":["Assert","require","Domain","Email","Ip","EscapeRegex","Tlds","Uri","Any","Common","internals","tlds","Set","allow","deny","base64Regex","true","false","dataUriRegex","hexRegex","ipRegex","regex","isoDurationRegex","guidBrackets","guidVersions","uuidv1","uuidv2","uuidv3","uuidv4","uuidv5","guidSeparators","undefined","normalizationForms","module","exports","extend","type","flags","insensitive","default","truncate","terms","replacements","init","coerce","from","method","value","schema","state","prefs","normalize","$_getRule","args","form","casing","direction","toLocaleUpperCase","toLocaleLowerCase","trim","enabled","$_terms","replacement","replace","pattern","hex","options","byteAligned","length","iso","isoDate","_flags","rule","limit","isResolvable","resolve","errors","$_createError","ref","arg","reason","slice","validate","error","rules","alphanum","$_addRule","helpers","test","base64","assertOptions","urlSafe","paddingRequired","name","case","includes","convert","creditCard","i","sum","mul","char","charAt","dataUri","matches","match","base64regex","domain","address","addressOptions","isValid","email","multiple","RegExp","separator","emails","split","invalids","push","guid","alias","versionNumbers","version","versions","concat","set","versionNumber","toLowerCase","Object","keys","join","has","add","results","exec","hostname","minDomainSegments","$_setFlag","ip","cidr","isoDuration","encoding","operator","Buffer","byteLength","compare","assert","message","lowercase","max","min","errorCode","invert","patternMatch","multi","obj","clone","token","uppercase","uri","scheme","matched","allowRelative","relativeOnly","manifest","build","desc","messages","Number","isSafeInteger","maxDomainSegments","assign","Array","isArray","validateTlds","source","tld","isIsoDate","date","Date","isNaN","getTime","toISOString","isEncoding"],"mappings":"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","sourcesContent":["'use strict';\n\nconst Assert = require('@hapi/hoek/lib/assert');\nconst Domain = require('@sideway/address/lib/domain');\nconst Email = require('@sideway/address/lib/email');\nconst Ip = require('@sideway/address/lib/ip');\nconst EscapeRegex = require('@hapi/hoek/lib/escapeRegex');\nconst Tlds = require('@sideway/address/lib/tlds');\nconst Uri = require('@sideway/address/lib/uri');\n\nconst Any = require('./any');\nconst Common = require('../common');\n\n\nconst internals = {\n    tlds: Tlds instanceof Set ? { tlds: { allow: Tlds, deny: null } } : false,              // $lab:coverage:ignore$\n    base64Regex: {\n        // paddingRequired\n        true: {\n            // urlSafe\n            true: /^(?:[\\w\\-]{2}[\\w\\-]{2})*(?:[\\w\\-]{2}==|[\\w\\-]{3}=)?$/,\n            false: /^(?:[A-Za-z0-9+\\/]{2}[A-Za-z0-9+\\/]{2})*(?:[A-Za-z0-9+\\/]{2}==|[A-Za-z0-9+\\/]{3}=)?$/\n        },\n        false: {\n            true: /^(?:[\\w\\-]{2}[\\w\\-]{2})*(?:[\\w\\-]{2}(==)?|[\\w\\-]{3}=?)?$/,\n            false: /^(?:[A-Za-z0-9+\\/]{2}[A-Za-z0-9+\\/]{2})*(?:[A-Za-z0-9+\\/]{2}(==)?|[A-Za-z0-9+\\/]{3}=?)?$/\n        }\n    },\n    dataUriRegex: /^data:[\\w+.-]+\\/[\\w+.-]+;((charset=[\\w-]+|base64),)?(.*)$/,\n    hexRegex: /^[a-f0-9]+$/i,\n    ipRegex: Ip.regex().regex,\n    isoDurationRegex: /^P(?!$)(\\d+Y)?(\\d+M)?(\\d+W)?(\\d+D)?(T(?=\\d)(\\d+H)?(\\d+M)?(\\d+S)?)?$/,\n\n    guidBrackets: {\n        '{': '}', '[': ']', '(': ')', '': ''\n    },\n    guidVersions: {\n        uuidv1: '1',\n        uuidv2: '2',\n        uuidv3: '3',\n        uuidv4: '4',\n        uuidv5: '5'\n    },\n    guidSeparators: new Set([undefined, true, false, '-', ':']),\n\n    normalizationForms: ['NFC', 'NFD', 'NFKC', 'NFKD']\n};\n\n\nmodule.exports = Any.extend({\n\n    type: 'string',\n\n    flags: {\n\n        insensitive: { default: false },\n        truncate: { default: false }\n    },\n\n    terms: {\n\n        replacements: { init: null }\n    },\n\n    coerce: {\n        from: 'string',\n        method(value, { schema, state, prefs }) {\n\n            const normalize = schema.$_getRule('normalize');\n            if (normalize) {\n                value = value.normalize(normalize.args.form);\n            }\n\n            const casing = schema.$_getRule('case');\n            if (casing) {\n                value = casing.args.direction === 'upper' ? value.toLocaleUpperCase() : value.toLocaleLowerCase();\n            }\n\n            const trim = schema.$_getRule('trim');\n            if (trim &&\n                trim.args.enabled) {\n\n                value = value.trim();\n            }\n\n            if (schema.$_terms.replacements) {\n                for (const replacement of schema.$_terms.replacements) {\n                    value = value.replace(replacement.pattern, replacement.replacement);\n                }\n            }\n\n            const hex = schema.$_getRule('hex');\n            if (hex &&\n                hex.args.options.byteAligned &&\n                value.length % 2 !== 0) {\n\n                value = `0${value}`;\n            }\n\n            if (schema.$_getRule('isoDate')) {\n                const iso = internals.isoDate(value);\n                if (iso) {\n                    value = iso;\n                }\n            }\n\n            if (schema._flags.truncate) {\n                const rule = schema.$_getRule('max');\n                if (rule) {\n                    let limit = rule.args.limit;\n                    if (Common.isResolvable(limit)) {\n                        limit = limit.resolve(value, state, prefs);\n                        if (!Common.limit(limit)) {\n                            return { value, errors: schema.$_createError('any.ref', limit, { ref: rule.args.limit, arg: 'limit', reason: 'must be a positive integer' }, state, prefs) };\n                        }\n                    }\n\n                    value = value.slice(0, limit);\n                }\n            }\n\n            return { value };\n        }\n    },\n\n    validate(value, { error }) {\n\n        if (typeof value !== 'string') {\n            return { value, errors: error('string.base') };\n        }\n\n        if (value === '') {\n            return { value, errors: error('string.empty') };\n        }\n    },\n\n    rules: {\n\n        alphanum: {\n            method() {\n\n                return this.$_addRule('alphanum');\n            },\n            validate(value, helpers) {\n\n                if (/^[a-zA-Z0-9]+$/.test(value)) {\n                    return value;\n                }\n\n                return helpers.error('string.alphanum');\n            }\n        },\n\n        base64: {\n            method(options = {}) {\n\n                Common.assertOptions(options, ['paddingRequired', 'urlSafe']);\n\n                options = { urlSafe: false, paddingRequired: true, ...options };\n                Assert(typeof options.paddingRequired === 'boolean', 'paddingRequired must be boolean');\n                Assert(typeof options.urlSafe === 'boolean', 'urlSafe must be boolean');\n\n                return this.$_addRule({ name: 'base64', args: { options } });\n            },\n            validate(value, helpers, { options }) {\n\n                const regex = internals.base64Regex[options.paddingRequired][options.urlSafe];\n                if (regex.test(value)) {\n                    return value;\n                }\n\n                return helpers.error('string.base64');\n            }\n        },\n\n        case: {\n            method(direction) {\n\n                Assert(['lower', 'upper'].includes(direction), 'Invalid case:', direction);\n\n                return this.$_addRule({ name: 'case', args: { direction } });\n            },\n            validate(value, helpers, { direction }) {\n\n                if (direction === 'lower' && value === value.toLocaleLowerCase() ||\n                    direction === 'upper' && value === value.toLocaleUpperCase()) {\n\n                    return value;\n                }\n\n                return helpers.error(`string.${direction}case`);\n            },\n            convert: true\n        },\n\n        creditCard: {\n            method() {\n\n                return this.$_addRule('creditCard');\n            },\n            validate(value, helpers) {\n\n                let i = value.length;\n                let sum = 0;\n                let mul = 1;\n\n                while (i--) {\n                    const char = value.charAt(i) * mul;\n                    sum = sum + (char - (char > 9) * 9);\n                    mul = mul ^ 3;\n                }\n\n                if (sum > 0 &&\n                    sum % 10 === 0) {\n\n                    return value;\n                }\n\n                return helpers.error('string.creditCard');\n            }\n        },\n\n        dataUri: {\n            method(options = {}) {\n\n                Common.assertOptions(options, ['paddingRequired']);\n\n                options = { paddingRequired: true, ...options };\n                Assert(typeof options.paddingRequired === 'boolean', 'paddingRequired must be boolean');\n\n                return this.$_addRule({ name: 'dataUri', args: { options } });\n            },\n            validate(value, helpers, { options }) {\n\n                const matches = value.match(internals.dataUriRegex);\n\n                if (matches) {\n                    if (!matches[2]) {\n                        return value;\n                    }\n\n                    if (matches[2] !== 'base64') {\n                        return value;\n                    }\n\n                    const base64regex = internals.base64Regex[options.paddingRequired].false;\n                    if (base64regex.test(matches[3])) {\n                        return value;\n                    }\n                }\n\n                return helpers.error('string.dataUri');\n            }\n        },\n\n        domain: {\n            method(options) {\n\n                if (options) {\n                    Common.assertOptions(options, ['allowUnicode', 'maxDomainSegments', 'minDomainSegments', 'tlds']);\n                }\n\n                const address = internals.addressOptions(options);\n                return this.$_addRule({ name: 'domain', args: { options }, address });\n            },\n            validate(value, helpers, args, { address }) {\n\n                if (Domain.isValid(value, address)) {\n                    return value;\n                }\n\n                return helpers.error('string.domain');\n            }\n        },\n\n        email: {\n            method(options = {}) {\n\n                Common.assertOptions(options, ['allowUnicode', 'ignoreLength', 'maxDomainSegments', 'minDomainSegments', 'multiple', 'separator', 'tlds']);\n                Assert(options.multiple === undefined || typeof options.multiple === 'boolean', 'multiple option must be an boolean');\n\n                const address = internals.addressOptions(options);\n                const regex = new RegExp(`\\\\s*[${options.separator ? EscapeRegex(options.separator) : ','}]\\\\s*`);\n\n                return this.$_addRule({ name: 'email', args: { options }, regex, address });\n            },\n            validate(value, helpers, { options }, { regex, address }) {\n\n                const emails = options.multiple ? value.split(regex) : [value];\n                const invalids = [];\n                for (const email of emails) {\n                    if (!Email.isValid(email, address)) {\n                        invalids.push(email);\n                    }\n                }\n\n                if (!invalids.length) {\n                    return value;\n                }\n\n                return helpers.error('string.email', { value, invalids });\n            }\n        },\n\n        guid: {\n            alias: 'uuid',\n            method(options = {}) {\n\n                Common.assertOptions(options, ['version', 'separator']);\n\n                let versionNumbers = '';\n\n                if (options.version) {\n                    const versions = [].concat(options.version);\n\n                    Assert(versions.length >= 1, 'version must have at least 1 valid version specified');\n                    const set = new Set();\n\n                    for (let i = 0; i < versions.length; ++i) {\n                        const version = versions[i];\n                        Assert(typeof version === 'string', 'version at position ' + i + ' must be a string');\n                        const versionNumber = internals.guidVersions[version.toLowerCase()];\n                        Assert(versionNumber, 'version at position ' + i + ' must be one of ' + Object.keys(internals.guidVersions).join(', '));\n                        Assert(!set.has(versionNumber), 'version at position ' + i + ' must not be a duplicate');\n\n                        versionNumbers += versionNumber;\n                        set.add(versionNumber);\n                    }\n                }\n\n                Assert(internals.guidSeparators.has(options.separator), 'separator must be one of true, false, \"-\", or \":\"');\n                const separator = options.separator === undefined ? '[:-]?' :\n                    options.separator === true ? '[:-]' :\n                        options.separator === false ? '[]?' : `\\\\${options.separator}`;\n\n                const regex = new RegExp(`^([\\\\[{\\\\(]?)[0-9A-F]{8}(${separator})[0-9A-F]{4}\\\\2?[${versionNumbers || '0-9A-F'}][0-9A-F]{3}\\\\2?[${versionNumbers ? '89AB' : '0-9A-F'}][0-9A-F]{3}\\\\2?[0-9A-F]{12}([\\\\]}\\\\)]?)$`, 'i');\n\n                return this.$_addRule({ name: 'guid', args: { options }, regex });\n            },\n            validate(value, helpers, args, { regex }) {\n\n                const results = regex.exec(value);\n\n                if (!results) {\n                    return helpers.error('string.guid');\n                }\n\n                // Matching braces\n\n                if (internals.guidBrackets[results[1]] !== results[results.length - 1]) {\n                    return helpers.error('string.guid');\n                }\n\n                return value;\n            }\n        },\n\n        hex: {\n            method(options = {}) {\n\n                Common.assertOptions(options, ['byteAligned']);\n\n                options = { byteAligned: false, ...options };\n                Assert(typeof options.byteAligned === 'boolean', 'byteAligned must be boolean');\n\n                return this.$_addRule({ name: 'hex', args: { options } });\n            },\n            validate(value, helpers, { options }) {\n\n                if (!internals.hexRegex.test(value)) {\n                    return helpers.error('string.hex');\n                }\n\n                if (options.byteAligned &&\n                    value.length % 2 !== 0) {\n\n                    return helpers.error('string.hexAlign');\n                }\n\n                return value;\n            }\n        },\n\n        hostname: {\n            method() {\n\n                return this.$_addRule('hostname');\n            },\n            validate(value, helpers) {\n\n                if (Domain.isValid(value, { minDomainSegments: 1 }) ||\n                    internals.ipRegex.test(value)) {\n\n                    return value;\n                }\n\n                return helpers.error('string.hostname');\n            }\n        },\n\n        insensitive: {\n            method() {\n\n                return this.$_setFlag('insensitive', true);\n            }\n        },\n\n        ip: {\n            method(options = {}) {\n\n                Common.assertOptions(options, ['cidr', 'version']);\n\n                const { cidr, versions, regex } = Ip.regex(options);\n                const version = options.version ? versions : undefined;\n                return this.$_addRule({ name: 'ip', args: { options: { cidr, version } }, regex });\n            },\n            validate(value, helpers, { options }, { regex }) {\n\n                if (regex.test(value)) {\n                    return value;\n                }\n\n                if (options.version) {\n                    return helpers.error('string.ipVersion', { value, cidr: options.cidr, version: options.version });\n                }\n\n                return helpers.error('string.ip', { value, cidr: options.cidr });\n            }\n        },\n\n        isoDate: {\n            method() {\n\n                return this.$_addRule('isoDate');\n            },\n            validate(value, { error }) {\n\n                if (internals.isoDate(value)) {\n                    return value;\n                }\n\n                return error('string.isoDate');\n            }\n        },\n\n        isoDuration: {\n            method() {\n\n                return this.$_addRule('isoDuration');\n            },\n            validate(value, helpers) {\n\n                if (internals.isoDurationRegex.test(value)) {\n                    return value;\n                }\n\n                return helpers.error('string.isoDuration');\n            }\n        },\n\n        length: {\n            method(limit, encoding) {\n\n                return internals.length(this, 'length', limit, '=', encoding);\n            },\n            validate(value, helpers, { limit, encoding }, { name, operator, args }) {\n\n                const length = encoding ? Buffer && Buffer.byteLength(value, encoding) : value.length;      // $lab:coverage:ignore$\n                if (Common.compare(length, limit, operator)) {\n                    return value;\n                }\n\n                return helpers.error('string.' + name, { limit: args.limit, value, encoding });\n            },\n            args: [\n                {\n                    name: 'limit',\n                    ref: true,\n                    assert: Common.limit,\n                    message: 'must be a positive integer'\n                },\n                'encoding'\n            ]\n        },\n\n        lowercase: {\n            method() {\n\n                return this.case('lower');\n            }\n        },\n\n        max: {\n            method(limit, encoding) {\n\n                return internals.length(this, 'max', limit, '<=', encoding);\n            },\n            args: ['limit', 'encoding']\n        },\n\n        min: {\n            method(limit, encoding) {\n\n                return internals.length(this, 'min', limit, '>=', encoding);\n            },\n            args: ['limit', 'encoding']\n        },\n\n        normalize: {\n            method(form = 'NFC') {\n\n                Assert(internals.normalizationForms.includes(form), 'normalization form must be one of ' + internals.normalizationForms.join(', '));\n\n                return this.$_addRule({ name: 'normalize', args: { form } });\n            },\n            validate(value, { error }, { form }) {\n\n                if (value === value.normalize(form)) {\n                    return value;\n                }\n\n                return error('string.normalize', { value, form });\n            },\n            convert: true\n        },\n\n        pattern: {\n            alias: 'regex',\n            method(regex, options = {}) {\n\n                Assert(regex instanceof RegExp, 'regex must be a RegExp');\n                Assert(!regex.flags.includes('g') && !regex.flags.includes('y'), 'regex should not use global or sticky mode');\n\n                if (typeof options === 'string') {\n                    options = { name: options };\n                }\n\n                Common.assertOptions(options, ['invert', 'name']);\n\n                const errorCode = ['string.pattern', options.invert ? '.invert' : '', options.name ? '.name' : '.base'].join('');\n                return this.$_addRule({ name: 'pattern', args: { regex, options }, errorCode });\n            },\n            validate(value, helpers, { regex, options }, { errorCode }) {\n\n                const patternMatch = regex.test(value);\n\n                if (patternMatch ^ options.invert) {\n                    return value;\n                }\n\n                return helpers.error(errorCode, { name: options.name, regex, value });\n            },\n            args: ['regex', 'options'],\n            multi: true\n        },\n\n        replace: {\n            method(pattern, replacement) {\n\n                if (typeof pattern === 'string') {\n                    pattern = new RegExp(EscapeRegex(pattern), 'g');\n                }\n\n                Assert(pattern instanceof RegExp, 'pattern must be a RegExp');\n                Assert(typeof replacement === 'string', 'replacement must be a String');\n\n                const obj = this.clone();\n\n                if (!obj.$_terms.replacements) {\n                    obj.$_terms.replacements = [];\n                }\n\n                obj.$_terms.replacements.push({ pattern, replacement });\n                return obj;\n            }\n        },\n\n        token: {\n            method() {\n\n                return this.$_addRule('token');\n            },\n            validate(value, helpers) {\n\n                if (/^\\w+$/.test(value)) {\n                    return value;\n                }\n\n                return helpers.error('string.token');\n            }\n        },\n\n        trim: {\n            method(enabled = true) {\n\n                Assert(typeof enabled === 'boolean', 'enabled must be a boolean');\n\n                return this.$_addRule({ name: 'trim', args: { enabled } });\n            },\n            validate(value, helpers, { enabled }) {\n\n                if (!enabled ||\n                    value === value.trim()) {\n\n                    return value;\n                }\n\n                return helpers.error('string.trim');\n            },\n            convert: true\n        },\n\n        truncate: {\n            method(enabled = true) {\n\n                Assert(typeof enabled === 'boolean', 'enabled must be a boolean');\n\n                return this.$_setFlag('truncate', enabled);\n            }\n        },\n\n        uppercase: {\n            method() {\n\n                return this.case('upper');\n            }\n        },\n\n        uri: {\n            method(options = {}) {\n\n                Common.assertOptions(options, ['allowRelative', 'allowQuerySquareBrackets', 'domain', 'relativeOnly', 'scheme']);\n\n                if (options.domain) {\n                    Common.assertOptions(options.domain, ['allowUnicode', 'maxDomainSegments', 'minDomainSegments', 'tlds']);\n                }\n\n                const { regex, scheme } = Uri.regex(options);\n                const domain = options.domain ? internals.addressOptions(options.domain) : null;\n                return this.$_addRule({ name: 'uri', args: { options }, regex, domain, scheme });\n            },\n            validate(value, helpers, { options }, { regex, domain, scheme }) {\n\n                if (['http:/', 'https:/'].includes(value)) {            // scheme:/ is technically valid but makes no sense\n                    return helpers.error('string.uri');\n                }\n\n                const match = regex.exec(value);\n                if (match) {\n                    const matched = match[1] || match[2];\n                    if (domain &&\n                        (!options.allowRelative || matched) &&\n                        !Domain.isValid(matched, domain)) {\n\n                        return helpers.error('string.domain', { value: matched });\n                    }\n\n                    return value;\n                }\n\n                if (options.relativeOnly) {\n                    return helpers.error('string.uriRelativeOnly');\n                }\n\n                if (options.scheme) {\n                    return helpers.error('string.uriCustomScheme', { scheme, value });\n                }\n\n                return helpers.error('string.uri');\n            }\n        }\n    },\n\n    manifest: {\n\n        build(obj, desc) {\n\n            if (desc.replacements) {\n                for (const { pattern, replacement } of desc.replacements) {\n                    obj = obj.replace(pattern, replacement);\n                }\n            }\n\n            return obj;\n        }\n    },\n\n    messages: {\n        'string.alphanum': '{{#label}} must only contain alpha-numeric characters',\n        'string.base': '{{#label}} must be a string',\n        'string.base64': '{{#label}} must be a valid base64 string',\n        'string.creditCard': '{{#label}} must be a credit card',\n        'string.dataUri': '{{#label}} must be a valid dataUri string',\n        'string.domain': '{{#label}} must contain a valid domain name',\n        'string.email': '{{#label}} must be a valid email',\n        'string.empty': '{{#label}} is not allowed to be empty',\n        'string.guid': '{{#label}} must be a valid GUID',\n        'string.hex': '{{#label}} must only contain hexadecimal characters',\n        'string.hexAlign': '{{#label}} hex decoded representation must be byte aligned',\n        'string.hostname': '{{#label}} must be a valid hostname',\n        'string.ip': '{{#label}} must be a valid ip address with a {{#cidr}} CIDR',\n        'string.ipVersion': '{{#label}} must be a valid ip address of one of the following versions {{#version}} with a {{#cidr}} CIDR',\n        'string.isoDate': '{{#label}} must be in iso format',\n        'string.isoDuration': '{{#label}} must be a valid ISO 8601 duration',\n        'string.length': '{{#label}} length must be {{#limit}} characters long',\n        'string.lowercase': '{{#label}} must only contain lowercase characters',\n        'string.max': '{{#label}} length must be less than or equal to {{#limit}} characters long',\n        'string.min': '{{#label}} length must be at least {{#limit}} characters long',\n        'string.normalize': '{{#label}} must be unicode normalized in the {{#form}} form',\n        'string.token': '{{#label}} must only contain alpha-numeric and underscore characters',\n        'string.pattern.base': '{{#label}} with value {:[.]} fails to match the required pattern: {{#regex}}',\n        'string.pattern.name': '{{#label}} with value {:[.]} fails to match the {{#name}} pattern',\n        'string.pattern.invert.base': '{{#label}} with value {:[.]} matches the inverted pattern: {{#regex}}',\n        'string.pattern.invert.name': '{{#label}} with value {:[.]} matches the inverted {{#name}} pattern',\n        'string.trim': '{{#label}} must not have leading or trailing whitespace',\n        'string.uri': '{{#label}} must be a valid uri',\n        'string.uriCustomScheme': '{{#label}} must be a valid uri with a scheme matching the {{#scheme}} pattern',\n        'string.uriRelativeOnly': '{{#label}} must be a valid relative uri',\n        'string.uppercase': '{{#label}} must only contain uppercase characters'\n    }\n});\n\n\n// Helpers\n\ninternals.addressOptions = function (options) {\n\n    if (!options) {\n        return options;\n    }\n\n    // minDomainSegments\n\n    Assert(options.minDomainSegments === undefined ||\n        Number.isSafeInteger(options.minDomainSegments) && options.minDomainSegments > 0, 'minDomainSegments must be a positive integer');\n\n    // maxDomainSegments\n\n    Assert(options.maxDomainSegments === undefined ||\n        Number.isSafeInteger(options.maxDomainSegments) && options.maxDomainSegments > 0, 'maxDomainSegments must be a positive integer');\n\n    // tlds\n\n    if (options.tlds === false) {\n        return options;\n    }\n\n    if (options.tlds === true ||\n        options.tlds === undefined) {\n\n        Assert(internals.tlds, 'Built-in TLD list disabled');\n        return Object.assign({}, options, internals.tlds);\n    }\n\n    Assert(typeof options.tlds === 'object', 'tlds must be true, false, or an object');\n\n    const deny = options.tlds.deny;\n    if (deny) {\n        if (Array.isArray(deny)) {\n            options = Object.assign({}, options, { tlds: { deny: new Set(deny) } });\n        }\n\n        Assert(options.tlds.deny instanceof Set, 'tlds.deny must be an array, Set, or boolean');\n        Assert(!options.tlds.allow, 'Cannot specify both tlds.allow and tlds.deny lists');\n        internals.validateTlds(options.tlds.deny, 'tlds.deny');\n        return options;\n    }\n\n    const allow = options.tlds.allow;\n    if (!allow) {\n        return options;\n    }\n\n    if (allow === true) {\n        Assert(internals.tlds, 'Built-in TLD list disabled');\n        return Object.assign({}, options, internals.tlds);\n    }\n\n    if (Array.isArray(allow)) {\n        options = Object.assign({}, options, { tlds: { allow: new Set(allow) } });\n    }\n\n    Assert(options.tlds.allow instanceof Set, 'tlds.allow must be an array, Set, or boolean');\n    internals.validateTlds(options.tlds.allow, 'tlds.allow');\n    return options;\n};\n\n\ninternals.validateTlds = function (set, source) {\n\n    for (const tld of set) {\n        Assert(Domain.isValid(tld, { minDomainSegments: 1, maxDomainSegments: 1 }), `${source} must contain valid top level domain names`);\n    }\n};\n\n\ninternals.isoDate = function (value) {\n\n    if (!Common.isIsoDate(value)) {\n        return null;\n    }\n\n    if (/.*T.*[+-]\\d\\d$/.test(value)) {             // Add missing trailing zeros to timeshift\n        value += '00';\n    }\n\n    const date = new Date(value);\n    if (isNaN(date.getTime())) {\n        return null;\n    }\n\n    return date.toISOString();\n};\n\n\ninternals.length = function (schema, name, limit, operator, encoding) {\n\n    Assert(!encoding || Buffer && Buffer.isEncoding(encoding), 'Invalid encoding:', encoding);      // $lab:coverage:ignore$\n\n    return schema.$_addRule({ name, method: 'length', args: { limit, encoding }, operator });\n};\n"]},"metadata":{},"sourceType":"script"}