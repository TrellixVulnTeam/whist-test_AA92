{"ast":null,"code":"'use strict';\n\nconst ApplyToDefaults = require('@hapi/hoek/lib/applyToDefaults');\n\nconst Assert = require('@hapi/hoek/lib/assert');\n\nconst Clone = require('@hapi/hoek/lib/clone');\n\nconst Topo = require('@hapi/topo');\n\nconst Any = require('./any');\n\nconst Common = require('../common');\n\nconst Compile = require('../compile');\n\nconst Errors = require('../errors');\n\nconst Ref = require('../ref');\n\nconst Template = require('../template');\n\nconst internals = {\n  renameDefaults: {\n    alias: false,\n    // Keep old value in place\n    multiple: false,\n    // Allow renaming multiple keys into the same target\n    override: false // Overrides an existing key\n\n  }\n};\nmodule.exports = Any.extend({\n  type: '_keys',\n  properties: {\n    typeof: 'object'\n  },\n  flags: {\n    unknown: {\n      default: false\n    }\n  },\n  terms: {\n    dependencies: {\n      init: null\n    },\n    keys: {\n      init: null,\n      manifest: {\n        mapped: {\n          from: 'schema',\n          to: 'key'\n        }\n      }\n    },\n    patterns: {\n      init: null\n    },\n    renames: {\n      init: null\n    }\n  },\n\n  args(schema, keys) {\n    return schema.keys(keys);\n  },\n\n  validate(value, {\n    schema,\n    error,\n    state,\n    prefs\n  }) {\n    if (!value || typeof value !== schema.$_property('typeof') || Array.isArray(value)) {\n      return {\n        value,\n        errors: error('object.base', {\n          type: schema.$_property('typeof')\n        })\n      };\n    } // Skip if there are no other rules to test\n\n\n    if (!schema.$_terms.renames && !schema.$_terms.dependencies && !schema.$_terms.keys && // null allows any keys\n    !schema.$_terms.patterns && !schema.$_terms.externals) {\n      return;\n    } // Shallow clone value\n\n\n    value = internals.clone(value, prefs);\n    const errors = []; // Rename keys\n\n    if (schema.$_terms.renames && !internals.rename(schema, value, state, prefs, errors)) {\n      return {\n        value,\n        errors\n      };\n    } // Anything allowed\n\n\n    if (!schema.$_terms.keys && // null allows any keys\n    !schema.$_terms.patterns && !schema.$_terms.dependencies) {\n      return {\n        value,\n        errors\n      };\n    } // Defined keys\n\n\n    const unprocessed = new Set(Object.keys(value));\n\n    if (schema.$_terms.keys) {\n      const ancestors = [value, ...state.ancestors];\n\n      for (const child of schema.$_terms.keys) {\n        const key = child.key;\n        const item = value[key];\n        unprocessed.delete(key);\n        const localState = state.localize([...state.path, key], ancestors, child);\n        const result = child.schema.$_validate(item, localState, prefs);\n\n        if (result.errors) {\n          if (prefs.abortEarly) {\n            return {\n              value,\n              errors: result.errors\n            };\n          }\n\n          if (result.value !== undefined) {\n            value[key] = result.value;\n          }\n\n          errors.push(...result.errors);\n        } else if (child.schema._flags.result === 'strip' || result.value === undefined && item !== undefined) {\n          delete value[key];\n        } else if (result.value !== undefined) {\n          value[key] = result.value;\n        }\n      }\n    } // Unknown keys\n\n\n    if (unprocessed.size || schema._flags._hasPatternMatch) {\n      const early = internals.unknown(schema, value, unprocessed, errors, state, prefs);\n\n      if (early) {\n        return early;\n      }\n    } // Validate dependencies\n\n\n    if (schema.$_terms.dependencies) {\n      for (const dep of schema.$_terms.dependencies) {\n        if (dep.key && dep.key.resolve(value, state, prefs, null, {\n          shadow: false\n        }) === undefined) {\n          continue;\n        }\n\n        const failed = internals.dependencies[dep.rel](schema, dep, value, state, prefs);\n\n        if (failed) {\n          const report = schema.$_createError(failed.code, value, failed.context, state, prefs);\n\n          if (prefs.abortEarly) {\n            return {\n              value,\n              errors: report\n            };\n          }\n\n          errors.push(report);\n        }\n      }\n    }\n\n    return {\n      value,\n      errors\n    };\n  },\n\n  rules: {\n    and: {\n      method(...peers\n      /*, [options] */\n      ) {\n        Common.verifyFlat(peers, 'and');\n        return internals.dependency(this, 'and', null, peers);\n      }\n\n    },\n    append: {\n      method(schema) {\n        if (schema === null || schema === undefined || Object.keys(schema).length === 0) {\n          return this;\n        }\n\n        return this.keys(schema);\n      }\n\n    },\n    assert: {\n      method(subject, schema, message) {\n        if (!Template.isTemplate(subject)) {\n          subject = Compile.ref(subject);\n        }\n\n        Assert(message === undefined || typeof message === 'string', 'Message must be a string');\n        schema = this.$_compile(schema, {\n          appendPath: true\n        });\n        const obj = this.$_addRule({\n          name: 'assert',\n          args: {\n            subject,\n            schema,\n            message\n          }\n        });\n        obj.$_mutateRegister(subject);\n        obj.$_mutateRegister(schema);\n        return obj;\n      },\n\n      validate(value, {\n        error,\n        prefs,\n        state\n      }, {\n        subject,\n        schema,\n        message\n      }) {\n        const about = subject.resolve(value, state, prefs);\n        const path = Ref.isRef(subject) ? subject.absolute(state) : [];\n\n        if (schema.$_match(about, state.localize(path, [value, ...state.ancestors], schema), prefs)) {\n          return value;\n        }\n\n        return error('object.assert', {\n          subject,\n          message\n        });\n      },\n\n      args: ['subject', 'schema', 'message'],\n      multi: true\n    },\n    instance: {\n      method(constructor, name) {\n        Assert(typeof constructor === 'function', 'constructor must be a function');\n        name = name || constructor.name;\n        return this.$_addRule({\n          name: 'instance',\n          args: {\n            constructor,\n            name\n          }\n        });\n      },\n\n      validate(value, helpers, {\n        constructor,\n        name\n      }) {\n        if (value instanceof constructor) {\n          return value;\n        }\n\n        return helpers.error('object.instance', {\n          type: name,\n          value\n        });\n      },\n\n      args: ['constructor', 'name']\n    },\n    keys: {\n      method(schema) {\n        Assert(schema === undefined || typeof schema === 'object', 'Object schema must be a valid object');\n        Assert(!Common.isSchema(schema), 'Object schema cannot be a joi schema');\n        const obj = this.clone();\n\n        if (!schema) {\n          // Allow all\n          obj.$_terms.keys = null;\n        } else if (!Object.keys(schema).length) {\n          // Allow none\n          obj.$_terms.keys = new internals.Keys();\n        } else {\n          obj.$_terms.keys = obj.$_terms.keys ? obj.$_terms.keys.filter(child => !schema.hasOwnProperty(child.key)) : new internals.Keys();\n\n          for (const key in schema) {\n            Common.tryWithPath(() => obj.$_terms.keys.push({\n              key,\n              schema: this.$_compile(schema[key])\n            }), key);\n          }\n        }\n\n        return obj.$_mutateRebuild();\n      }\n\n    },\n    length: {\n      method(limit) {\n        return this.$_addRule({\n          name: 'length',\n          args: {\n            limit\n          },\n          operator: '='\n        });\n      },\n\n      validate(value, helpers, {\n        limit\n      }, {\n        name,\n        operator,\n        args\n      }) {\n        if (Common.compare(Object.keys(value).length, limit, operator)) {\n          return value;\n        }\n\n        return helpers.error('object.' + name, {\n          limit: args.limit,\n          value\n        });\n      },\n\n      args: [{\n        name: 'limit',\n        ref: true,\n        assert: Common.limit,\n        message: 'must be a positive integer'\n      }]\n    },\n    max: {\n      method(limit) {\n        return this.$_addRule({\n          name: 'max',\n          method: 'length',\n          args: {\n            limit\n          },\n          operator: '<='\n        });\n      }\n\n    },\n    min: {\n      method(limit) {\n        return this.$_addRule({\n          name: 'min',\n          method: 'length',\n          args: {\n            limit\n          },\n          operator: '>='\n        });\n      }\n\n    },\n    nand: {\n      method(...peers\n      /*, [options] */\n      ) {\n        Common.verifyFlat(peers, 'nand');\n        return internals.dependency(this, 'nand', null, peers);\n      }\n\n    },\n    or: {\n      method(...peers\n      /*, [options] */\n      ) {\n        Common.verifyFlat(peers, 'or');\n        return internals.dependency(this, 'or', null, peers);\n      }\n\n    },\n    oxor: {\n      method(...peers\n      /*, [options] */\n      ) {\n        return internals.dependency(this, 'oxor', null, peers);\n      }\n\n    },\n    pattern: {\n      method(pattern, schema, options = {}) {\n        const isRegExp = pattern instanceof RegExp;\n\n        if (!isRegExp) {\n          pattern = this.$_compile(pattern, {\n            appendPath: true\n          });\n        }\n\n        Assert(schema !== undefined, 'Invalid rule');\n        Common.assertOptions(options, ['fallthrough', 'matches']);\n\n        if (isRegExp) {\n          Assert(!pattern.flags.includes('g') && !pattern.flags.includes('y'), 'pattern should not use global or sticky mode');\n        }\n\n        schema = this.$_compile(schema, {\n          appendPath: true\n        });\n        const obj = this.clone();\n        obj.$_terms.patterns = obj.$_terms.patterns || [];\n        const config = {\n          [isRegExp ? 'regex' : 'schema']: pattern,\n          rule: schema\n        };\n\n        if (options.matches) {\n          config.matches = this.$_compile(options.matches);\n\n          if (config.matches.type !== 'array') {\n            config.matches = config.matches.$_root.array().items(config.matches);\n          }\n\n          obj.$_mutateRegister(config.matches);\n          obj.$_setFlag('_hasPatternMatch', true, {\n            clone: false\n          });\n        }\n\n        if (options.fallthrough) {\n          config.fallthrough = true;\n        }\n\n        obj.$_terms.patterns.push(config);\n        obj.$_mutateRegister(schema);\n        return obj;\n      }\n\n    },\n    ref: {\n      method() {\n        return this.$_addRule('ref');\n      },\n\n      validate(value, helpers) {\n        if (Ref.isRef(value)) {\n          return value;\n        }\n\n        return helpers.error('object.refType', {\n          value\n        });\n      }\n\n    },\n    regex: {\n      method() {\n        return this.$_addRule('regex');\n      },\n\n      validate(value, helpers) {\n        if (value instanceof RegExp) {\n          return value;\n        }\n\n        return helpers.error('object.regex', {\n          value\n        });\n      }\n\n    },\n    rename: {\n      method(from, to, options = {}) {\n        Assert(typeof from === 'string' || from instanceof RegExp, 'Rename missing the from argument');\n        Assert(typeof to === 'string' || to instanceof Template, 'Invalid rename to argument');\n        Assert(to !== from, 'Cannot rename key to same name:', from);\n        Common.assertOptions(options, ['alias', 'ignoreUndefined', 'override', 'multiple']);\n        const obj = this.clone();\n        obj.$_terms.renames = obj.$_terms.renames || [];\n\n        for (const rename of obj.$_terms.renames) {\n          Assert(rename.from !== from, 'Cannot rename the same key multiple times');\n        }\n\n        if (to instanceof Template) {\n          obj.$_mutateRegister(to);\n        }\n\n        obj.$_terms.renames.push({\n          from,\n          to,\n          options: ApplyToDefaults(internals.renameDefaults, options)\n        });\n        return obj;\n      }\n\n    },\n    schema: {\n      method(type = 'any') {\n        return this.$_addRule({\n          name: 'schema',\n          args: {\n            type\n          }\n        });\n      },\n\n      validate(value, helpers, {\n        type\n      }) {\n        if (Common.isSchema(value) && (type === 'any' || value.type === type)) {\n          return value;\n        }\n\n        return helpers.error('object.schema', {\n          type\n        });\n      }\n\n    },\n    unknown: {\n      method(allow) {\n        return this.$_setFlag('unknown', allow !== false);\n      }\n\n    },\n    with: {\n      method(key, peers, options = {}) {\n        return internals.dependency(this, 'with', key, peers, options);\n      }\n\n    },\n    without: {\n      method(key, peers, options = {}) {\n        return internals.dependency(this, 'without', key, peers, options);\n      }\n\n    },\n    xor: {\n      method(...peers\n      /*, [options] */\n      ) {\n        Common.verifyFlat(peers, 'xor');\n        return internals.dependency(this, 'xor', null, peers);\n      }\n\n    }\n  },\n  overrides: {\n    default(value, options) {\n      if (value === undefined) {\n        value = Common.symbols.deepDefault;\n      }\n\n      return this.$_parent('default', value, options);\n    }\n\n  },\n\n  rebuild(schema) {\n    if (schema.$_terms.keys) {\n      const topo = new Topo.Sorter();\n\n      for (const child of schema.$_terms.keys) {\n        Common.tryWithPath(() => topo.add(child, {\n          after: child.schema.$_rootReferences(),\n          group: child.key\n        }), child.key);\n      }\n\n      schema.$_terms.keys = new internals.Keys(...topo.nodes);\n    }\n  },\n\n  manifest: {\n    build(obj, desc) {\n      if (desc.keys) {\n        obj = obj.keys(desc.keys);\n      }\n\n      if (desc.dependencies) {\n        for (const {\n          rel,\n          key = null,\n          peers,\n          options\n        } of desc.dependencies) {\n          obj = internals.dependency(obj, rel, key, peers, options);\n        }\n      }\n\n      if (desc.patterns) {\n        for (const {\n          regex,\n          schema,\n          rule,\n          fallthrough,\n          matches\n        } of desc.patterns) {\n          obj = obj.pattern(regex || schema, rule, {\n            fallthrough,\n            matches\n          });\n        }\n      }\n\n      if (desc.renames) {\n        for (const {\n          from,\n          to,\n          options\n        } of desc.renames) {\n          obj = obj.rename(from, to, options);\n        }\n      }\n\n      return obj;\n    }\n\n  },\n  messages: {\n    'object.and': '{{#label}} contains {{#presentWithLabels}} without its required peers {{#missingWithLabels}}',\n    'object.assert': '{{#label}} is invalid because {if(#subject.key, `\"` + #subject.key + `\" failed to ` + (#message || \"pass the assertion test\"), #message || \"the assertion failed\")}',\n    'object.base': '{{#label}} must be of type {{#type}}',\n    'object.instance': '{{#label}} must be an instance of {{:#type}}',\n    'object.length': '{{#label}} must have {{#limit}} key{if(#limit == 1, \"\", \"s\")}',\n    'object.max': '{{#label}} must have less than or equal to {{#limit}} key{if(#limit == 1, \"\", \"s\")}',\n    'object.min': '{{#label}} must have at least {{#limit}} key{if(#limit == 1, \"\", \"s\")}',\n    'object.missing': '{{#label}} must contain at least one of {{#peersWithLabels}}',\n    'object.nand': '{{:#mainWithLabel}} must not exist simultaneously with {{#peersWithLabels}}',\n    'object.oxor': '{{#label}} contains a conflict between optional exclusive peers {{#peersWithLabels}}',\n    'object.pattern.match': '{{#label}} keys failed to match pattern requirements',\n    'object.refType': '{{#label}} must be a Joi reference',\n    'object.regex': '{{#label}} must be a RegExp object',\n    'object.rename.multiple': '{{#label}} cannot rename {{:#from}} because multiple renames are disabled and another key was already renamed to {{:#to}}',\n    'object.rename.override': '{{#label}} cannot rename {{:#from}} because override is disabled and target {{:#to}} exists',\n    'object.schema': '{{#label}} must be a Joi schema of {{#type}} type',\n    'object.unknown': '{{#label}} is not allowed',\n    'object.with': '{{:#mainWithLabel}} missing required peer {{:#peerWithLabel}}',\n    'object.without': '{{:#mainWithLabel}} conflict with forbidden peer {{:#peerWithLabel}}',\n    'object.xor': '{{#label}} contains a conflict between exclusive peers {{#peersWithLabels}}'\n  }\n}); // Helpers\n\ninternals.clone = function (value, prefs) {\n  // Object\n  if (typeof value === 'object') {\n    if (prefs.nonEnumerables) {\n      return Clone(value, {\n        shallow: true\n      });\n    }\n\n    const clone = Object.create(Object.getPrototypeOf(value));\n    Object.assign(clone, value);\n    return clone;\n  } // Function\n\n\n  const clone = function (...args) {\n    return value.apply(this, args);\n  };\n\n  clone.prototype = Clone(value.prototype);\n  Object.defineProperty(clone, 'name', {\n    value: value.name,\n    writable: false\n  });\n  Object.defineProperty(clone, 'length', {\n    value: value.length,\n    writable: false\n  });\n  Object.assign(clone, value);\n  return clone;\n};\n\ninternals.dependency = function (schema, rel, key, peers, options) {\n  Assert(key === null || typeof key === 'string', rel, 'key must be a strings'); // Extract options from peers array\n\n  if (!options) {\n    options = peers.length > 1 && typeof peers[peers.length - 1] === 'object' ? peers.pop() : {};\n  }\n\n  Common.assertOptions(options, ['separator']);\n  peers = [].concat(peers); // Cast peer paths\n\n  const separator = Common.default(options.separator, '.');\n  const paths = [];\n\n  for (const peer of peers) {\n    Assert(typeof peer === 'string', rel, 'peers must be strings');\n    paths.push(Compile.ref(peer, {\n      separator,\n      ancestor: 0,\n      prefix: false\n    }));\n  } // Cast key\n\n\n  if (key !== null) {\n    key = Compile.ref(key, {\n      separator,\n      ancestor: 0,\n      prefix: false\n    });\n  } // Add rule\n\n\n  const obj = schema.clone();\n  obj.$_terms.dependencies = obj.$_terms.dependencies || [];\n  obj.$_terms.dependencies.push(new internals.Dependency(rel, key, paths, peers));\n  return obj;\n};\n\ninternals.dependencies = {\n  and(schema, dep, value, state, prefs) {\n    const missing = [];\n    const present = [];\n    const count = dep.peers.length;\n\n    for (const peer of dep.peers) {\n      if (peer.resolve(value, state, prefs, null, {\n        shadow: false\n      }) === undefined) {\n        missing.push(peer.key);\n      } else {\n        present.push(peer.key);\n      }\n    }\n\n    if (missing.length !== count && present.length !== count) {\n      return {\n        code: 'object.and',\n        context: {\n          present,\n          presentWithLabels: internals.keysToLabels(schema, present),\n          missing,\n          missingWithLabels: internals.keysToLabels(schema, missing)\n        }\n      };\n    }\n  },\n\n  nand(schema, dep, value, state, prefs) {\n    const present = [];\n\n    for (const peer of dep.peers) {\n      if (peer.resolve(value, state, prefs, null, {\n        shadow: false\n      }) !== undefined) {\n        present.push(peer.key);\n      }\n    }\n\n    if (present.length !== dep.peers.length) {\n      return;\n    }\n\n    const main = dep.paths[0];\n    const values = dep.paths.slice(1);\n    return {\n      code: 'object.nand',\n      context: {\n        main,\n        mainWithLabel: internals.keysToLabels(schema, main),\n        peers: values,\n        peersWithLabels: internals.keysToLabels(schema, values)\n      }\n    };\n  },\n\n  or(schema, dep, value, state, prefs) {\n    for (const peer of dep.peers) {\n      if (peer.resolve(value, state, prefs, null, {\n        shadow: false\n      }) !== undefined) {\n        return;\n      }\n    }\n\n    return {\n      code: 'object.missing',\n      context: {\n        peers: dep.paths,\n        peersWithLabels: internals.keysToLabels(schema, dep.paths)\n      }\n    };\n  },\n\n  oxor(schema, dep, value, state, prefs) {\n    const present = [];\n\n    for (const peer of dep.peers) {\n      if (peer.resolve(value, state, prefs, null, {\n        shadow: false\n      }) !== undefined) {\n        present.push(peer.key);\n      }\n    }\n\n    if (!present.length || present.length === 1) {\n      return;\n    }\n\n    const context = {\n      peers: dep.paths,\n      peersWithLabels: internals.keysToLabels(schema, dep.paths)\n    };\n    context.present = present;\n    context.presentWithLabels = internals.keysToLabels(schema, present);\n    return {\n      code: 'object.oxor',\n      context\n    };\n  },\n\n  with(schema, dep, value, state, prefs) {\n    for (const peer of dep.peers) {\n      if (peer.resolve(value, state, prefs, null, {\n        shadow: false\n      }) === undefined) {\n        return {\n          code: 'object.with',\n          context: {\n            main: dep.key.key,\n            mainWithLabel: internals.keysToLabels(schema, dep.key.key),\n            peer: peer.key,\n            peerWithLabel: internals.keysToLabels(schema, peer.key)\n          }\n        };\n      }\n    }\n  },\n\n  without(schema, dep, value, state, prefs) {\n    for (const peer of dep.peers) {\n      if (peer.resolve(value, state, prefs, null, {\n        shadow: false\n      }) !== undefined) {\n        return {\n          code: 'object.without',\n          context: {\n            main: dep.key.key,\n            mainWithLabel: internals.keysToLabels(schema, dep.key.key),\n            peer: peer.key,\n            peerWithLabel: internals.keysToLabels(schema, peer.key)\n          }\n        };\n      }\n    }\n  },\n\n  xor(schema, dep, value, state, prefs) {\n    const present = [];\n\n    for (const peer of dep.peers) {\n      if (peer.resolve(value, state, prefs, null, {\n        shadow: false\n      }) !== undefined) {\n        present.push(peer.key);\n      }\n    }\n\n    if (present.length === 1) {\n      return;\n    }\n\n    const context = {\n      peers: dep.paths,\n      peersWithLabels: internals.keysToLabels(schema, dep.paths)\n    };\n\n    if (present.length === 0) {\n      return {\n        code: 'object.missing',\n        context\n      };\n    }\n\n    context.present = present;\n    context.presentWithLabels = internals.keysToLabels(schema, present);\n    return {\n      code: 'object.xor',\n      context\n    };\n  }\n\n};\n\ninternals.keysToLabels = function (schema, keys) {\n  if (Array.isArray(keys)) {\n    return keys.map(key => schema.$_mapLabels(key));\n  }\n\n  return schema.$_mapLabels(keys);\n};\n\ninternals.rename = function (schema, value, state, prefs, errors) {\n  const renamed = {};\n\n  for (const rename of schema.$_terms.renames) {\n    const matches = [];\n    const pattern = typeof rename.from !== 'string';\n\n    if (!pattern) {\n      if (Object.prototype.hasOwnProperty.call(value, rename.from) && (value[rename.from] !== undefined || !rename.options.ignoreUndefined)) {\n        matches.push(rename);\n      }\n    } else {\n      for (const from in value) {\n        if (value[from] === undefined && rename.options.ignoreUndefined) {\n          continue;\n        }\n\n        if (from === rename.to) {\n          continue;\n        }\n\n        const match = rename.from.exec(from);\n\n        if (!match) {\n          continue;\n        }\n\n        matches.push({\n          from,\n          to: rename.to,\n          match\n        });\n      }\n    }\n\n    for (const match of matches) {\n      const from = match.from;\n      let to = match.to;\n\n      if (to instanceof Template) {\n        to = to.render(value, state, prefs, match.match);\n      }\n\n      if (from === to) {\n        continue;\n      }\n\n      if (!rename.options.multiple && renamed[to]) {\n        errors.push(schema.$_createError('object.rename.multiple', value, {\n          from,\n          to,\n          pattern\n        }, state, prefs));\n\n        if (prefs.abortEarly) {\n          return false;\n        }\n      }\n\n      if (Object.prototype.hasOwnProperty.call(value, to) && !rename.options.override && !renamed[to]) {\n        errors.push(schema.$_createError('object.rename.override', value, {\n          from,\n          to,\n          pattern\n        }, state, prefs));\n\n        if (prefs.abortEarly) {\n          return false;\n        }\n      }\n\n      if (value[from] === undefined) {\n        delete value[to];\n      } else {\n        value[to] = value[from];\n      }\n\n      renamed[to] = true;\n\n      if (!rename.options.alias) {\n        delete value[from];\n      }\n    }\n  }\n\n  return true;\n};\n\ninternals.unknown = function (schema, value, unprocessed, errors, state, prefs) {\n  if (schema.$_terms.patterns) {\n    let hasMatches = false;\n    const matches = schema.$_terms.patterns.map(pattern => {\n      if (pattern.matches) {\n        hasMatches = true;\n        return [];\n      }\n    });\n    const ancestors = [value, ...state.ancestors];\n\n    for (const key of unprocessed) {\n      const item = value[key];\n      const path = [...state.path, key];\n\n      for (let i = 0; i < schema.$_terms.patterns.length; ++i) {\n        const pattern = schema.$_terms.patterns[i];\n\n        if (pattern.regex) {\n          const match = pattern.regex.test(key);\n          state.mainstay.tracer.debug(state, 'rule', `pattern.${i}`, match ? 'pass' : 'error');\n\n          if (!match) {\n            continue;\n          }\n        } else {\n          if (!pattern.schema.$_match(key, state.nest(pattern.schema, `pattern.${i}`), prefs)) {\n            continue;\n          }\n        }\n\n        unprocessed.delete(key);\n        const localState = state.localize(path, ancestors, {\n          schema: pattern.rule,\n          key\n        });\n        const result = pattern.rule.$_validate(item, localState, prefs);\n\n        if (result.errors) {\n          if (prefs.abortEarly) {\n            return {\n              value,\n              errors: result.errors\n            };\n          }\n\n          errors.push(...result.errors);\n        }\n\n        if (pattern.matches) {\n          matches[i].push(key);\n        }\n\n        value[key] = result.value;\n\n        if (!pattern.fallthrough) {\n          break;\n        }\n      }\n    } // Validate pattern matches rules\n\n\n    if (hasMatches) {\n      for (let i = 0; i < matches.length; ++i) {\n        const match = matches[i];\n\n        if (!match) {\n          continue;\n        }\n\n        const stpm = schema.$_terms.patterns[i].matches;\n        const localState = state.localize(state.path, ancestors, stpm);\n        const result = stpm.$_validate(match, localState, prefs);\n\n        if (result.errors) {\n          const details = Errors.details(result.errors, {\n            override: false\n          });\n          details.matches = match;\n          const report = schema.$_createError('object.pattern.match', value, details, state, prefs);\n\n          if (prefs.abortEarly) {\n            return {\n              value,\n              errors: report\n            };\n          }\n\n          errors.push(report);\n        }\n      }\n    }\n  }\n\n  if (!unprocessed.size || !schema.$_terms.keys && !schema.$_terms.patterns) {\n    // If no keys or patterns specified, unknown keys allowed\n    return;\n  }\n\n  if (prefs.stripUnknown && !schema._flags.unknown || prefs.skipFunctions) {\n    const stripUnknown = prefs.stripUnknown ? prefs.stripUnknown === true ? true : !!prefs.stripUnknown.objects : false;\n\n    for (const key of unprocessed) {\n      if (stripUnknown) {\n        delete value[key];\n        unprocessed.delete(key);\n      } else if (typeof value[key] === 'function') {\n        unprocessed.delete(key);\n      }\n    }\n  }\n\n  const forbidUnknown = !Common.default(schema._flags.unknown, prefs.allowUnknown);\n\n  if (forbidUnknown) {\n    for (const unprocessedKey of unprocessed) {\n      const localState = state.localize([...state.path, unprocessedKey], []);\n      const report = schema.$_createError('object.unknown', value[unprocessedKey], {\n        child: unprocessedKey\n      }, localState, prefs, {\n        flags: false\n      });\n\n      if (prefs.abortEarly) {\n        return {\n          value,\n          errors: report\n        };\n      }\n\n      errors.push(report);\n    }\n  }\n};\n\ninternals.Dependency = class {\n  constructor(rel, key, peers, paths) {\n    this.rel = rel;\n    this.key = key;\n    this.peers = peers;\n    this.paths = paths;\n  }\n\n  describe() {\n    const desc = {\n      rel: this.rel,\n      peers: this.paths\n    };\n\n    if (this.key !== null) {\n      desc.key = this.key.key;\n    }\n\n    if (this.peers[0].separator !== '.') {\n      desc.options = {\n        separator: this.peers[0].separator\n      };\n    }\n\n    return desc;\n  }\n\n};\ninternals.Keys = class extends Array {\n  concat(source) {\n    const result = this.slice();\n    const keys = new Map();\n\n    for (let i = 0; i < result.length; ++i) {\n      keys.set(result[i].key, i);\n    }\n\n    for (const item of source) {\n      const key = item.key;\n      const pos = keys.get(key);\n\n      if (pos !== undefined) {\n        result[pos] = {\n          key,\n          schema: result[pos].schema.concat(item.schema)\n        };\n      } else {\n        result.push(item);\n      }\n    }\n\n    return result;\n  }\n\n};","map":{"version":3,"sources":["C:/scripting/jobs assignments/whist/backend/node_modules/joi/lib/types/keys.js"],"names":["ApplyToDefaults","require","Assert","Clone","Topo","Any","Common","Compile","Errors","Ref","Template","internals","renameDefaults","alias","multiple","override","module","exports","extend","type","properties","typeof","flags","unknown","default","terms","dependencies","init","keys","manifest","mapped","from","to","patterns","renames","args","schema","validate","value","error","state","prefs","$_property","Array","isArray","errors","$_terms","externals","clone","rename","unprocessed","Set","Object","ancestors","child","key","item","delete","localState","localize","path","result","$_validate","abortEarly","undefined","push","_flags","size","_hasPatternMatch","early","dep","resolve","shadow","failed","rel","report","$_createError","code","context","rules","and","method","peers","verifyFlat","dependency","append","length","assert","subject","message","isTemplate","ref","$_compile","appendPath","obj","$_addRule","name","$_mutateRegister","about","isRef","absolute","$_match","multi","instance","constructor","helpers","isSchema","Keys","filter","hasOwnProperty","tryWithPath","$_mutateRebuild","limit","operator","compare","max","min","nand","or","oxor","pattern","options","isRegExp","RegExp","assertOptions","includes","config","rule","matches","$_root","array","items","$_setFlag","fallthrough","regex","allow","with","without","xor","overrides","symbols","deepDefault","$_parent","rebuild","topo","Sorter","add","after","$_rootReferences","group","nodes","build","desc","messages","nonEnumerables","shallow","create","getPrototypeOf","assign","apply","prototype","defineProperty","writable","pop","concat","separator","paths","peer","ancestor","prefix","Dependency","missing","present","count","presentWithLabels","keysToLabels","missingWithLabels","main","values","slice","mainWithLabel","peersWithLabels","peerWithLabel","map","$_mapLabels","renamed","call","ignoreUndefined","match","exec","render","hasMatches","i","test","mainstay","tracer","debug","nest","stpm","details","stripUnknown","skipFunctions","objects","forbidUnknown","allowUnknown","unprocessedKey","describe","source","Map","set","pos","get"],"mappings":"AAAA;;AAEA,MAAMA,eAAe,GAAGC,OAAO,CAAC,gCAAD,CAA/B;;AACA,MAAMC,MAAM,GAAGD,OAAO,CAAC,uBAAD,CAAtB;;AACA,MAAME,KAAK,GAAGF,OAAO,CAAC,sBAAD,CAArB;;AACA,MAAMG,IAAI,GAAGH,OAAO,CAAC,YAAD,CAApB;;AAEA,MAAMI,GAAG,GAAGJ,OAAO,CAAC,OAAD,CAAnB;;AACA,MAAMK,MAAM,GAAGL,OAAO,CAAC,WAAD,CAAtB;;AACA,MAAMM,OAAO,GAAGN,OAAO,CAAC,YAAD,CAAvB;;AACA,MAAMO,MAAM,GAAGP,OAAO,CAAC,WAAD,CAAtB;;AACA,MAAMQ,GAAG,GAAGR,OAAO,CAAC,QAAD,CAAnB;;AACA,MAAMS,QAAQ,GAAGT,OAAO,CAAC,aAAD,CAAxB;;AAGA,MAAMU,SAAS,GAAG;AACdC,EAAAA,cAAc,EAAE;AACZC,IAAAA,KAAK,EAAE,KADK;AACoB;AAChCC,IAAAA,QAAQ,EAAE,KAFE;AAEoB;AAChCC,IAAAA,QAAQ,EAAE,KAHE,CAGoB;;AAHpB;AADF,CAAlB;AASAC,MAAM,CAACC,OAAP,GAAiBZ,GAAG,CAACa,MAAJ,CAAW;AAExBC,EAAAA,IAAI,EAAE,OAFkB;AAIxBC,EAAAA,UAAU,EAAE;AAERC,IAAAA,MAAM,EAAE;AAFA,GAJY;AASxBC,EAAAA,KAAK,EAAE;AAEHC,IAAAA,OAAO,EAAE;AAAEC,MAAAA,OAAO,EAAE;AAAX;AAFN,GATiB;AAcxBC,EAAAA,KAAK,EAAE;AAEHC,IAAAA,YAAY,EAAE;AAAEC,MAAAA,IAAI,EAAE;AAAR,KAFX;AAGHC,IAAAA,IAAI,EAAE;AAAED,MAAAA,IAAI,EAAE,IAAR;AAAcE,MAAAA,QAAQ,EAAE;AAAEC,QAAAA,MAAM,EAAE;AAAEC,UAAAA,IAAI,EAAE,QAAR;AAAkBC,UAAAA,EAAE,EAAE;AAAtB;AAAV;AAAxB,KAHH;AAIHC,IAAAA,QAAQ,EAAE;AAAEN,MAAAA,IAAI,EAAE;AAAR,KAJP;AAKHO,IAAAA,OAAO,EAAE;AAAEP,MAAAA,IAAI,EAAE;AAAR;AALN,GAdiB;;AAsBxBQ,EAAAA,IAAI,CAACC,MAAD,EAASR,IAAT,EAAe;AAEf,WAAOQ,MAAM,CAACR,IAAP,CAAYA,IAAZ,CAAP;AACH,GAzBuB;;AA2BxBS,EAAAA,QAAQ,CAACC,KAAD,EAAQ;AAAEF,IAAAA,MAAF;AAAUG,IAAAA,KAAV;AAAiBC,IAAAA,KAAjB;AAAwBC,IAAAA;AAAxB,GAAR,EAAyC;AAE7C,QAAI,CAACH,KAAD,IACA,OAAOA,KAAP,KAAiBF,MAAM,CAACM,UAAP,CAAkB,QAAlB,CADjB,IAEAC,KAAK,CAACC,OAAN,CAAcN,KAAd,CAFJ,EAE0B;AAEtB,aAAO;AAAEA,QAAAA,KAAF;AAASO,QAAAA,MAAM,EAAEN,KAAK,CAAC,aAAD,EAAgB;AAAEpB,UAAAA,IAAI,EAAEiB,MAAM,CAACM,UAAP,CAAkB,QAAlB;AAAR,SAAhB;AAAtB,OAAP;AACH,KAP4C,CAS7C;;;AAEA,QAAI,CAACN,MAAM,CAACU,OAAP,CAAeZ,OAAhB,IACA,CAACE,MAAM,CAACU,OAAP,CAAepB,YADhB,IAEA,CAACU,MAAM,CAACU,OAAP,CAAelB,IAFhB,IAE8C;AAC9C,KAACQ,MAAM,CAACU,OAAP,CAAeb,QAHhB,IAIA,CAACG,MAAM,CAACU,OAAP,CAAeC,SAJpB,EAI+B;AAE3B;AACH,KAlB4C,CAoB7C;;;AAEAT,IAAAA,KAAK,GAAG3B,SAAS,CAACqC,KAAV,CAAgBV,KAAhB,EAAuBG,KAAvB,CAAR;AACA,UAAMI,MAAM,GAAG,EAAf,CAvB6C,CAyB7C;;AAEA,QAAIT,MAAM,CAACU,OAAP,CAAeZ,OAAf,IACA,CAACvB,SAAS,CAACsC,MAAV,CAAiBb,MAAjB,EAAyBE,KAAzB,EAAgCE,KAAhC,EAAuCC,KAAvC,EAA8CI,MAA9C,CADL,EAC4D;AAExD,aAAO;AAAEP,QAAAA,KAAF;AAASO,QAAAA;AAAT,OAAP;AACH,KA/B4C,CAiC7C;;;AAEA,QAAI,CAACT,MAAM,CAACU,OAAP,CAAelB,IAAhB,IAA8C;AAC9C,KAACQ,MAAM,CAACU,OAAP,CAAeb,QADhB,IAEA,CAACG,MAAM,CAACU,OAAP,CAAepB,YAFpB,EAEkC;AAE9B,aAAO;AAAEY,QAAAA,KAAF;AAASO,QAAAA;AAAT,OAAP;AACH,KAxC4C,CA0C7C;;;AAEA,UAAMK,WAAW,GAAG,IAAIC,GAAJ,CAAQC,MAAM,CAACxB,IAAP,CAAYU,KAAZ,CAAR,CAApB;;AAEA,QAAIF,MAAM,CAACU,OAAP,CAAelB,IAAnB,EAAyB;AACrB,YAAMyB,SAAS,GAAG,CAACf,KAAD,EAAQ,GAAGE,KAAK,CAACa,SAAjB,CAAlB;;AAEA,WAAK,MAAMC,KAAX,IAAoBlB,MAAM,CAACU,OAAP,CAAelB,IAAnC,EAAyC;AACrC,cAAM2B,GAAG,GAAGD,KAAK,CAACC,GAAlB;AACA,cAAMC,IAAI,GAAGlB,KAAK,CAACiB,GAAD,CAAlB;AAEAL,QAAAA,WAAW,CAACO,MAAZ,CAAmBF,GAAnB;AAEA,cAAMG,UAAU,GAAGlB,KAAK,CAACmB,QAAN,CAAe,CAAC,GAAGnB,KAAK,CAACoB,IAAV,EAAgBL,GAAhB,CAAf,EAAqCF,SAArC,EAAgDC,KAAhD,CAAnB;AACA,cAAMO,MAAM,GAAGP,KAAK,CAAClB,MAAN,CAAa0B,UAAb,CAAwBN,IAAxB,EAA8BE,UAA9B,EAA0CjB,KAA1C,CAAf;;AAEA,YAAIoB,MAAM,CAAChB,MAAX,EAAmB;AACf,cAAIJ,KAAK,CAACsB,UAAV,EAAsB;AAClB,mBAAO;AAAEzB,cAAAA,KAAF;AAASO,cAAAA,MAAM,EAAEgB,MAAM,CAAChB;AAAxB,aAAP;AACH;;AAED,cAAIgB,MAAM,CAACvB,KAAP,KAAiB0B,SAArB,EAAgC;AAC5B1B,YAAAA,KAAK,CAACiB,GAAD,CAAL,GAAaM,MAAM,CAACvB,KAApB;AACH;;AAEDO,UAAAA,MAAM,CAACoB,IAAP,CAAY,GAAGJ,MAAM,CAAChB,MAAtB;AACH,SAVD,MAWK,IAAIS,KAAK,CAAClB,MAAN,CAAa8B,MAAb,CAAoBL,MAApB,KAA+B,OAA/B,IACLA,MAAM,CAACvB,KAAP,KAAiB0B,SAAjB,IAA8BR,IAAI,KAAKQ,SADtC,EACiD;AAElD,iBAAO1B,KAAK,CAACiB,GAAD,CAAZ;AACH,SAJI,MAKA,IAAIM,MAAM,CAACvB,KAAP,KAAiB0B,SAArB,EAAgC;AACjC1B,UAAAA,KAAK,CAACiB,GAAD,CAAL,GAAaM,MAAM,CAACvB,KAApB;AACH;AACJ;AACJ,KA9E4C,CAgF7C;;;AAEA,QAAIY,WAAW,CAACiB,IAAZ,IACA/B,MAAM,CAAC8B,MAAP,CAAcE,gBADlB,EACoC;AAEhC,YAAMC,KAAK,GAAG1D,SAAS,CAACY,OAAV,CAAkBa,MAAlB,EAA0BE,KAA1B,EAAiCY,WAAjC,EAA8CL,MAA9C,EAAsDL,KAAtD,EAA6DC,KAA7D,CAAd;;AACA,UAAI4B,KAAJ,EAAW;AACP,eAAOA,KAAP;AACH;AACJ,KAzF4C,CA2F7C;;;AAEA,QAAIjC,MAAM,CAACU,OAAP,CAAepB,YAAnB,EAAiC;AAC7B,WAAK,MAAM4C,GAAX,IAAkBlC,MAAM,CAACU,OAAP,CAAepB,YAAjC,EAA+C;AAC3C,YAAI4C,GAAG,CAACf,GAAJ,IACAe,GAAG,CAACf,GAAJ,CAAQgB,OAAR,CAAgBjC,KAAhB,EAAuBE,KAAvB,EAA8BC,KAA9B,EAAqC,IAArC,EAA2C;AAAE+B,UAAAA,MAAM,EAAE;AAAV,SAA3C,MAAkER,SADtE,EACiF;AAE7E;AACH;;AAED,cAAMS,MAAM,GAAG9D,SAAS,CAACe,YAAV,CAAuB4C,GAAG,CAACI,GAA3B,EAAgCtC,MAAhC,EAAwCkC,GAAxC,EAA6ChC,KAA7C,EAAoDE,KAApD,EAA2DC,KAA3D,CAAf;;AACA,YAAIgC,MAAJ,EAAY;AACR,gBAAME,MAAM,GAAGvC,MAAM,CAACwC,aAAP,CAAqBH,MAAM,CAACI,IAA5B,EAAkCvC,KAAlC,EAAyCmC,MAAM,CAACK,OAAhD,EAAyDtC,KAAzD,EAAgEC,KAAhE,CAAf;;AACA,cAAIA,KAAK,CAACsB,UAAV,EAAsB;AAClB,mBAAO;AAAEzB,cAAAA,KAAF;AAASO,cAAAA,MAAM,EAAE8B;AAAjB,aAAP;AACH;;AAED9B,UAAAA,MAAM,CAACoB,IAAP,CAAYU,MAAZ;AACH;AACJ;AACJ;;AAED,WAAO;AAAErC,MAAAA,KAAF;AAASO,MAAAA;AAAT,KAAP;AACH,GA7IuB;;AA+IxBkC,EAAAA,KAAK,EAAE;AAEHC,IAAAA,GAAG,EAAE;AACDC,MAAAA,MAAM,CAAC,GAAGC;AAAM;AAAV,QAA4B;AAE9B5E,QAAAA,MAAM,CAAC6E,UAAP,CAAkBD,KAAlB,EAAyB,KAAzB;AAEA,eAAOvE,SAAS,CAACyE,UAAV,CAAqB,IAArB,EAA2B,KAA3B,EAAkC,IAAlC,EAAwCF,KAAxC,CAAP;AACH;;AANA,KAFF;AAWHG,IAAAA,MAAM,EAAE;AACJJ,MAAAA,MAAM,CAAC7C,MAAD,EAAS;AAEX,YAAIA,MAAM,KAAK,IAAX,IACAA,MAAM,KAAK4B,SADX,IAEAZ,MAAM,CAACxB,IAAP,CAAYQ,MAAZ,EAAoBkD,MAApB,KAA+B,CAFnC,EAEsC;AAElC,iBAAO,IAAP;AACH;;AAED,eAAO,KAAK1D,IAAL,CAAUQ,MAAV,CAAP;AACH;;AAXG,KAXL;AAyBHmD,IAAAA,MAAM,EAAE;AACJN,MAAAA,MAAM,CAACO,OAAD,EAAUpD,MAAV,EAAkBqD,OAAlB,EAA2B;AAE7B,YAAI,CAAC/E,QAAQ,CAACgF,UAAT,CAAoBF,OAApB,CAAL,EAAmC;AAC/BA,UAAAA,OAAO,GAAGjF,OAAO,CAACoF,GAAR,CAAYH,OAAZ,CAAV;AACH;;AAEDtF,QAAAA,MAAM,CAACuF,OAAO,KAAKzB,SAAZ,IAAyB,OAAOyB,OAAP,KAAmB,QAA7C,EAAuD,0BAAvD,CAAN;AAEArD,QAAAA,MAAM,GAAG,KAAKwD,SAAL,CAAexD,MAAf,EAAuB;AAAEyD,UAAAA,UAAU,EAAE;AAAd,SAAvB,CAAT;AAEA,cAAMC,GAAG,GAAG,KAAKC,SAAL,CAAe;AAAEC,UAAAA,IAAI,EAAE,QAAR;AAAkB7D,UAAAA,IAAI,EAAE;AAAEqD,YAAAA,OAAF;AAAWpD,YAAAA,MAAX;AAAmBqD,YAAAA;AAAnB;AAAxB,SAAf,CAAZ;AACAK,QAAAA,GAAG,CAACG,gBAAJ,CAAqBT,OAArB;AACAM,QAAAA,GAAG,CAACG,gBAAJ,CAAqB7D,MAArB;AACA,eAAO0D,GAAP;AACH,OAfG;;AAgBJzD,MAAAA,QAAQ,CAACC,KAAD,EAAQ;AAAEC,QAAAA,KAAF;AAASE,QAAAA,KAAT;AAAgBD,QAAAA;AAAhB,OAAR,EAAiC;AAAEgD,QAAAA,OAAF;AAAWpD,QAAAA,MAAX;AAAmBqD,QAAAA;AAAnB,OAAjC,EAA+D;AAEnE,cAAMS,KAAK,GAAGV,OAAO,CAACjB,OAAR,CAAgBjC,KAAhB,EAAuBE,KAAvB,EAA8BC,KAA9B,CAAd;AACA,cAAMmB,IAAI,GAAGnD,GAAG,CAAC0F,KAAJ,CAAUX,OAAV,IAAqBA,OAAO,CAACY,QAAR,CAAiB5D,KAAjB,CAArB,GAA+C,EAA5D;;AACA,YAAIJ,MAAM,CAACiE,OAAP,CAAeH,KAAf,EAAsB1D,KAAK,CAACmB,QAAN,CAAeC,IAAf,EAAqB,CAACtB,KAAD,EAAQ,GAAGE,KAAK,CAACa,SAAjB,CAArB,EAAkDjB,MAAlD,CAAtB,EAAiFK,KAAjF,CAAJ,EAA6F;AACzF,iBAAOH,KAAP;AACH;;AAED,eAAOC,KAAK,CAAC,eAAD,EAAkB;AAAEiD,UAAAA,OAAF;AAAWC,UAAAA;AAAX,SAAlB,CAAZ;AACH,OAzBG;;AA0BJtD,MAAAA,IAAI,EAAE,CAAC,SAAD,EAAY,QAAZ,EAAsB,SAAtB,CA1BF;AA2BJmE,MAAAA,KAAK,EAAE;AA3BH,KAzBL;AAuDHC,IAAAA,QAAQ,EAAE;AACNtB,MAAAA,MAAM,CAACuB,WAAD,EAAcR,IAAd,EAAoB;AAEtB9F,QAAAA,MAAM,CAAC,OAAOsG,WAAP,KAAuB,UAAxB,EAAoC,gCAApC,CAAN;AAEAR,QAAAA,IAAI,GAAGA,IAAI,IAAIQ,WAAW,CAACR,IAA3B;AAEA,eAAO,KAAKD,SAAL,CAAe;AAAEC,UAAAA,IAAI,EAAE,UAAR;AAAoB7D,UAAAA,IAAI,EAAE;AAAEqE,YAAAA,WAAF;AAAeR,YAAAA;AAAf;AAA1B,SAAf,CAAP;AACH,OARK;;AASN3D,MAAAA,QAAQ,CAACC,KAAD,EAAQmE,OAAR,EAAiB;AAAED,QAAAA,WAAF;AAAeR,QAAAA;AAAf,OAAjB,EAAwC;AAE5C,YAAI1D,KAAK,YAAYkE,WAArB,EAAkC;AAC9B,iBAAOlE,KAAP;AACH;;AAED,eAAOmE,OAAO,CAAClE,KAAR,CAAc,iBAAd,EAAiC;AAAEpB,UAAAA,IAAI,EAAE6E,IAAR;AAAc1D,UAAAA;AAAd,SAAjC,CAAP;AACH,OAhBK;;AAiBNH,MAAAA,IAAI,EAAE,CAAC,aAAD,EAAgB,MAAhB;AAjBA,KAvDP;AA2EHP,IAAAA,IAAI,EAAE;AACFqD,MAAAA,MAAM,CAAC7C,MAAD,EAAS;AAEXlC,QAAAA,MAAM,CAACkC,MAAM,KAAK4B,SAAX,IAAwB,OAAO5B,MAAP,KAAkB,QAA3C,EAAqD,sCAArD,CAAN;AACAlC,QAAAA,MAAM,CAAC,CAACI,MAAM,CAACoG,QAAP,CAAgBtE,MAAhB,CAAF,EAA2B,sCAA3B,CAAN;AAEA,cAAM0D,GAAG,GAAG,KAAK9C,KAAL,EAAZ;;AAEA,YAAI,CAACZ,MAAL,EAAa;AAAuC;AAChD0D,UAAAA,GAAG,CAAChD,OAAJ,CAAYlB,IAAZ,GAAmB,IAAnB;AACH,SAFD,MAGK,IAAI,CAACwB,MAAM,CAACxB,IAAP,CAAYQ,MAAZ,EAAoBkD,MAAzB,EAAiC;AAAc;AAChDQ,UAAAA,GAAG,CAAChD,OAAJ,CAAYlB,IAAZ,GAAmB,IAAIjB,SAAS,CAACgG,IAAd,EAAnB;AACH,SAFI,MAGA;AACDb,UAAAA,GAAG,CAAChD,OAAJ,CAAYlB,IAAZ,GAAmBkE,GAAG,CAAChD,OAAJ,CAAYlB,IAAZ,GAAmBkE,GAAG,CAAChD,OAAJ,CAAYlB,IAAZ,CAAiBgF,MAAjB,CAAyBtD,KAAD,IAAW,CAAClB,MAAM,CAACyE,cAAP,CAAsBvD,KAAK,CAACC,GAA5B,CAApC,CAAnB,GAA2F,IAAI5C,SAAS,CAACgG,IAAd,EAA9G;;AACA,eAAK,MAAMpD,GAAX,IAAkBnB,MAAlB,EAA0B;AACtB9B,YAAAA,MAAM,CAACwG,WAAP,CAAmB,MAAMhB,GAAG,CAAChD,OAAJ,CAAYlB,IAAZ,CAAiBqC,IAAjB,CAAsB;AAAEV,cAAAA,GAAF;AAAOnB,cAAAA,MAAM,EAAE,KAAKwD,SAAL,CAAexD,MAAM,CAACmB,GAAD,CAArB;AAAf,aAAtB,CAAzB,EAA8FA,GAA9F;AACH;AACJ;;AAED,eAAOuC,GAAG,CAACiB,eAAJ,EAAP;AACH;;AAtBC,KA3EH;AAoGHzB,IAAAA,MAAM,EAAE;AACJL,MAAAA,MAAM,CAAC+B,KAAD,EAAQ;AAEV,eAAO,KAAKjB,SAAL,CAAe;AAAEC,UAAAA,IAAI,EAAE,QAAR;AAAkB7D,UAAAA,IAAI,EAAE;AAAE6E,YAAAA;AAAF,WAAxB;AAAmCC,UAAAA,QAAQ,EAAE;AAA7C,SAAf,CAAP;AACH,OAJG;;AAKJ5E,MAAAA,QAAQ,CAACC,KAAD,EAAQmE,OAAR,EAAiB;AAAEO,QAAAA;AAAF,OAAjB,EAA4B;AAAEhB,QAAAA,IAAF;AAAQiB,QAAAA,QAAR;AAAkB9E,QAAAA;AAAlB,OAA5B,EAAsD;AAE1D,YAAI7B,MAAM,CAAC4G,OAAP,CAAe9D,MAAM,CAACxB,IAAP,CAAYU,KAAZ,EAAmBgD,MAAlC,EAA0C0B,KAA1C,EAAiDC,QAAjD,CAAJ,EAAgE;AAC5D,iBAAO3E,KAAP;AACH;;AAED,eAAOmE,OAAO,CAAClE,KAAR,CAAc,YAAYyD,IAA1B,EAAgC;AAAEgB,UAAAA,KAAK,EAAE7E,IAAI,CAAC6E,KAAd;AAAqB1E,UAAAA;AAArB,SAAhC,CAAP;AACH,OAZG;;AAaJH,MAAAA,IAAI,EAAE,CACF;AACI6D,QAAAA,IAAI,EAAE,OADV;AAEIL,QAAAA,GAAG,EAAE,IAFT;AAGIJ,QAAAA,MAAM,EAAEjF,MAAM,CAAC0G,KAHnB;AAIIvB,QAAAA,OAAO,EAAE;AAJb,OADE;AAbF,KApGL;AA2HH0B,IAAAA,GAAG,EAAE;AACDlC,MAAAA,MAAM,CAAC+B,KAAD,EAAQ;AAEV,eAAO,KAAKjB,SAAL,CAAe;AAAEC,UAAAA,IAAI,EAAE,KAAR;AAAef,UAAAA,MAAM,EAAE,QAAvB;AAAiC9C,UAAAA,IAAI,EAAE;AAAE6E,YAAAA;AAAF,WAAvC;AAAkDC,UAAAA,QAAQ,EAAE;AAA5D,SAAf,CAAP;AACH;;AAJA,KA3HF;AAkIHG,IAAAA,GAAG,EAAE;AACDnC,MAAAA,MAAM,CAAC+B,KAAD,EAAQ;AAEV,eAAO,KAAKjB,SAAL,CAAe;AAAEC,UAAAA,IAAI,EAAE,KAAR;AAAef,UAAAA,MAAM,EAAE,QAAvB;AAAiC9C,UAAAA,IAAI,EAAE;AAAE6E,YAAAA;AAAF,WAAvC;AAAkDC,UAAAA,QAAQ,EAAE;AAA5D,SAAf,CAAP;AACH;;AAJA,KAlIF;AAyIHI,IAAAA,IAAI,EAAE;AACFpC,MAAAA,MAAM,CAAC,GAAGC;AAAM;AAAV,QAA4B;AAE9B5E,QAAAA,MAAM,CAAC6E,UAAP,CAAkBD,KAAlB,EAAyB,MAAzB;AAEA,eAAOvE,SAAS,CAACyE,UAAV,CAAqB,IAArB,EAA2B,MAA3B,EAAmC,IAAnC,EAAyCF,KAAzC,CAAP;AACH;;AANC,KAzIH;AAkJHoC,IAAAA,EAAE,EAAE;AACArC,MAAAA,MAAM,CAAC,GAAGC;AAAM;AAAV,QAA4B;AAE9B5E,QAAAA,MAAM,CAAC6E,UAAP,CAAkBD,KAAlB,EAAyB,IAAzB;AAEA,eAAOvE,SAAS,CAACyE,UAAV,CAAqB,IAArB,EAA2B,IAA3B,EAAiC,IAAjC,EAAuCF,KAAvC,CAAP;AACH;;AAND,KAlJD;AA2JHqC,IAAAA,IAAI,EAAE;AACFtC,MAAAA,MAAM,CAAC,GAAGC;AAAM;AAAV,QAA4B;AAE9B,eAAOvE,SAAS,CAACyE,UAAV,CAAqB,IAArB,EAA2B,MAA3B,EAAmC,IAAnC,EAAyCF,KAAzC,CAAP;AACH;;AAJC,KA3JH;AAkKHsC,IAAAA,OAAO,EAAE;AACLvC,MAAAA,MAAM,CAACuC,OAAD,EAAUpF,MAAV,EAAkBqF,OAAO,GAAG,EAA5B,EAAgC;AAElC,cAAMC,QAAQ,GAAGF,OAAO,YAAYG,MAApC;;AACA,YAAI,CAACD,QAAL,EAAe;AACXF,UAAAA,OAAO,GAAG,KAAK5B,SAAL,CAAe4B,OAAf,EAAwB;AAAE3B,YAAAA,UAAU,EAAE;AAAd,WAAxB,CAAV;AACH;;AAED3F,QAAAA,MAAM,CAACkC,MAAM,KAAK4B,SAAZ,EAAuB,cAAvB,CAAN;AACA1D,QAAAA,MAAM,CAACsH,aAAP,CAAqBH,OAArB,EAA8B,CAAC,aAAD,EAAgB,SAAhB,CAA9B;;AAEA,YAAIC,QAAJ,EAAc;AACVxH,UAAAA,MAAM,CAAC,CAACsH,OAAO,CAAClG,KAAR,CAAcuG,QAAd,CAAuB,GAAvB,CAAD,IAAgC,CAACL,OAAO,CAAClG,KAAR,CAAcuG,QAAd,CAAuB,GAAvB,CAAlC,EAA+D,8CAA/D,CAAN;AACH;;AAEDzF,QAAAA,MAAM,GAAG,KAAKwD,SAAL,CAAexD,MAAf,EAAuB;AAAEyD,UAAAA,UAAU,EAAE;AAAd,SAAvB,CAAT;AAEA,cAAMC,GAAG,GAAG,KAAK9C,KAAL,EAAZ;AACA8C,QAAAA,GAAG,CAAChD,OAAJ,CAAYb,QAAZ,GAAuB6D,GAAG,CAAChD,OAAJ,CAAYb,QAAZ,IAAwB,EAA/C;AACA,cAAM6F,MAAM,GAAG;AAAE,WAACJ,QAAQ,GAAG,OAAH,GAAa,QAAtB,GAAiCF,OAAnC;AAA4CO,UAAAA,IAAI,EAAE3F;AAAlD,SAAf;;AACA,YAAIqF,OAAO,CAACO,OAAZ,EAAqB;AACjBF,UAAAA,MAAM,CAACE,OAAP,GAAiB,KAAKpC,SAAL,CAAe6B,OAAO,CAACO,OAAvB,CAAjB;;AACA,cAAIF,MAAM,CAACE,OAAP,CAAe7G,IAAf,KAAwB,OAA5B,EAAqC;AACjC2G,YAAAA,MAAM,CAACE,OAAP,GAAiBF,MAAM,CAACE,OAAP,CAAeC,MAAf,CAAsBC,KAAtB,GAA8BC,KAA9B,CAAoCL,MAAM,CAACE,OAA3C,CAAjB;AACH;;AAEDlC,UAAAA,GAAG,CAACG,gBAAJ,CAAqB6B,MAAM,CAACE,OAA5B;AACAlC,UAAAA,GAAG,CAACsC,SAAJ,CAAc,kBAAd,EAAkC,IAAlC,EAAwC;AAAEpF,YAAAA,KAAK,EAAE;AAAT,WAAxC;AACH;;AAED,YAAIyE,OAAO,CAACY,WAAZ,EAAyB;AACrBP,UAAAA,MAAM,CAACO,WAAP,GAAqB,IAArB;AACH;;AAEDvC,QAAAA,GAAG,CAAChD,OAAJ,CAAYb,QAAZ,CAAqBgC,IAArB,CAA0B6D,MAA1B;AACAhC,QAAAA,GAAG,CAACG,gBAAJ,CAAqB7D,MAArB;AACA,eAAO0D,GAAP;AACH;;AArCI,KAlKN;AA0MHH,IAAAA,GAAG,EAAE;AACDV,MAAAA,MAAM,GAAG;AAEL,eAAO,KAAKc,SAAL,CAAe,KAAf,CAAP;AACH,OAJA;;AAKD1D,MAAAA,QAAQ,CAACC,KAAD,EAAQmE,OAAR,EAAiB;AAErB,YAAIhG,GAAG,CAAC0F,KAAJ,CAAU7D,KAAV,CAAJ,EAAsB;AAClB,iBAAOA,KAAP;AACH;;AAED,eAAOmE,OAAO,CAAClE,KAAR,CAAc,gBAAd,EAAgC;AAAED,UAAAA;AAAF,SAAhC,CAAP;AACH;;AAZA,KA1MF;AAyNHgG,IAAAA,KAAK,EAAE;AACHrD,MAAAA,MAAM,GAAG;AAEL,eAAO,KAAKc,SAAL,CAAe,OAAf,CAAP;AACH,OAJE;;AAKH1D,MAAAA,QAAQ,CAACC,KAAD,EAAQmE,OAAR,EAAiB;AAErB,YAAInE,KAAK,YAAYqF,MAArB,EAA6B;AACzB,iBAAOrF,KAAP;AACH;;AAED,eAAOmE,OAAO,CAAClE,KAAR,CAAc,cAAd,EAA8B;AAAED,UAAAA;AAAF,SAA9B,CAAP;AACH;;AAZE,KAzNJ;AAwOHW,IAAAA,MAAM,EAAE;AACJgC,MAAAA,MAAM,CAAClD,IAAD,EAAOC,EAAP,EAAWyF,OAAO,GAAG,EAArB,EAAyB;AAE3BvH,QAAAA,MAAM,CAAC,OAAO6B,IAAP,KAAgB,QAAhB,IAA4BA,IAAI,YAAY4F,MAA7C,EAAqD,kCAArD,CAAN;AACAzH,QAAAA,MAAM,CAAC,OAAO8B,EAAP,KAAc,QAAd,IAA0BA,EAAE,YAAYtB,QAAzC,EAAmD,4BAAnD,CAAN;AACAR,QAAAA,MAAM,CAAC8B,EAAE,KAAKD,IAAR,EAAc,iCAAd,EAAiDA,IAAjD,CAAN;AAEAzB,QAAAA,MAAM,CAACsH,aAAP,CAAqBH,OAArB,EAA8B,CAAC,OAAD,EAAU,iBAAV,EAA6B,UAA7B,EAAyC,UAAzC,CAA9B;AAEA,cAAM3B,GAAG,GAAG,KAAK9C,KAAL,EAAZ;AAEA8C,QAAAA,GAAG,CAAChD,OAAJ,CAAYZ,OAAZ,GAAsB4D,GAAG,CAAChD,OAAJ,CAAYZ,OAAZ,IAAuB,EAA7C;;AACA,aAAK,MAAMe,MAAX,IAAqB6C,GAAG,CAAChD,OAAJ,CAAYZ,OAAjC,EAA0C;AACtChC,UAAAA,MAAM,CAAC+C,MAAM,CAAClB,IAAP,KAAgBA,IAAjB,EAAuB,2CAAvB,CAAN;AACH;;AAED,YAAIC,EAAE,YAAYtB,QAAlB,EAA4B;AACxBoF,UAAAA,GAAG,CAACG,gBAAJ,CAAqBjE,EAArB;AACH;;AAED8D,QAAAA,GAAG,CAAChD,OAAJ,CAAYZ,OAAZ,CAAoB+B,IAApB,CAAyB;AACrBlC,UAAAA,IADqB;AAErBC,UAAAA,EAFqB;AAGrByF,UAAAA,OAAO,EAAEzH,eAAe,CAACW,SAAS,CAACC,cAAX,EAA2B6G,OAA3B;AAHH,SAAzB;AAMA,eAAO3B,GAAP;AACH;;AA3BG,KAxOL;AAsQH1D,IAAAA,MAAM,EAAE;AACJ6C,MAAAA,MAAM,CAAC9D,IAAI,GAAG,KAAR,EAAe;AAEjB,eAAO,KAAK4E,SAAL,CAAe;AAAEC,UAAAA,IAAI,EAAE,QAAR;AAAkB7D,UAAAA,IAAI,EAAE;AAAEhB,YAAAA;AAAF;AAAxB,SAAf,CAAP;AACH,OAJG;;AAKJkB,MAAAA,QAAQ,CAACC,KAAD,EAAQmE,OAAR,EAAiB;AAAEtF,QAAAA;AAAF,OAAjB,EAA2B;AAE/B,YAAIb,MAAM,CAACoG,QAAP,CAAgBpE,KAAhB,MACCnB,IAAI,KAAK,KAAT,IAAkBmB,KAAK,CAACnB,IAAN,KAAeA,IADlC,CAAJ,EAC6C;AAEzC,iBAAOmB,KAAP;AACH;;AAED,eAAOmE,OAAO,CAAClE,KAAR,CAAc,eAAd,EAA+B;AAAEpB,UAAAA;AAAF,SAA/B,CAAP;AACH;;AAdG,KAtQL;AAuRHI,IAAAA,OAAO,EAAE;AACL0D,MAAAA,MAAM,CAACsD,KAAD,EAAQ;AAEV,eAAO,KAAKH,SAAL,CAAe,SAAf,EAA0BG,KAAK,KAAK,KAApC,CAAP;AACH;;AAJI,KAvRN;AA8RHC,IAAAA,IAAI,EAAE;AACFvD,MAAAA,MAAM,CAAC1B,GAAD,EAAM2B,KAAN,EAAauC,OAAO,GAAG,EAAvB,EAA2B;AAE7B,eAAO9G,SAAS,CAACyE,UAAV,CAAqB,IAArB,EAA2B,MAA3B,EAAmC7B,GAAnC,EAAwC2B,KAAxC,EAA+CuC,OAA/C,CAAP;AACH;;AAJC,KA9RH;AAqSHgB,IAAAA,OAAO,EAAE;AACLxD,MAAAA,MAAM,CAAC1B,GAAD,EAAM2B,KAAN,EAAauC,OAAO,GAAG,EAAvB,EAA2B;AAE7B,eAAO9G,SAAS,CAACyE,UAAV,CAAqB,IAArB,EAA2B,SAA3B,EAAsC7B,GAAtC,EAA2C2B,KAA3C,EAAkDuC,OAAlD,CAAP;AACH;;AAJI,KArSN;AA4SHiB,IAAAA,GAAG,EAAE;AACDzD,MAAAA,MAAM,CAAC,GAAGC;AAAM;AAAV,QAA4B;AAE9B5E,QAAAA,MAAM,CAAC6E,UAAP,CAAkBD,KAAlB,EAAyB,KAAzB;AAEA,eAAOvE,SAAS,CAACyE,UAAV,CAAqB,IAArB,EAA2B,KAA3B,EAAkC,IAAlC,EAAwCF,KAAxC,CAAP;AACH;;AANA;AA5SF,GA/IiB;AAqcxByD,EAAAA,SAAS,EAAE;AAEPnH,IAAAA,OAAO,CAACc,KAAD,EAAQmF,OAAR,EAAiB;AAEpB,UAAInF,KAAK,KAAK0B,SAAd,EAAyB;AACrB1B,QAAAA,KAAK,GAAGhC,MAAM,CAACsI,OAAP,CAAeC,WAAvB;AACH;;AAED,aAAO,KAAKC,QAAL,CAAc,SAAd,EAAyBxG,KAAzB,EAAgCmF,OAAhC,CAAP;AACH;;AATM,GArca;;AAidxBsB,EAAAA,OAAO,CAAC3G,MAAD,EAAS;AAEZ,QAAIA,MAAM,CAACU,OAAP,CAAelB,IAAnB,EAAyB;AACrB,YAAMoH,IAAI,GAAG,IAAI5I,IAAI,CAAC6I,MAAT,EAAb;;AACA,WAAK,MAAM3F,KAAX,IAAoBlB,MAAM,CAACU,OAAP,CAAelB,IAAnC,EAAyC;AACrCtB,QAAAA,MAAM,CAACwG,WAAP,CAAmB,MAAMkC,IAAI,CAACE,GAAL,CAAS5F,KAAT,EAAgB;AAAE6F,UAAAA,KAAK,EAAE7F,KAAK,CAAClB,MAAN,CAAagH,gBAAb,EAAT;AAA0CC,UAAAA,KAAK,EAAE/F,KAAK,CAACC;AAAvD,SAAhB,CAAzB,EAAwGD,KAAK,CAACC,GAA9G;AACH;;AAEDnB,MAAAA,MAAM,CAACU,OAAP,CAAelB,IAAf,GAAsB,IAAIjB,SAAS,CAACgG,IAAd,CAAmB,GAAGqC,IAAI,CAACM,KAA3B,CAAtB;AACH;AACJ,GA3duB;;AA6dxBzH,EAAAA,QAAQ,EAAE;AAEN0H,IAAAA,KAAK,CAACzD,GAAD,EAAM0D,IAAN,EAAY;AAEb,UAAIA,IAAI,CAAC5H,IAAT,EAAe;AACXkE,QAAAA,GAAG,GAAGA,GAAG,CAAClE,IAAJ,CAAS4H,IAAI,CAAC5H,IAAd,CAAN;AACH;;AAED,UAAI4H,IAAI,CAAC9H,YAAT,EAAuB;AACnB,aAAK,MAAM;AAAEgD,UAAAA,GAAF;AAAOnB,UAAAA,GAAG,GAAG,IAAb;AAAmB2B,UAAAA,KAAnB;AAA0BuC,UAAAA;AAA1B,SAAX,IAAkD+B,IAAI,CAAC9H,YAAvD,EAAqE;AACjEoE,UAAAA,GAAG,GAAGnF,SAAS,CAACyE,UAAV,CAAqBU,GAArB,EAA0BpB,GAA1B,EAA+BnB,GAA/B,EAAoC2B,KAApC,EAA2CuC,OAA3C,CAAN;AACH;AACJ;;AAED,UAAI+B,IAAI,CAACvH,QAAT,EAAmB;AACf,aAAK,MAAM;AAAEqG,UAAAA,KAAF;AAASlG,UAAAA,MAAT;AAAiB2F,UAAAA,IAAjB;AAAuBM,UAAAA,WAAvB;AAAoCL,UAAAA;AAApC,SAAX,IAA4DwB,IAAI,CAACvH,QAAjE,EAA2E;AACvE6D,UAAAA,GAAG,GAAGA,GAAG,CAAC0B,OAAJ,CAAYc,KAAK,IAAIlG,MAArB,EAA6B2F,IAA7B,EAAmC;AAAEM,YAAAA,WAAF;AAAeL,YAAAA;AAAf,WAAnC,CAAN;AACH;AACJ;;AAED,UAAIwB,IAAI,CAACtH,OAAT,EAAkB;AACd,aAAK,MAAM;AAAEH,UAAAA,IAAF;AAAQC,UAAAA,EAAR;AAAYyF,UAAAA;AAAZ,SAAX,IAAoC+B,IAAI,CAACtH,OAAzC,EAAkD;AAC9C4D,UAAAA,GAAG,GAAGA,GAAG,CAAC7C,MAAJ,CAAWlB,IAAX,EAAiBC,EAAjB,EAAqByF,OAArB,CAAN;AACH;AACJ;;AAED,aAAO3B,GAAP;AACH;;AA3BK,GA7dc;AA2fxB2D,EAAAA,QAAQ,EAAE;AACN,kBAAc,8FADR;AAEN,qBAAiB,qKAFX;AAGN,mBAAe,sCAHT;AAIN,uBAAmB,8CAJb;AAKN,qBAAiB,+DALX;AAMN,kBAAc,qFANR;AAON,kBAAc,wEAPR;AAQN,sBAAkB,8DARZ;AASN,mBAAe,6EATT;AAUN,mBAAe,sFAVT;AAWN,4BAAwB,sDAXlB;AAYN,sBAAkB,oCAZZ;AAaN,oBAAgB,oCAbV;AAcN,8BAA0B,2HAdpB;AAeN,8BAA0B,6FAfpB;AAgBN,qBAAiB,mDAhBX;AAiBN,sBAAkB,2BAjBZ;AAkBN,mBAAe,+DAlBT;AAmBN,sBAAkB,sEAnBZ;AAoBN,kBAAc;AApBR;AA3fc,CAAX,CAAjB,C,CAohBA;;AAEA9I,SAAS,CAACqC,KAAV,GAAkB,UAAUV,KAAV,EAAiBG,KAAjB,EAAwB;AAEtC;AAEA,MAAI,OAAOH,KAAP,KAAiB,QAArB,EAA+B;AAC3B,QAAIG,KAAK,CAACiH,cAAV,EAA0B;AACtB,aAAOvJ,KAAK,CAACmC,KAAD,EAAQ;AAAEqH,QAAAA,OAAO,EAAE;AAAX,OAAR,CAAZ;AACH;;AAED,UAAM3G,KAAK,GAAGI,MAAM,CAACwG,MAAP,CAAcxG,MAAM,CAACyG,cAAP,CAAsBvH,KAAtB,CAAd,CAAd;AACAc,IAAAA,MAAM,CAAC0G,MAAP,CAAc9G,KAAd,EAAqBV,KAArB;AACA,WAAOU,KAAP;AACH,GAZqC,CActC;;;AAEA,QAAMA,KAAK,GAAG,UAAU,GAAGb,IAAb,EAAmB;AAE7B,WAAOG,KAAK,CAACyH,KAAN,CAAY,IAAZ,EAAkB5H,IAAlB,CAAP;AACH,GAHD;;AAKAa,EAAAA,KAAK,CAACgH,SAAN,GAAkB7J,KAAK,CAACmC,KAAK,CAAC0H,SAAP,CAAvB;AACA5G,EAAAA,MAAM,CAAC6G,cAAP,CAAsBjH,KAAtB,EAA6B,MAA7B,EAAqC;AAAEV,IAAAA,KAAK,EAAEA,KAAK,CAAC0D,IAAf;AAAqBkE,IAAAA,QAAQ,EAAE;AAA/B,GAArC;AACA9G,EAAAA,MAAM,CAAC6G,cAAP,CAAsBjH,KAAtB,EAA6B,QAA7B,EAAuC;AAAEV,IAAAA,KAAK,EAAEA,KAAK,CAACgD,MAAf;AAAuB4E,IAAAA,QAAQ,EAAE;AAAjC,GAAvC;AACA9G,EAAAA,MAAM,CAAC0G,MAAP,CAAc9G,KAAd,EAAqBV,KAArB;AACA,SAAOU,KAAP;AACH,CA1BD;;AA6BArC,SAAS,CAACyE,UAAV,GAAuB,UAAUhD,MAAV,EAAkBsC,GAAlB,EAAuBnB,GAAvB,EAA4B2B,KAA5B,EAAmCuC,OAAnC,EAA4C;AAE/DvH,EAAAA,MAAM,CAACqD,GAAG,KAAK,IAAR,IAAgB,OAAOA,GAAP,KAAe,QAAhC,EAA0CmB,GAA1C,EAA+C,uBAA/C,CAAN,CAF+D,CAI/D;;AAEA,MAAI,CAAC+C,OAAL,EAAc;AACVA,IAAAA,OAAO,GAAGvC,KAAK,CAACI,MAAN,GAAe,CAAf,IAAoB,OAAOJ,KAAK,CAACA,KAAK,CAACI,MAAN,GAAe,CAAhB,CAAZ,KAAmC,QAAvD,GAAkEJ,KAAK,CAACiF,GAAN,EAAlE,GAAgF,EAA1F;AACH;;AAED7J,EAAAA,MAAM,CAACsH,aAAP,CAAqBH,OAArB,EAA8B,CAAC,WAAD,CAA9B;AAEAvC,EAAAA,KAAK,GAAG,GAAGkF,MAAH,CAAUlF,KAAV,CAAR,CAZ+D,CAc/D;;AAEA,QAAMmF,SAAS,GAAG/J,MAAM,CAACkB,OAAP,CAAeiG,OAAO,CAAC4C,SAAvB,EAAkC,GAAlC,CAAlB;AACA,QAAMC,KAAK,GAAG,EAAd;;AACA,OAAK,MAAMC,IAAX,IAAmBrF,KAAnB,EAA0B;AACtBhF,IAAAA,MAAM,CAAC,OAAOqK,IAAP,KAAgB,QAAjB,EAA2B7F,GAA3B,EAAgC,uBAAhC,CAAN;AACA4F,IAAAA,KAAK,CAACrG,IAAN,CAAW1D,OAAO,CAACoF,GAAR,CAAY4E,IAAZ,EAAkB;AAAEF,MAAAA,SAAF;AAAaG,MAAAA,QAAQ,EAAE,CAAvB;AAA0BC,MAAAA,MAAM,EAAE;AAAlC,KAAlB,CAAX;AACH,GArB8D,CAuB/D;;;AAEA,MAAIlH,GAAG,KAAK,IAAZ,EAAkB;AACdA,IAAAA,GAAG,GAAGhD,OAAO,CAACoF,GAAR,CAAYpC,GAAZ,EAAiB;AAAE8G,MAAAA,SAAF;AAAaG,MAAAA,QAAQ,EAAE,CAAvB;AAA0BC,MAAAA,MAAM,EAAE;AAAlC,KAAjB,CAAN;AACH,GA3B8D,CA6B/D;;;AAEA,QAAM3E,GAAG,GAAG1D,MAAM,CAACY,KAAP,EAAZ;AACA8C,EAAAA,GAAG,CAAChD,OAAJ,CAAYpB,YAAZ,GAA2BoE,GAAG,CAAChD,OAAJ,CAAYpB,YAAZ,IAA4B,EAAvD;AACAoE,EAAAA,GAAG,CAAChD,OAAJ,CAAYpB,YAAZ,CAAyBuC,IAAzB,CAA8B,IAAItD,SAAS,CAAC+J,UAAd,CAAyBhG,GAAzB,EAA8BnB,GAA9B,EAAmC+G,KAAnC,EAA0CpF,KAA1C,CAA9B;AACA,SAAOY,GAAP;AACH,CAnCD;;AAsCAnF,SAAS,CAACe,YAAV,GAAyB;AAErBsD,EAAAA,GAAG,CAAC5C,MAAD,EAASkC,GAAT,EAAchC,KAAd,EAAqBE,KAArB,EAA4BC,KAA5B,EAAmC;AAElC,UAAMkI,OAAO,GAAG,EAAhB;AACA,UAAMC,OAAO,GAAG,EAAhB;AACA,UAAMC,KAAK,GAAGvG,GAAG,CAACY,KAAJ,CAAUI,MAAxB;;AACA,SAAK,MAAMiF,IAAX,IAAmBjG,GAAG,CAACY,KAAvB,EAA8B;AAC1B,UAAIqF,IAAI,CAAChG,OAAL,CAAajC,KAAb,EAAoBE,KAApB,EAA2BC,KAA3B,EAAkC,IAAlC,EAAwC;AAAE+B,QAAAA,MAAM,EAAE;AAAV,OAAxC,MAA+DR,SAAnE,EAA8E;AAC1E2G,QAAAA,OAAO,CAAC1G,IAAR,CAAasG,IAAI,CAAChH,GAAlB;AACH,OAFD,MAGK;AACDqH,QAAAA,OAAO,CAAC3G,IAAR,CAAasG,IAAI,CAAChH,GAAlB;AACH;AACJ;;AAED,QAAIoH,OAAO,CAACrF,MAAR,KAAmBuF,KAAnB,IACAD,OAAO,CAACtF,MAAR,KAAmBuF,KADvB,EAC8B;AAE1B,aAAO;AACHhG,QAAAA,IAAI,EAAE,YADH;AAEHC,QAAAA,OAAO,EAAE;AACL8F,UAAAA,OADK;AAELE,UAAAA,iBAAiB,EAAEnK,SAAS,CAACoK,YAAV,CAAuB3I,MAAvB,EAA+BwI,OAA/B,CAFd;AAGLD,UAAAA,OAHK;AAILK,UAAAA,iBAAiB,EAAErK,SAAS,CAACoK,YAAV,CAAuB3I,MAAvB,EAA+BuI,OAA/B;AAJd;AAFN,OAAP;AASH;AACJ,GA7BoB;;AA+BrBtD,EAAAA,IAAI,CAACjF,MAAD,EAASkC,GAAT,EAAchC,KAAd,EAAqBE,KAArB,EAA4BC,KAA5B,EAAmC;AAEnC,UAAMmI,OAAO,GAAG,EAAhB;;AACA,SAAK,MAAML,IAAX,IAAmBjG,GAAG,CAACY,KAAvB,EAA8B;AAC1B,UAAIqF,IAAI,CAAChG,OAAL,CAAajC,KAAb,EAAoBE,KAApB,EAA2BC,KAA3B,EAAkC,IAAlC,EAAwC;AAAE+B,QAAAA,MAAM,EAAE;AAAV,OAAxC,MAA+DR,SAAnE,EAA8E;AAC1E4G,QAAAA,OAAO,CAAC3G,IAAR,CAAasG,IAAI,CAAChH,GAAlB;AACH;AACJ;;AAED,QAAIqH,OAAO,CAACtF,MAAR,KAAmBhB,GAAG,CAACY,KAAJ,CAAUI,MAAjC,EAAyC;AACrC;AACH;;AAED,UAAM2F,IAAI,GAAG3G,GAAG,CAACgG,KAAJ,CAAU,CAAV,CAAb;AACA,UAAMY,MAAM,GAAG5G,GAAG,CAACgG,KAAJ,CAAUa,KAAV,CAAgB,CAAhB,CAAf;AACA,WAAO;AACHtG,MAAAA,IAAI,EAAE,aADH;AAEHC,MAAAA,OAAO,EAAE;AACLmG,QAAAA,IADK;AAELG,QAAAA,aAAa,EAAEzK,SAAS,CAACoK,YAAV,CAAuB3I,MAAvB,EAA+B6I,IAA/B,CAFV;AAGL/F,QAAAA,KAAK,EAAEgG,MAHF;AAILG,QAAAA,eAAe,EAAE1K,SAAS,CAACoK,YAAV,CAAuB3I,MAAvB,EAA+B8I,MAA/B;AAJZ;AAFN,KAAP;AASH,GAvDoB;;AAyDrB5D,EAAAA,EAAE,CAAClF,MAAD,EAASkC,GAAT,EAAchC,KAAd,EAAqBE,KAArB,EAA4BC,KAA5B,EAAmC;AAEjC,SAAK,MAAM8H,IAAX,IAAmBjG,GAAG,CAACY,KAAvB,EAA8B;AAC1B,UAAIqF,IAAI,CAAChG,OAAL,CAAajC,KAAb,EAAoBE,KAApB,EAA2BC,KAA3B,EAAkC,IAAlC,EAAwC;AAAE+B,QAAAA,MAAM,EAAE;AAAV,OAAxC,MAA+DR,SAAnE,EAA8E;AAC1E;AACH;AACJ;;AAED,WAAO;AACHa,MAAAA,IAAI,EAAE,gBADH;AAEHC,MAAAA,OAAO,EAAE;AACLI,QAAAA,KAAK,EAAEZ,GAAG,CAACgG,KADN;AAELe,QAAAA,eAAe,EAAE1K,SAAS,CAACoK,YAAV,CAAuB3I,MAAvB,EAA+BkC,GAAG,CAACgG,KAAnC;AAFZ;AAFN,KAAP;AAOH,GAxEoB;;AA0ErB/C,EAAAA,IAAI,CAACnF,MAAD,EAASkC,GAAT,EAAchC,KAAd,EAAqBE,KAArB,EAA4BC,KAA5B,EAAmC;AAEnC,UAAMmI,OAAO,GAAG,EAAhB;;AACA,SAAK,MAAML,IAAX,IAAmBjG,GAAG,CAACY,KAAvB,EAA8B;AAC1B,UAAIqF,IAAI,CAAChG,OAAL,CAAajC,KAAb,EAAoBE,KAApB,EAA2BC,KAA3B,EAAkC,IAAlC,EAAwC;AAAE+B,QAAAA,MAAM,EAAE;AAAV,OAAxC,MAA+DR,SAAnE,EAA8E;AAC1E4G,QAAAA,OAAO,CAAC3G,IAAR,CAAasG,IAAI,CAAChH,GAAlB;AACH;AACJ;;AAED,QAAI,CAACqH,OAAO,CAACtF,MAAT,IACAsF,OAAO,CAACtF,MAAR,KAAmB,CADvB,EAC0B;AAEtB;AACH;;AAED,UAAMR,OAAO,GAAG;AAAEI,MAAAA,KAAK,EAAEZ,GAAG,CAACgG,KAAb;AAAoBe,MAAAA,eAAe,EAAE1K,SAAS,CAACoK,YAAV,CAAuB3I,MAAvB,EAA+BkC,GAAG,CAACgG,KAAnC;AAArC,KAAhB;AACAxF,IAAAA,OAAO,CAAC8F,OAAR,GAAkBA,OAAlB;AACA9F,IAAAA,OAAO,CAACgG,iBAAR,GAA4BnK,SAAS,CAACoK,YAAV,CAAuB3I,MAAvB,EAA+BwI,OAA/B,CAA5B;AACA,WAAO;AAAE/F,MAAAA,IAAI,EAAE,aAAR;AAAuBC,MAAAA;AAAvB,KAAP;AACH,GA7FoB;;AA+FrB0D,EAAAA,IAAI,CAACpG,MAAD,EAASkC,GAAT,EAAchC,KAAd,EAAqBE,KAArB,EAA4BC,KAA5B,EAAmC;AAEnC,SAAK,MAAM8H,IAAX,IAAmBjG,GAAG,CAACY,KAAvB,EAA8B;AAC1B,UAAIqF,IAAI,CAAChG,OAAL,CAAajC,KAAb,EAAoBE,KAApB,EAA2BC,KAA3B,EAAkC,IAAlC,EAAwC;AAAE+B,QAAAA,MAAM,EAAE;AAAV,OAAxC,MAA+DR,SAAnE,EAA8E;AAC1E,eAAO;AACHa,UAAAA,IAAI,EAAE,aADH;AAEHC,UAAAA,OAAO,EAAE;AACLmG,YAAAA,IAAI,EAAE3G,GAAG,CAACf,GAAJ,CAAQA,GADT;AAEL6H,YAAAA,aAAa,EAAEzK,SAAS,CAACoK,YAAV,CAAuB3I,MAAvB,EAA+BkC,GAAG,CAACf,GAAJ,CAAQA,GAAvC,CAFV;AAGLgH,YAAAA,IAAI,EAAEA,IAAI,CAAChH,GAHN;AAIL+H,YAAAA,aAAa,EAAE3K,SAAS,CAACoK,YAAV,CAAuB3I,MAAvB,EAA+BmI,IAAI,CAAChH,GAApC;AAJV;AAFN,SAAP;AASH;AACJ;AACJ,GA9GoB;;AAgHrBkF,EAAAA,OAAO,CAACrG,MAAD,EAASkC,GAAT,EAAchC,KAAd,EAAqBE,KAArB,EAA4BC,KAA5B,EAAmC;AAEtC,SAAK,MAAM8H,IAAX,IAAmBjG,GAAG,CAACY,KAAvB,EAA8B;AAC1B,UAAIqF,IAAI,CAAChG,OAAL,CAAajC,KAAb,EAAoBE,KAApB,EAA2BC,KAA3B,EAAkC,IAAlC,EAAwC;AAAE+B,QAAAA,MAAM,EAAE;AAAV,OAAxC,MAA+DR,SAAnE,EAA8E;AAC1E,eAAO;AACHa,UAAAA,IAAI,EAAE,gBADH;AAEHC,UAAAA,OAAO,EAAE;AACLmG,YAAAA,IAAI,EAAE3G,GAAG,CAACf,GAAJ,CAAQA,GADT;AAEL6H,YAAAA,aAAa,EAAEzK,SAAS,CAACoK,YAAV,CAAuB3I,MAAvB,EAA+BkC,GAAG,CAACf,GAAJ,CAAQA,GAAvC,CAFV;AAGLgH,YAAAA,IAAI,EAAEA,IAAI,CAAChH,GAHN;AAIL+H,YAAAA,aAAa,EAAE3K,SAAS,CAACoK,YAAV,CAAuB3I,MAAvB,EAA+BmI,IAAI,CAAChH,GAApC;AAJV;AAFN,SAAP;AASH;AACJ;AACJ,GA/HoB;;AAiIrBmF,EAAAA,GAAG,CAACtG,MAAD,EAASkC,GAAT,EAAchC,KAAd,EAAqBE,KAArB,EAA4BC,KAA5B,EAAmC;AAElC,UAAMmI,OAAO,GAAG,EAAhB;;AACA,SAAK,MAAML,IAAX,IAAmBjG,GAAG,CAACY,KAAvB,EAA8B;AAC1B,UAAIqF,IAAI,CAAChG,OAAL,CAAajC,KAAb,EAAoBE,KAApB,EAA2BC,KAA3B,EAAkC,IAAlC,EAAwC;AAAE+B,QAAAA,MAAM,EAAE;AAAV,OAAxC,MAA+DR,SAAnE,EAA8E;AAC1E4G,QAAAA,OAAO,CAAC3G,IAAR,CAAasG,IAAI,CAAChH,GAAlB;AACH;AACJ;;AAED,QAAIqH,OAAO,CAACtF,MAAR,KAAmB,CAAvB,EAA0B;AACtB;AACH;;AAED,UAAMR,OAAO,GAAG;AAAEI,MAAAA,KAAK,EAAEZ,GAAG,CAACgG,KAAb;AAAoBe,MAAAA,eAAe,EAAE1K,SAAS,CAACoK,YAAV,CAAuB3I,MAAvB,EAA+BkC,GAAG,CAACgG,KAAnC;AAArC,KAAhB;;AACA,QAAIM,OAAO,CAACtF,MAAR,KAAmB,CAAvB,EAA0B;AACtB,aAAO;AAAET,QAAAA,IAAI,EAAE,gBAAR;AAA0BC,QAAAA;AAA1B,OAAP;AACH;;AAEDA,IAAAA,OAAO,CAAC8F,OAAR,GAAkBA,OAAlB;AACA9F,IAAAA,OAAO,CAACgG,iBAAR,GAA4BnK,SAAS,CAACoK,YAAV,CAAuB3I,MAAvB,EAA+BwI,OAA/B,CAA5B;AACA,WAAO;AAAE/F,MAAAA,IAAI,EAAE,YAAR;AAAsBC,MAAAA;AAAtB,KAAP;AACH;;AAtJoB,CAAzB;;AA0JAnE,SAAS,CAACoK,YAAV,GAAyB,UAAU3I,MAAV,EAAkBR,IAAlB,EAAwB;AAE7C,MAAIe,KAAK,CAACC,OAAN,CAAchB,IAAd,CAAJ,EAAyB;AACrB,WAAOA,IAAI,CAAC2J,GAAL,CAAUhI,GAAD,IAASnB,MAAM,CAACoJ,WAAP,CAAmBjI,GAAnB,CAAlB,CAAP;AACH;;AAED,SAAOnB,MAAM,CAACoJ,WAAP,CAAmB5J,IAAnB,CAAP;AACH,CAPD;;AAUAjB,SAAS,CAACsC,MAAV,GAAmB,UAAUb,MAAV,EAAkBE,KAAlB,EAAyBE,KAAzB,EAAgCC,KAAhC,EAAuCI,MAAvC,EAA+C;AAE9D,QAAM4I,OAAO,GAAG,EAAhB;;AACA,OAAK,MAAMxI,MAAX,IAAqBb,MAAM,CAACU,OAAP,CAAeZ,OAApC,EAA6C;AACzC,UAAM8F,OAAO,GAAG,EAAhB;AACA,UAAMR,OAAO,GAAG,OAAOvE,MAAM,CAAClB,IAAd,KAAuB,QAAvC;;AAEA,QAAI,CAACyF,OAAL,EAAc;AACV,UAAIpE,MAAM,CAAC4G,SAAP,CAAiBnD,cAAjB,CAAgC6E,IAAhC,CAAqCpJ,KAArC,EAA4CW,MAAM,CAAClB,IAAnD,MACCO,KAAK,CAACW,MAAM,CAAClB,IAAR,CAAL,KAAuBiC,SAAvB,IAAoC,CAACf,MAAM,CAACwE,OAAP,CAAekE,eADrD,CAAJ,EAC2E;AAEvE3D,QAAAA,OAAO,CAAC/D,IAAR,CAAahB,MAAb;AACH;AACJ,KAND,MAOK;AACD,WAAK,MAAMlB,IAAX,IAAmBO,KAAnB,EAA0B;AACtB,YAAIA,KAAK,CAACP,IAAD,CAAL,KAAgBiC,SAAhB,IACAf,MAAM,CAACwE,OAAP,CAAekE,eADnB,EACoC;AAEhC;AACH;;AAED,YAAI5J,IAAI,KAAKkB,MAAM,CAACjB,EAApB,EAAwB;AACpB;AACH;;AAED,cAAM4J,KAAK,GAAG3I,MAAM,CAAClB,IAAP,CAAY8J,IAAZ,CAAiB9J,IAAjB,CAAd;;AACA,YAAI,CAAC6J,KAAL,EAAY;AACR;AACH;;AAED5D,QAAAA,OAAO,CAAC/D,IAAR,CAAa;AAAElC,UAAAA,IAAF;AAAQC,UAAAA,EAAE,EAAEiB,MAAM,CAACjB,EAAnB;AAAuB4J,UAAAA;AAAvB,SAAb;AACH;AACJ;;AAED,SAAK,MAAMA,KAAX,IAAoB5D,OAApB,EAA6B;AACzB,YAAMjG,IAAI,GAAG6J,KAAK,CAAC7J,IAAnB;AACA,UAAIC,EAAE,GAAG4J,KAAK,CAAC5J,EAAf;;AACA,UAAIA,EAAE,YAAYtB,QAAlB,EAA4B;AACxBsB,QAAAA,EAAE,GAAGA,EAAE,CAAC8J,MAAH,CAAUxJ,KAAV,EAAiBE,KAAjB,EAAwBC,KAAxB,EAA+BmJ,KAAK,CAACA,KAArC,CAAL;AACH;;AAED,UAAI7J,IAAI,KAAKC,EAAb,EAAiB;AACb;AACH;;AAED,UAAI,CAACiB,MAAM,CAACwE,OAAP,CAAe3G,QAAhB,IACA2K,OAAO,CAACzJ,EAAD,CADX,EACiB;AAEba,QAAAA,MAAM,CAACoB,IAAP,CAAY7B,MAAM,CAACwC,aAAP,CAAqB,wBAArB,EAA+CtC,KAA/C,EAAsD;AAAEP,UAAAA,IAAF;AAAQC,UAAAA,EAAR;AAAYwF,UAAAA;AAAZ,SAAtD,EAA6EhF,KAA7E,EAAoFC,KAApF,CAAZ;;AACA,YAAIA,KAAK,CAACsB,UAAV,EAAsB;AAClB,iBAAO,KAAP;AACH;AACJ;;AAED,UAAIX,MAAM,CAAC4G,SAAP,CAAiBnD,cAAjB,CAAgC6E,IAAhC,CAAqCpJ,KAArC,EAA4CN,EAA5C,KACA,CAACiB,MAAM,CAACwE,OAAP,CAAe1G,QADhB,IAEA,CAAC0K,OAAO,CAACzJ,EAAD,CAFZ,EAEkB;AAEda,QAAAA,MAAM,CAACoB,IAAP,CAAY7B,MAAM,CAACwC,aAAP,CAAqB,wBAArB,EAA+CtC,KAA/C,EAAsD;AAAEP,UAAAA,IAAF;AAAQC,UAAAA,EAAR;AAAYwF,UAAAA;AAAZ,SAAtD,EAA6EhF,KAA7E,EAAoFC,KAApF,CAAZ;;AACA,YAAIA,KAAK,CAACsB,UAAV,EAAsB;AAClB,iBAAO,KAAP;AACH;AACJ;;AAED,UAAIzB,KAAK,CAACP,IAAD,CAAL,KAAgBiC,SAApB,EAA+B;AAC3B,eAAO1B,KAAK,CAACN,EAAD,CAAZ;AACH,OAFD,MAGK;AACDM,QAAAA,KAAK,CAACN,EAAD,CAAL,GAAYM,KAAK,CAACP,IAAD,CAAjB;AACH;;AAED0J,MAAAA,OAAO,CAACzJ,EAAD,CAAP,GAAc,IAAd;;AAEA,UAAI,CAACiB,MAAM,CAACwE,OAAP,CAAe5G,KAApB,EAA2B;AACvB,eAAOyB,KAAK,CAACP,IAAD,CAAZ;AACH;AACJ;AACJ;;AAED,SAAO,IAAP;AACH,CAjFD;;AAoFApB,SAAS,CAACY,OAAV,GAAoB,UAAUa,MAAV,EAAkBE,KAAlB,EAAyBY,WAAzB,EAAsCL,MAAtC,EAA8CL,KAA9C,EAAqDC,KAArD,EAA4D;AAE5E,MAAIL,MAAM,CAACU,OAAP,CAAeb,QAAnB,EAA6B;AACzB,QAAI8J,UAAU,GAAG,KAAjB;AACA,UAAM/D,OAAO,GAAG5F,MAAM,CAACU,OAAP,CAAeb,QAAf,CAAwBsJ,GAAxB,CAA6B/D,OAAD,IAAa;AAErD,UAAIA,OAAO,CAACQ,OAAZ,EAAqB;AACjB+D,QAAAA,UAAU,GAAG,IAAb;AACA,eAAO,EAAP;AACH;AACJ,KANe,CAAhB;AAQA,UAAM1I,SAAS,GAAG,CAACf,KAAD,EAAQ,GAAGE,KAAK,CAACa,SAAjB,CAAlB;;AAEA,SAAK,MAAME,GAAX,IAAkBL,WAAlB,EAA+B;AAC3B,YAAMM,IAAI,GAAGlB,KAAK,CAACiB,GAAD,CAAlB;AACA,YAAMK,IAAI,GAAG,CAAC,GAAGpB,KAAK,CAACoB,IAAV,EAAgBL,GAAhB,CAAb;;AAEA,WAAK,IAAIyI,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG5J,MAAM,CAACU,OAAP,CAAeb,QAAf,CAAwBqD,MAA5C,EAAoD,EAAE0G,CAAtD,EAAyD;AACrD,cAAMxE,OAAO,GAAGpF,MAAM,CAACU,OAAP,CAAeb,QAAf,CAAwB+J,CAAxB,CAAhB;;AACA,YAAIxE,OAAO,CAACc,KAAZ,EAAmB;AACf,gBAAMsD,KAAK,GAAGpE,OAAO,CAACc,KAAR,CAAc2D,IAAd,CAAmB1I,GAAnB,CAAd;AACAf,UAAAA,KAAK,CAAC0J,QAAN,CAAeC,MAAf,CAAsBC,KAAtB,CAA4B5J,KAA5B,EAAmC,MAAnC,EAA4C,WAAUwJ,CAAE,EAAxD,EAA2DJ,KAAK,GAAG,MAAH,GAAY,OAA5E;;AACA,cAAI,CAACA,KAAL,EAAY;AACR;AACH;AACJ,SAND,MAOK;AACD,cAAI,CAACpE,OAAO,CAACpF,MAAR,CAAeiE,OAAf,CAAuB9C,GAAvB,EAA4Bf,KAAK,CAAC6J,IAAN,CAAW7E,OAAO,CAACpF,MAAnB,EAA4B,WAAU4J,CAAE,EAAxC,CAA5B,EAAwEvJ,KAAxE,CAAL,EAAqF;AACjF;AACH;AACJ;;AAEDS,QAAAA,WAAW,CAACO,MAAZ,CAAmBF,GAAnB;AAEA,cAAMG,UAAU,GAAGlB,KAAK,CAACmB,QAAN,CAAeC,IAAf,EAAqBP,SAArB,EAAgC;AAAEjB,UAAAA,MAAM,EAAEoF,OAAO,CAACO,IAAlB;AAAwBxE,UAAAA;AAAxB,SAAhC,CAAnB;AACA,cAAMM,MAAM,GAAG2D,OAAO,CAACO,IAAR,CAAajE,UAAb,CAAwBN,IAAxB,EAA8BE,UAA9B,EAA0CjB,KAA1C,CAAf;;AACA,YAAIoB,MAAM,CAAChB,MAAX,EAAmB;AACf,cAAIJ,KAAK,CAACsB,UAAV,EAAsB;AAClB,mBAAO;AAAEzB,cAAAA,KAAF;AAASO,cAAAA,MAAM,EAAEgB,MAAM,CAAChB;AAAxB,aAAP;AACH;;AAEDA,UAAAA,MAAM,CAACoB,IAAP,CAAY,GAAGJ,MAAM,CAAChB,MAAtB;AACH;;AAED,YAAI2E,OAAO,CAACQ,OAAZ,EAAqB;AACjBA,UAAAA,OAAO,CAACgE,CAAD,CAAP,CAAW/H,IAAX,CAAgBV,GAAhB;AACH;;AAEDjB,QAAAA,KAAK,CAACiB,GAAD,CAAL,GAAaM,MAAM,CAACvB,KAApB;;AACA,YAAI,CAACkF,OAAO,CAACa,WAAb,EAA0B;AACtB;AACH;AACJ;AACJ,KApDwB,CAsDzB;;;AAEA,QAAI0D,UAAJ,EAAgB;AACZ,WAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGhE,OAAO,CAAC1C,MAA5B,EAAoC,EAAE0G,CAAtC,EAAyC;AACrC,cAAMJ,KAAK,GAAG5D,OAAO,CAACgE,CAAD,CAArB;;AACA,YAAI,CAACJ,KAAL,EAAY;AACR;AACH;;AAED,cAAMU,IAAI,GAAGlK,MAAM,CAACU,OAAP,CAAeb,QAAf,CAAwB+J,CAAxB,EAA2BhE,OAAxC;AACA,cAAMtE,UAAU,GAAGlB,KAAK,CAACmB,QAAN,CAAenB,KAAK,CAACoB,IAArB,EAA2BP,SAA3B,EAAsCiJ,IAAtC,CAAnB;AACA,cAAMzI,MAAM,GAAGyI,IAAI,CAACxI,UAAL,CAAgB8H,KAAhB,EAAuBlI,UAAvB,EAAmCjB,KAAnC,CAAf;;AACA,YAAIoB,MAAM,CAAChB,MAAX,EAAmB;AACf,gBAAM0J,OAAO,GAAG/L,MAAM,CAAC+L,OAAP,CAAe1I,MAAM,CAAChB,MAAtB,EAA8B;AAAE9B,YAAAA,QAAQ,EAAE;AAAZ,WAA9B,CAAhB;AACAwL,UAAAA,OAAO,CAACvE,OAAR,GAAkB4D,KAAlB;AACA,gBAAMjH,MAAM,GAAGvC,MAAM,CAACwC,aAAP,CAAqB,sBAArB,EAA6CtC,KAA7C,EAAoDiK,OAApD,EAA6D/J,KAA7D,EAAoEC,KAApE,CAAf;;AACA,cAAIA,KAAK,CAACsB,UAAV,EAAsB;AAClB,mBAAO;AAAEzB,cAAAA,KAAF;AAASO,cAAAA,MAAM,EAAE8B;AAAjB,aAAP;AACH;;AAED9B,UAAAA,MAAM,CAACoB,IAAP,CAAYU,MAAZ;AACH;AACJ;AACJ;AACJ;;AAED,MAAI,CAACzB,WAAW,CAACiB,IAAb,IACA,CAAC/B,MAAM,CAACU,OAAP,CAAelB,IAAhB,IAAwB,CAACQ,MAAM,CAACU,OAAP,CAAeb,QAD5C,EACsD;AAAM;AAExD;AACH;;AAED,MAAIQ,KAAK,CAAC+J,YAAN,IAAsB,CAACpK,MAAM,CAAC8B,MAAP,CAAc3C,OAArC,IACAkB,KAAK,CAACgK,aADV,EACyB;AAErB,UAAMD,YAAY,GAAG/J,KAAK,CAAC+J,YAAN,GAAsB/J,KAAK,CAAC+J,YAAN,KAAuB,IAAvB,GAA8B,IAA9B,GAAqC,CAAC,CAAC/J,KAAK,CAAC+J,YAAN,CAAmBE,OAAhF,GAA2F,KAAhH;;AAEA,SAAK,MAAMnJ,GAAX,IAAkBL,WAAlB,EAA+B;AAC3B,UAAIsJ,YAAJ,EAAkB;AACd,eAAOlK,KAAK,CAACiB,GAAD,CAAZ;AACAL,QAAAA,WAAW,CAACO,MAAZ,CAAmBF,GAAnB;AACH,OAHD,MAIK,IAAI,OAAOjB,KAAK,CAACiB,GAAD,CAAZ,KAAsB,UAA1B,EAAsC;AACvCL,QAAAA,WAAW,CAACO,MAAZ,CAAmBF,GAAnB;AACH;AACJ;AACJ;;AAED,QAAMoJ,aAAa,GAAG,CAACrM,MAAM,CAACkB,OAAP,CAAeY,MAAM,CAAC8B,MAAP,CAAc3C,OAA7B,EAAsCkB,KAAK,CAACmK,YAA5C,CAAvB;;AACA,MAAID,aAAJ,EAAmB;AACf,SAAK,MAAME,cAAX,IAA6B3J,WAA7B,EAA0C;AACtC,YAAMQ,UAAU,GAAGlB,KAAK,CAACmB,QAAN,CAAe,CAAC,GAAGnB,KAAK,CAACoB,IAAV,EAAgBiJ,cAAhB,CAAf,EAAgD,EAAhD,CAAnB;AACA,YAAMlI,MAAM,GAAGvC,MAAM,CAACwC,aAAP,CAAqB,gBAArB,EAAuCtC,KAAK,CAACuK,cAAD,CAA5C,EAA8D;AAAEvJ,QAAAA,KAAK,EAAEuJ;AAAT,OAA9D,EAAyFnJ,UAAzF,EAAqGjB,KAArG,EAA4G;AAAEnB,QAAAA,KAAK,EAAE;AAAT,OAA5G,CAAf;;AACA,UAAImB,KAAK,CAACsB,UAAV,EAAsB;AAClB,eAAO;AAAEzB,UAAAA,KAAF;AAASO,UAAAA,MAAM,EAAE8B;AAAjB,SAAP;AACH;;AAED9B,MAAAA,MAAM,CAACoB,IAAP,CAAYU,MAAZ;AACH;AACJ;AACJ,CApHD;;AAuHAhE,SAAS,CAAC+J,UAAV,GAAuB,MAAM;AAEzBlE,EAAAA,WAAW,CAAC9B,GAAD,EAAMnB,GAAN,EAAW2B,KAAX,EAAkBoF,KAAlB,EAAyB;AAEhC,SAAK5F,GAAL,GAAWA,GAAX;AACA,SAAKnB,GAAL,GAAWA,GAAX;AACA,SAAK2B,KAAL,GAAaA,KAAb;AACA,SAAKoF,KAAL,GAAaA,KAAb;AACH;;AAEDwC,EAAAA,QAAQ,GAAG;AAEP,UAAMtD,IAAI,GAAG;AACT9E,MAAAA,GAAG,EAAE,KAAKA,GADD;AAETQ,MAAAA,KAAK,EAAE,KAAKoF;AAFH,KAAb;;AAKA,QAAI,KAAK/G,GAAL,KAAa,IAAjB,EAAuB;AACnBiG,MAAAA,IAAI,CAACjG,GAAL,GAAW,KAAKA,GAAL,CAASA,GAApB;AACH;;AAED,QAAI,KAAK2B,KAAL,CAAW,CAAX,EAAcmF,SAAd,KAA4B,GAAhC,EAAqC;AACjCb,MAAAA,IAAI,CAAC/B,OAAL,GAAe;AAAE4C,QAAAA,SAAS,EAAE,KAAKnF,KAAL,CAAW,CAAX,EAAcmF;AAA3B,OAAf;AACH;;AAED,WAAOb,IAAP;AACH;;AA1BwB,CAA7B;AA8BA7I,SAAS,CAACgG,IAAV,GAAiB,cAAchE,KAAd,CAAoB;AAEjCyH,EAAAA,MAAM,CAAC2C,MAAD,EAAS;AAEX,UAAMlJ,MAAM,GAAG,KAAKsH,KAAL,EAAf;AAEA,UAAMvJ,IAAI,GAAG,IAAIoL,GAAJ,EAAb;;AACA,SAAK,IAAIhB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGnI,MAAM,CAACyB,MAA3B,EAAmC,EAAE0G,CAArC,EAAwC;AACpCpK,MAAAA,IAAI,CAACqL,GAAL,CAASpJ,MAAM,CAACmI,CAAD,CAAN,CAAUzI,GAAnB,EAAwByI,CAAxB;AACH;;AAED,SAAK,MAAMxI,IAAX,IAAmBuJ,MAAnB,EAA2B;AACvB,YAAMxJ,GAAG,GAAGC,IAAI,CAACD,GAAjB;AACA,YAAM2J,GAAG,GAAGtL,IAAI,CAACuL,GAAL,CAAS5J,GAAT,CAAZ;;AACA,UAAI2J,GAAG,KAAKlJ,SAAZ,EAAuB;AACnBH,QAAAA,MAAM,CAACqJ,GAAD,CAAN,GAAc;AAAE3J,UAAAA,GAAF;AAAOnB,UAAAA,MAAM,EAAEyB,MAAM,CAACqJ,GAAD,CAAN,CAAY9K,MAAZ,CAAmBgI,MAAnB,CAA0B5G,IAAI,CAACpB,MAA/B;AAAf,SAAd;AACH,OAFD,MAGK;AACDyB,QAAAA,MAAM,CAACI,IAAP,CAAYT,IAAZ;AACH;AACJ;;AAED,WAAOK,MAAP;AACH;;AAvBgC,CAArC","sourcesContent":["'use strict';\n\nconst ApplyToDefaults = require('@hapi/hoek/lib/applyToDefaults');\nconst Assert = require('@hapi/hoek/lib/assert');\nconst Clone = require('@hapi/hoek/lib/clone');\nconst Topo = require('@hapi/topo');\n\nconst Any = require('./any');\nconst Common = require('../common');\nconst Compile = require('../compile');\nconst Errors = require('../errors');\nconst Ref = require('../ref');\nconst Template = require('../template');\n\n\nconst internals = {\n    renameDefaults: {\n        alias: false,                   // Keep old value in place\n        multiple: false,                // Allow renaming multiple keys into the same target\n        override: false                 // Overrides an existing key\n    }\n};\n\n\nmodule.exports = Any.extend({\n\n    type: '_keys',\n\n    properties: {\n\n        typeof: 'object'\n    },\n\n    flags: {\n\n        unknown: { default: false }\n    },\n\n    terms: {\n\n        dependencies: { init: null },\n        keys: { init: null, manifest: { mapped: { from: 'schema', to: 'key' } } },\n        patterns: { init: null },\n        renames: { init: null }\n    },\n\n    args(schema, keys) {\n\n        return schema.keys(keys);\n    },\n\n    validate(value, { schema, error, state, prefs }) {\n\n        if (!value ||\n            typeof value !== schema.$_property('typeof') ||\n            Array.isArray(value)) {\n\n            return { value, errors: error('object.base', { type: schema.$_property('typeof') }) };\n        }\n\n        // Skip if there are no other rules to test\n\n        if (!schema.$_terms.renames &&\n            !schema.$_terms.dependencies &&\n            !schema.$_terms.keys &&                       // null allows any keys\n            !schema.$_terms.patterns &&\n            !schema.$_terms.externals) {\n\n            return;\n        }\n\n        // Shallow clone value\n\n        value = internals.clone(value, prefs);\n        const errors = [];\n\n        // Rename keys\n\n        if (schema.$_terms.renames &&\n            !internals.rename(schema, value, state, prefs, errors)) {\n\n            return { value, errors };\n        }\n\n        // Anything allowed\n\n        if (!schema.$_terms.keys &&                       // null allows any keys\n            !schema.$_terms.patterns &&\n            !schema.$_terms.dependencies) {\n\n            return { value, errors };\n        }\n\n        // Defined keys\n\n        const unprocessed = new Set(Object.keys(value));\n\n        if (schema.$_terms.keys) {\n            const ancestors = [value, ...state.ancestors];\n\n            for (const child of schema.$_terms.keys) {\n                const key = child.key;\n                const item = value[key];\n\n                unprocessed.delete(key);\n\n                const localState = state.localize([...state.path, key], ancestors, child);\n                const result = child.schema.$_validate(item, localState, prefs);\n\n                if (result.errors) {\n                    if (prefs.abortEarly) {\n                        return { value, errors: result.errors };\n                    }\n\n                    if (result.value !== undefined) {\n                        value[key] = result.value;\n                    }\n\n                    errors.push(...result.errors);\n                }\n                else if (child.schema._flags.result === 'strip' ||\n                    result.value === undefined && item !== undefined) {\n\n                    delete value[key];\n                }\n                else if (result.value !== undefined) {\n                    value[key] = result.value;\n                }\n            }\n        }\n\n        // Unknown keys\n\n        if (unprocessed.size ||\n            schema._flags._hasPatternMatch) {\n\n            const early = internals.unknown(schema, value, unprocessed, errors, state, prefs);\n            if (early) {\n                return early;\n            }\n        }\n\n        // Validate dependencies\n\n        if (schema.$_terms.dependencies) {\n            for (const dep of schema.$_terms.dependencies) {\n                if (dep.key &&\n                    dep.key.resolve(value, state, prefs, null, { shadow: false }) === undefined) {\n\n                    continue;\n                }\n\n                const failed = internals.dependencies[dep.rel](schema, dep, value, state, prefs);\n                if (failed) {\n                    const report = schema.$_createError(failed.code, value, failed.context, state, prefs);\n                    if (prefs.abortEarly) {\n                        return { value, errors: report };\n                    }\n\n                    errors.push(report);\n                }\n            }\n        }\n\n        return { value, errors };\n    },\n\n    rules: {\n\n        and: {\n            method(...peers /*, [options] */) {\n\n                Common.verifyFlat(peers, 'and');\n\n                return internals.dependency(this, 'and', null, peers);\n            }\n        },\n\n        append: {\n            method(schema) {\n\n                if (schema === null ||\n                    schema === undefined ||\n                    Object.keys(schema).length === 0) {\n\n                    return this;\n                }\n\n                return this.keys(schema);\n            }\n        },\n\n        assert: {\n            method(subject, schema, message) {\n\n                if (!Template.isTemplate(subject)) {\n                    subject = Compile.ref(subject);\n                }\n\n                Assert(message === undefined || typeof message === 'string', 'Message must be a string');\n\n                schema = this.$_compile(schema, { appendPath: true });\n\n                const obj = this.$_addRule({ name: 'assert', args: { subject, schema, message } });\n                obj.$_mutateRegister(subject);\n                obj.$_mutateRegister(schema);\n                return obj;\n            },\n            validate(value, { error, prefs, state }, { subject, schema, message }) {\n\n                const about = subject.resolve(value, state, prefs);\n                const path = Ref.isRef(subject) ? subject.absolute(state) : [];\n                if (schema.$_match(about, state.localize(path, [value, ...state.ancestors], schema), prefs)) {\n                    return value;\n                }\n\n                return error('object.assert', { subject, message });\n            },\n            args: ['subject', 'schema', 'message'],\n            multi: true\n        },\n\n        instance: {\n            method(constructor, name) {\n\n                Assert(typeof constructor === 'function', 'constructor must be a function');\n\n                name = name || constructor.name;\n\n                return this.$_addRule({ name: 'instance', args: { constructor, name } });\n            },\n            validate(value, helpers, { constructor, name }) {\n\n                if (value instanceof constructor) {\n                    return value;\n                }\n\n                return helpers.error('object.instance', { type: name, value });\n            },\n            args: ['constructor', 'name']\n        },\n\n        keys: {\n            method(schema) {\n\n                Assert(schema === undefined || typeof schema === 'object', 'Object schema must be a valid object');\n                Assert(!Common.isSchema(schema), 'Object schema cannot be a joi schema');\n\n                const obj = this.clone();\n\n                if (!schema) {                                      // Allow all\n                    obj.$_terms.keys = null;\n                }\n                else if (!Object.keys(schema).length) {             // Allow none\n                    obj.$_terms.keys = new internals.Keys();\n                }\n                else {\n                    obj.$_terms.keys = obj.$_terms.keys ? obj.$_terms.keys.filter((child) => !schema.hasOwnProperty(child.key)) : new internals.Keys();\n                    for (const key in schema) {\n                        Common.tryWithPath(() => obj.$_terms.keys.push({ key, schema: this.$_compile(schema[key]) }), key);\n                    }\n                }\n\n                return obj.$_mutateRebuild();\n            }\n        },\n\n        length: {\n            method(limit) {\n\n                return this.$_addRule({ name: 'length', args: { limit }, operator: '=' });\n            },\n            validate(value, helpers, { limit }, { name, operator, args }) {\n\n                if (Common.compare(Object.keys(value).length, limit, operator)) {\n                    return value;\n                }\n\n                return helpers.error('object.' + name, { limit: args.limit, value });\n            },\n            args: [\n                {\n                    name: 'limit',\n                    ref: true,\n                    assert: Common.limit,\n                    message: 'must be a positive integer'\n                }\n            ]\n        },\n\n        max: {\n            method(limit) {\n\n                return this.$_addRule({ name: 'max', method: 'length', args: { limit }, operator: '<=' });\n            }\n        },\n\n        min: {\n            method(limit) {\n\n                return this.$_addRule({ name: 'min', method: 'length', args: { limit }, operator: '>=' });\n            }\n        },\n\n        nand: {\n            method(...peers /*, [options] */) {\n\n                Common.verifyFlat(peers, 'nand');\n\n                return internals.dependency(this, 'nand', null, peers);\n            }\n        },\n\n        or: {\n            method(...peers /*, [options] */) {\n\n                Common.verifyFlat(peers, 'or');\n\n                return internals.dependency(this, 'or', null, peers);\n            }\n        },\n\n        oxor: {\n            method(...peers /*, [options] */) {\n\n                return internals.dependency(this, 'oxor', null, peers);\n            }\n        },\n\n        pattern: {\n            method(pattern, schema, options = {}) {\n\n                const isRegExp = pattern instanceof RegExp;\n                if (!isRegExp) {\n                    pattern = this.$_compile(pattern, { appendPath: true });\n                }\n\n                Assert(schema !== undefined, 'Invalid rule');\n                Common.assertOptions(options, ['fallthrough', 'matches']);\n\n                if (isRegExp) {\n                    Assert(!pattern.flags.includes('g') && !pattern.flags.includes('y'), 'pattern should not use global or sticky mode');\n                }\n\n                schema = this.$_compile(schema, { appendPath: true });\n\n                const obj = this.clone();\n                obj.$_terms.patterns = obj.$_terms.patterns || [];\n                const config = { [isRegExp ? 'regex' : 'schema']: pattern, rule: schema };\n                if (options.matches) {\n                    config.matches = this.$_compile(options.matches);\n                    if (config.matches.type !== 'array') {\n                        config.matches = config.matches.$_root.array().items(config.matches);\n                    }\n\n                    obj.$_mutateRegister(config.matches);\n                    obj.$_setFlag('_hasPatternMatch', true, { clone: false });\n                }\n\n                if (options.fallthrough) {\n                    config.fallthrough = true;\n                }\n\n                obj.$_terms.patterns.push(config);\n                obj.$_mutateRegister(schema);\n                return obj;\n            }\n        },\n\n        ref: {\n            method() {\n\n                return this.$_addRule('ref');\n            },\n            validate(value, helpers) {\n\n                if (Ref.isRef(value)) {\n                    return value;\n                }\n\n                return helpers.error('object.refType', { value });\n            }\n        },\n\n        regex: {\n            method() {\n\n                return this.$_addRule('regex');\n            },\n            validate(value, helpers) {\n\n                if (value instanceof RegExp) {\n                    return value;\n                }\n\n                return helpers.error('object.regex', { value });\n            }\n        },\n\n        rename: {\n            method(from, to, options = {}) {\n\n                Assert(typeof from === 'string' || from instanceof RegExp, 'Rename missing the from argument');\n                Assert(typeof to === 'string' || to instanceof Template, 'Invalid rename to argument');\n                Assert(to !== from, 'Cannot rename key to same name:', from);\n\n                Common.assertOptions(options, ['alias', 'ignoreUndefined', 'override', 'multiple']);\n\n                const obj = this.clone();\n\n                obj.$_terms.renames = obj.$_terms.renames || [];\n                for (const rename of obj.$_terms.renames) {\n                    Assert(rename.from !== from, 'Cannot rename the same key multiple times');\n                }\n\n                if (to instanceof Template) {\n                    obj.$_mutateRegister(to);\n                }\n\n                obj.$_terms.renames.push({\n                    from,\n                    to,\n                    options: ApplyToDefaults(internals.renameDefaults, options)\n                });\n\n                return obj;\n            }\n        },\n\n        schema: {\n            method(type = 'any') {\n\n                return this.$_addRule({ name: 'schema', args: { type } });\n            },\n            validate(value, helpers, { type }) {\n\n                if (Common.isSchema(value) &&\n                    (type === 'any' || value.type === type)) {\n\n                    return value;\n                }\n\n                return helpers.error('object.schema', { type });\n            }\n        },\n\n        unknown: {\n            method(allow) {\n\n                return this.$_setFlag('unknown', allow !== false);\n            }\n        },\n\n        with: {\n            method(key, peers, options = {}) {\n\n                return internals.dependency(this, 'with', key, peers, options);\n            }\n        },\n\n        without: {\n            method(key, peers, options = {}) {\n\n                return internals.dependency(this, 'without', key, peers, options);\n            }\n        },\n\n        xor: {\n            method(...peers /*, [options] */) {\n\n                Common.verifyFlat(peers, 'xor');\n\n                return internals.dependency(this, 'xor', null, peers);\n            }\n        }\n    },\n\n    overrides: {\n\n        default(value, options) {\n\n            if (value === undefined) {\n                value = Common.symbols.deepDefault;\n            }\n\n            return this.$_parent('default', value, options);\n        }\n    },\n\n    rebuild(schema) {\n\n        if (schema.$_terms.keys) {\n            const topo = new Topo.Sorter();\n            for (const child of schema.$_terms.keys) {\n                Common.tryWithPath(() => topo.add(child, { after: child.schema.$_rootReferences(), group: child.key }), child.key);\n            }\n\n            schema.$_terms.keys = new internals.Keys(...topo.nodes);\n        }\n    },\n\n    manifest: {\n\n        build(obj, desc) {\n\n            if (desc.keys) {\n                obj = obj.keys(desc.keys);\n            }\n\n            if (desc.dependencies) {\n                for (const { rel, key = null, peers, options } of desc.dependencies) {\n                    obj = internals.dependency(obj, rel, key, peers, options);\n                }\n            }\n\n            if (desc.patterns) {\n                for (const { regex, schema, rule, fallthrough, matches } of desc.patterns) {\n                    obj = obj.pattern(regex || schema, rule, { fallthrough, matches });\n                }\n            }\n\n            if (desc.renames) {\n                for (const { from, to, options } of desc.renames) {\n                    obj = obj.rename(from, to, options);\n                }\n            }\n\n            return obj;\n        }\n    },\n\n    messages: {\n        'object.and': '{{#label}} contains {{#presentWithLabels}} without its required peers {{#missingWithLabels}}',\n        'object.assert': '{{#label}} is invalid because {if(#subject.key, `\"` + #subject.key + `\" failed to ` + (#message || \"pass the assertion test\"), #message || \"the assertion failed\")}',\n        'object.base': '{{#label}} must be of type {{#type}}',\n        'object.instance': '{{#label}} must be an instance of {{:#type}}',\n        'object.length': '{{#label}} must have {{#limit}} key{if(#limit == 1, \"\", \"s\")}',\n        'object.max': '{{#label}} must have less than or equal to {{#limit}} key{if(#limit == 1, \"\", \"s\")}',\n        'object.min': '{{#label}} must have at least {{#limit}} key{if(#limit == 1, \"\", \"s\")}',\n        'object.missing': '{{#label}} must contain at least one of {{#peersWithLabels}}',\n        'object.nand': '{{:#mainWithLabel}} must not exist simultaneously with {{#peersWithLabels}}',\n        'object.oxor': '{{#label}} contains a conflict between optional exclusive peers {{#peersWithLabels}}',\n        'object.pattern.match': '{{#label}} keys failed to match pattern requirements',\n        'object.refType': '{{#label}} must be a Joi reference',\n        'object.regex': '{{#label}} must be a RegExp object',\n        'object.rename.multiple': '{{#label}} cannot rename {{:#from}} because multiple renames are disabled and another key was already renamed to {{:#to}}',\n        'object.rename.override': '{{#label}} cannot rename {{:#from}} because override is disabled and target {{:#to}} exists',\n        'object.schema': '{{#label}} must be a Joi schema of {{#type}} type',\n        'object.unknown': '{{#label}} is not allowed',\n        'object.with': '{{:#mainWithLabel}} missing required peer {{:#peerWithLabel}}',\n        'object.without': '{{:#mainWithLabel}} conflict with forbidden peer {{:#peerWithLabel}}',\n        'object.xor': '{{#label}} contains a conflict between exclusive peers {{#peersWithLabels}}'\n    }\n});\n\n\n// Helpers\n\ninternals.clone = function (value, prefs) {\n\n    // Object\n\n    if (typeof value === 'object') {\n        if (prefs.nonEnumerables) {\n            return Clone(value, { shallow: true });\n        }\n\n        const clone = Object.create(Object.getPrototypeOf(value));\n        Object.assign(clone, value);\n        return clone;\n    }\n\n    // Function\n\n    const clone = function (...args) {\n\n        return value.apply(this, args);\n    };\n\n    clone.prototype = Clone(value.prototype);\n    Object.defineProperty(clone, 'name', { value: value.name, writable: false });\n    Object.defineProperty(clone, 'length', { value: value.length, writable: false });\n    Object.assign(clone, value);\n    return clone;\n};\n\n\ninternals.dependency = function (schema, rel, key, peers, options) {\n\n    Assert(key === null || typeof key === 'string', rel, 'key must be a strings');\n\n    // Extract options from peers array\n\n    if (!options) {\n        options = peers.length > 1 && typeof peers[peers.length - 1] === 'object' ? peers.pop() : {};\n    }\n\n    Common.assertOptions(options, ['separator']);\n\n    peers = [].concat(peers);\n\n    // Cast peer paths\n\n    const separator = Common.default(options.separator, '.');\n    const paths = [];\n    for (const peer of peers) {\n        Assert(typeof peer === 'string', rel, 'peers must be strings');\n        paths.push(Compile.ref(peer, { separator, ancestor: 0, prefix: false }));\n    }\n\n    // Cast key\n\n    if (key !== null) {\n        key = Compile.ref(key, { separator, ancestor: 0, prefix: false });\n    }\n\n    // Add rule\n\n    const obj = schema.clone();\n    obj.$_terms.dependencies = obj.$_terms.dependencies || [];\n    obj.$_terms.dependencies.push(new internals.Dependency(rel, key, paths, peers));\n    return obj;\n};\n\n\ninternals.dependencies = {\n\n    and(schema, dep, value, state, prefs) {\n\n        const missing = [];\n        const present = [];\n        const count = dep.peers.length;\n        for (const peer of dep.peers) {\n            if (peer.resolve(value, state, prefs, null, { shadow: false }) === undefined) {\n                missing.push(peer.key);\n            }\n            else {\n                present.push(peer.key);\n            }\n        }\n\n        if (missing.length !== count &&\n            present.length !== count) {\n\n            return {\n                code: 'object.and',\n                context: {\n                    present,\n                    presentWithLabels: internals.keysToLabels(schema, present),\n                    missing,\n                    missingWithLabels: internals.keysToLabels(schema, missing)\n                }\n            };\n        }\n    },\n\n    nand(schema, dep, value, state, prefs) {\n\n        const present = [];\n        for (const peer of dep.peers) {\n            if (peer.resolve(value, state, prefs, null, { shadow: false }) !== undefined) {\n                present.push(peer.key);\n            }\n        }\n\n        if (present.length !== dep.peers.length) {\n            return;\n        }\n\n        const main = dep.paths[0];\n        const values = dep.paths.slice(1);\n        return {\n            code: 'object.nand',\n            context: {\n                main,\n                mainWithLabel: internals.keysToLabels(schema, main),\n                peers: values,\n                peersWithLabels: internals.keysToLabels(schema, values)\n            }\n        };\n    },\n\n    or(schema, dep, value, state, prefs) {\n\n        for (const peer of dep.peers) {\n            if (peer.resolve(value, state, prefs, null, { shadow: false }) !== undefined) {\n                return;\n            }\n        }\n\n        return {\n            code: 'object.missing',\n            context: {\n                peers: dep.paths,\n                peersWithLabels: internals.keysToLabels(schema, dep.paths)\n            }\n        };\n    },\n\n    oxor(schema, dep, value, state, prefs) {\n\n        const present = [];\n        for (const peer of dep.peers) {\n            if (peer.resolve(value, state, prefs, null, { shadow: false }) !== undefined) {\n                present.push(peer.key);\n            }\n        }\n\n        if (!present.length ||\n            present.length === 1) {\n\n            return;\n        }\n\n        const context = { peers: dep.paths, peersWithLabels: internals.keysToLabels(schema, dep.paths) };\n        context.present = present;\n        context.presentWithLabels = internals.keysToLabels(schema, present);\n        return { code: 'object.oxor', context };\n    },\n\n    with(schema, dep, value, state, prefs) {\n\n        for (const peer of dep.peers) {\n            if (peer.resolve(value, state, prefs, null, { shadow: false }) === undefined) {\n                return {\n                    code: 'object.with',\n                    context: {\n                        main: dep.key.key,\n                        mainWithLabel: internals.keysToLabels(schema, dep.key.key),\n                        peer: peer.key,\n                        peerWithLabel: internals.keysToLabels(schema, peer.key)\n                    }\n                };\n            }\n        }\n    },\n\n    without(schema, dep, value, state, prefs) {\n\n        for (const peer of dep.peers) {\n            if (peer.resolve(value, state, prefs, null, { shadow: false }) !== undefined) {\n                return {\n                    code: 'object.without',\n                    context: {\n                        main: dep.key.key,\n                        mainWithLabel: internals.keysToLabels(schema, dep.key.key),\n                        peer: peer.key,\n                        peerWithLabel: internals.keysToLabels(schema, peer.key)\n                    }\n                };\n            }\n        }\n    },\n\n    xor(schema, dep, value, state, prefs) {\n\n        const present = [];\n        for (const peer of dep.peers) {\n            if (peer.resolve(value, state, prefs, null, { shadow: false }) !== undefined) {\n                present.push(peer.key);\n            }\n        }\n\n        if (present.length === 1) {\n            return;\n        }\n\n        const context = { peers: dep.paths, peersWithLabels: internals.keysToLabels(schema, dep.paths) };\n        if (present.length === 0) {\n            return { code: 'object.missing', context };\n        }\n\n        context.present = present;\n        context.presentWithLabels = internals.keysToLabels(schema, present);\n        return { code: 'object.xor', context };\n    }\n};\n\n\ninternals.keysToLabels = function (schema, keys) {\n\n    if (Array.isArray(keys)) {\n        return keys.map((key) => schema.$_mapLabels(key));\n    }\n\n    return schema.$_mapLabels(keys);\n};\n\n\ninternals.rename = function (schema, value, state, prefs, errors) {\n\n    const renamed = {};\n    for (const rename of schema.$_terms.renames) {\n        const matches = [];\n        const pattern = typeof rename.from !== 'string';\n\n        if (!pattern) {\n            if (Object.prototype.hasOwnProperty.call(value, rename.from) &&\n                (value[rename.from] !== undefined || !rename.options.ignoreUndefined)) {\n\n                matches.push(rename);\n            }\n        }\n        else {\n            for (const from in value) {\n                if (value[from] === undefined &&\n                    rename.options.ignoreUndefined) {\n\n                    continue;\n                }\n\n                if (from === rename.to) {\n                    continue;\n                }\n\n                const match = rename.from.exec(from);\n                if (!match) {\n                    continue;\n                }\n\n                matches.push({ from, to: rename.to, match });\n            }\n        }\n\n        for (const match of matches) {\n            const from = match.from;\n            let to = match.to;\n            if (to instanceof Template) {\n                to = to.render(value, state, prefs, match.match);\n            }\n\n            if (from === to) {\n                continue;\n            }\n\n            if (!rename.options.multiple &&\n                renamed[to]) {\n\n                errors.push(schema.$_createError('object.rename.multiple', value, { from, to, pattern }, state, prefs));\n                if (prefs.abortEarly) {\n                    return false;\n                }\n            }\n\n            if (Object.prototype.hasOwnProperty.call(value, to) &&\n                !rename.options.override &&\n                !renamed[to]) {\n\n                errors.push(schema.$_createError('object.rename.override', value, { from, to, pattern }, state, prefs));\n                if (prefs.abortEarly) {\n                    return false;\n                }\n            }\n\n            if (value[from] === undefined) {\n                delete value[to];\n            }\n            else {\n                value[to] = value[from];\n            }\n\n            renamed[to] = true;\n\n            if (!rename.options.alias) {\n                delete value[from];\n            }\n        }\n    }\n\n    return true;\n};\n\n\ninternals.unknown = function (schema, value, unprocessed, errors, state, prefs) {\n\n    if (schema.$_terms.patterns) {\n        let hasMatches = false;\n        const matches = schema.$_terms.patterns.map((pattern) => {\n\n            if (pattern.matches) {\n                hasMatches = true;\n                return [];\n            }\n        });\n\n        const ancestors = [value, ...state.ancestors];\n\n        for (const key of unprocessed) {\n            const item = value[key];\n            const path = [...state.path, key];\n\n            for (let i = 0; i < schema.$_terms.patterns.length; ++i) {\n                const pattern = schema.$_terms.patterns[i];\n                if (pattern.regex) {\n                    const match = pattern.regex.test(key);\n                    state.mainstay.tracer.debug(state, 'rule', `pattern.${i}`, match ? 'pass' : 'error');\n                    if (!match) {\n                        continue;\n                    }\n                }\n                else {\n                    if (!pattern.schema.$_match(key, state.nest(pattern.schema, `pattern.${i}`), prefs)) {\n                        continue;\n                    }\n                }\n\n                unprocessed.delete(key);\n\n                const localState = state.localize(path, ancestors, { schema: pattern.rule, key });\n                const result = pattern.rule.$_validate(item, localState, prefs);\n                if (result.errors) {\n                    if (prefs.abortEarly) {\n                        return { value, errors: result.errors };\n                    }\n\n                    errors.push(...result.errors);\n                }\n\n                if (pattern.matches) {\n                    matches[i].push(key);\n                }\n\n                value[key] = result.value;\n                if (!pattern.fallthrough) {\n                    break;\n                }\n            }\n        }\n\n        // Validate pattern matches rules\n\n        if (hasMatches) {\n            for (let i = 0; i < matches.length; ++i) {\n                const match = matches[i];\n                if (!match) {\n                    continue;\n                }\n\n                const stpm = schema.$_terms.patterns[i].matches;\n                const localState = state.localize(state.path, ancestors, stpm);\n                const result = stpm.$_validate(match, localState, prefs);\n                if (result.errors) {\n                    const details = Errors.details(result.errors, { override: false });\n                    details.matches = match;\n                    const report = schema.$_createError('object.pattern.match', value, details, state, prefs);\n                    if (prefs.abortEarly) {\n                        return { value, errors: report };\n                    }\n\n                    errors.push(report);\n                }\n            }\n        }\n    }\n\n    if (!unprocessed.size ||\n        !schema.$_terms.keys && !schema.$_terms.patterns) {     // If no keys or patterns specified, unknown keys allowed\n\n        return;\n    }\n\n    if (prefs.stripUnknown && !schema._flags.unknown ||\n        prefs.skipFunctions) {\n\n        const stripUnknown = prefs.stripUnknown ? (prefs.stripUnknown === true ? true : !!prefs.stripUnknown.objects) : false;\n\n        for (const key of unprocessed) {\n            if (stripUnknown) {\n                delete value[key];\n                unprocessed.delete(key);\n            }\n            else if (typeof value[key] === 'function') {\n                unprocessed.delete(key);\n            }\n        }\n    }\n\n    const forbidUnknown = !Common.default(schema._flags.unknown, prefs.allowUnknown);\n    if (forbidUnknown) {\n        for (const unprocessedKey of unprocessed) {\n            const localState = state.localize([...state.path, unprocessedKey], []);\n            const report = schema.$_createError('object.unknown', value[unprocessedKey], { child: unprocessedKey }, localState, prefs, { flags: false });\n            if (prefs.abortEarly) {\n                return { value, errors: report };\n            }\n\n            errors.push(report);\n        }\n    }\n};\n\n\ninternals.Dependency = class {\n\n    constructor(rel, key, peers, paths) {\n\n        this.rel = rel;\n        this.key = key;\n        this.peers = peers;\n        this.paths = paths;\n    }\n\n    describe() {\n\n        const desc = {\n            rel: this.rel,\n            peers: this.paths\n        };\n\n        if (this.key !== null) {\n            desc.key = this.key.key;\n        }\n\n        if (this.peers[0].separator !== '.') {\n            desc.options = { separator: this.peers[0].separator };\n        }\n\n        return desc;\n    }\n};\n\n\ninternals.Keys = class extends Array {\n\n    concat(source) {\n\n        const result = this.slice();\n\n        const keys = new Map();\n        for (let i = 0; i < result.length; ++i) {\n            keys.set(result[i].key, i);\n        }\n\n        for (const item of source) {\n            const key = item.key;\n            const pos = keys.get(key);\n            if (pos !== undefined) {\n                result[pos] = { key, schema: result[pos].schema.concat(item.schema) };\n            }\n            else {\n                result.push(item);\n            }\n        }\n\n        return result;\n    }\n};\n"]},"metadata":{},"sourceType":"script"}