{"ast":null,"code":"'use strict';\n\nconst Assert = require('@hapi/hoek/lib/assert');\n\nconst Any = require('./any');\n\nconst Common = require('../common');\n\nconst internals = {\n  numberRx: /^\\s*[+-]?(?:(?:\\d+(?:\\.\\d*)?)|(?:\\.\\d+))(?:e([+-]?\\d+))?\\s*$/i,\n  precisionRx: /(?:\\.(\\d+))?(?:[eE]([+-]?\\d+))?$/\n};\nmodule.exports = Any.extend({\n  type: 'number',\n  flags: {\n    unsafe: {\n      default: false\n    }\n  },\n  coerce: {\n    from: 'string',\n\n    method(value, {\n      schema,\n      error\n    }) {\n      const matches = value.match(internals.numberRx);\n\n      if (!matches) {\n        return;\n      }\n\n      value = value.trim();\n      const result = {\n        value: parseFloat(value)\n      };\n\n      if (result.value === 0) {\n        result.value = 0; // -0\n      }\n\n      if (!schema._flags.unsafe) {\n        if (value.match(/e/i)) {\n          const constructed = internals.normalizeExponent(`${result.value / Math.pow(10, matches[1])}e${matches[1]}`);\n\n          if (constructed !== internals.normalizeExponent(value)) {\n            result.errors = error('number.unsafe');\n            return result;\n          }\n        } else {\n          const string = result.value.toString();\n\n          if (string.match(/e/i)) {\n            return result;\n          }\n\n          if (string !== internals.normalizeDecimal(value)) {\n            result.errors = error('number.unsafe');\n            return result;\n          }\n        }\n      }\n\n      return result;\n    }\n\n  },\n\n  validate(value, {\n    schema,\n    error,\n    prefs\n  }) {\n    if (value === Infinity || value === -Infinity) {\n      return {\n        value,\n        errors: error('number.infinity')\n      };\n    }\n\n    if (!Common.isNumber(value)) {\n      return {\n        value,\n        errors: error('number.base')\n      };\n    }\n\n    const result = {\n      value\n    };\n\n    if (prefs.convert) {\n      const rule = schema.$_getRule('precision');\n\n      if (rule) {\n        const precision = Math.pow(10, rule.args.limit); // This is conceptually equivalent to using toFixed but it should be much faster\n\n        result.value = Math.round(result.value * precision) / precision;\n      }\n    }\n\n    if (result.value === 0) {\n      result.value = 0; // -0\n    }\n\n    if (!schema._flags.unsafe && (value > Number.MAX_SAFE_INTEGER || value < Number.MIN_SAFE_INTEGER)) {\n      result.errors = error('number.unsafe');\n    }\n\n    return result;\n  },\n\n  rules: {\n    compare: {\n      method: false,\n\n      validate(value, helpers, {\n        limit\n      }, {\n        name,\n        operator,\n        args\n      }) {\n        if (Common.compare(value, limit, operator)) {\n          return value;\n        }\n\n        return helpers.error('number.' + name, {\n          limit: args.limit,\n          value\n        });\n      },\n\n      args: [{\n        name: 'limit',\n        ref: true,\n        assert: Common.isNumber,\n        message: 'must be a number'\n      }]\n    },\n    greater: {\n      method(limit) {\n        return this.$_addRule({\n          name: 'greater',\n          method: 'compare',\n          args: {\n            limit\n          },\n          operator: '>'\n        });\n      }\n\n    },\n    integer: {\n      method() {\n        return this.$_addRule('integer');\n      },\n\n      validate(value, helpers) {\n        if (Math.trunc(value) - value === 0) {\n          return value;\n        }\n\n        return helpers.error('number.integer');\n      }\n\n    },\n    less: {\n      method(limit) {\n        return this.$_addRule({\n          name: 'less',\n          method: 'compare',\n          args: {\n            limit\n          },\n          operator: '<'\n        });\n      }\n\n    },\n    max: {\n      method(limit) {\n        return this.$_addRule({\n          name: 'max',\n          method: 'compare',\n          args: {\n            limit\n          },\n          operator: '<='\n        });\n      }\n\n    },\n    min: {\n      method(limit) {\n        return this.$_addRule({\n          name: 'min',\n          method: 'compare',\n          args: {\n            limit\n          },\n          operator: '>='\n        });\n      }\n\n    },\n    multiple: {\n      method(base) {\n        return this.$_addRule({\n          name: 'multiple',\n          args: {\n            base\n          }\n        });\n      },\n\n      validate(value, helpers, {\n        base\n      }, options) {\n        if (value % base === 0) {\n          return value;\n        }\n\n        return helpers.error('number.multiple', {\n          multiple: options.args.base,\n          value\n        });\n      },\n\n      args: [{\n        name: 'base',\n        ref: true,\n        assert: value => typeof value === 'number' && isFinite(value) && value > 0,\n        message: 'must be a positive number'\n      }],\n      multi: true\n    },\n    negative: {\n      method() {\n        return this.sign('negative');\n      }\n\n    },\n    port: {\n      method() {\n        return this.$_addRule('port');\n      },\n\n      validate(value, helpers) {\n        if (Number.isSafeInteger(value) && value >= 0 && value <= 65535) {\n          return value;\n        }\n\n        return helpers.error('number.port');\n      }\n\n    },\n    positive: {\n      method() {\n        return this.sign('positive');\n      }\n\n    },\n    precision: {\n      method(limit) {\n        Assert(Number.isSafeInteger(limit), 'limit must be an integer');\n        return this.$_addRule({\n          name: 'precision',\n          args: {\n            limit\n          }\n        });\n      },\n\n      validate(value, helpers, {\n        limit\n      }) {\n        const places = value.toString().match(internals.precisionRx);\n        const decimals = Math.max((places[1] ? places[1].length : 0) - (places[2] ? parseInt(places[2], 10) : 0), 0);\n\n        if (decimals <= limit) {\n          return value;\n        }\n\n        return helpers.error('number.precision', {\n          limit,\n          value\n        });\n      },\n\n      convert: true\n    },\n    sign: {\n      method(sign) {\n        Assert(['negative', 'positive'].includes(sign), 'Invalid sign', sign);\n        return this.$_addRule({\n          name: 'sign',\n          args: {\n            sign\n          }\n        });\n      },\n\n      validate(value, helpers, {\n        sign\n      }) {\n        if (sign === 'negative' && value < 0 || sign === 'positive' && value > 0) {\n          return value;\n        }\n\n        return helpers.error(`number.${sign}`);\n      }\n\n    },\n    unsafe: {\n      method(enabled = true) {\n        Assert(typeof enabled === 'boolean', 'enabled must be a boolean');\n        return this.$_setFlag('unsafe', enabled);\n      }\n\n    }\n  },\n  cast: {\n    string: {\n      from: value => typeof value === 'number',\n\n      to(value, helpers) {\n        return value.toString();\n      }\n\n    }\n  },\n  messages: {\n    'number.base': '{{#label}} must be a number',\n    'number.greater': '{{#label}} must be greater than {{#limit}}',\n    'number.infinity': '{{#label}} cannot be infinity',\n    'number.integer': '{{#label}} must be an integer',\n    'number.less': '{{#label}} must be less than {{#limit}}',\n    'number.max': '{{#label}} must be less than or equal to {{#limit}}',\n    'number.min': '{{#label}} must be greater than or equal to {{#limit}}',\n    'number.multiple': '{{#label}} must be a multiple of {{#multiple}}',\n    'number.negative': '{{#label}} must be a negative number',\n    'number.port': '{{#label}} must be a valid port',\n    'number.positive': '{{#label}} must be a positive number',\n    'number.precision': '{{#label}} must have no more than {{#limit}} decimal places',\n    'number.unsafe': '{{#label}} must be a safe number'\n  }\n}); // Helpers\n\ninternals.normalizeExponent = function (str) {\n  return str.replace(/E/, 'e').replace(/\\.(\\d*[1-9])?0+e/, '.$1e').replace(/\\.e/, 'e').replace(/e\\+/, 'e').replace(/^\\+/, '').replace(/^(-?)0+([1-9])/, '$1$2');\n};\n\ninternals.normalizeDecimal = function (str) {\n  str = str // Remove leading plus signs\n  .replace(/^\\+/, '') // Remove trailing zeros if there is a decimal point and unecessary decimal points\n  .replace(/\\.0*$/, '') // Add a integer 0 if the numbers starts with a decimal point\n  .replace(/^(-?)\\.([^\\.]*)$/, '$10.$2') // Remove leading zeros\n  .replace(/^(-?)0+([0-9])/, '$1$2');\n\n  if (str.includes('.') && str.endsWith('0')) {\n    str = str.replace(/0+$/, '');\n  }\n\n  if (str === '-0') {\n    return '0';\n  }\n\n  return str;\n};","map":{"version":3,"sources":["C:/scripting/jobs assignments/whist/backend/node_modules/joi/lib/types/number.js"],"names":["Assert","require","Any","Common","internals","numberRx","precisionRx","module","exports","extend","type","flags","unsafe","default","coerce","from","method","value","schema","error","matches","match","trim","result","parseFloat","_flags","constructed","normalizeExponent","Math","pow","errors","string","toString","normalizeDecimal","validate","prefs","Infinity","isNumber","convert","rule","$_getRule","precision","args","limit","round","Number","MAX_SAFE_INTEGER","MIN_SAFE_INTEGER","rules","compare","helpers","name","operator","ref","assert","message","greater","$_addRule","integer","trunc","less","max","min","multiple","base","options","isFinite","multi","negative","sign","port","isSafeInteger","positive","places","decimals","length","parseInt","includes","enabled","$_setFlag","cast","to","messages","str","replace","endsWith"],"mappings":"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","sourcesContent":["'use strict';\n\nconst Assert = require('@hapi/hoek/lib/assert');\n\nconst Any = require('./any');\nconst Common = require('../common');\n\n\nconst internals = {\n    numberRx: /^\\s*[+-]?(?:(?:\\d+(?:\\.\\d*)?)|(?:\\.\\d+))(?:e([+-]?\\d+))?\\s*$/i,\n    precisionRx: /(?:\\.(\\d+))?(?:[eE]([+-]?\\d+))?$/\n};\n\n\nmodule.exports = Any.extend({\n\n    type: 'number',\n\n    flags: {\n\n        unsafe: { default: false }\n    },\n\n    coerce: {\n        from: 'string',\n        method(value, { schema, error }) {\n\n            const matches = value.match(internals.numberRx);\n            if (!matches) {\n                return;\n            }\n\n            value = value.trim();\n            const result = { value: parseFloat(value) };\n\n            if (result.value === 0) {\n                result.value = 0;           // -0\n            }\n\n            if (!schema._flags.unsafe) {\n                if (value.match(/e/i)) {\n                    const constructed = internals.normalizeExponent(`${result.value / Math.pow(10, matches[1])}e${matches[1]}`);\n                    if (constructed !== internals.normalizeExponent(value)) {\n                        result.errors = error('number.unsafe');\n                        return result;\n                    }\n                }\n                else {\n                    const string = result.value.toString();\n                    if (string.match(/e/i)) {\n                        return result;\n                    }\n\n                    if (string !== internals.normalizeDecimal(value)) {\n                        result.errors = error('number.unsafe');\n                        return result;\n                    }\n                }\n            }\n\n            return result;\n        }\n    },\n\n    validate(value, { schema, error, prefs }) {\n\n        if (value === Infinity ||\n            value === -Infinity) {\n\n            return { value, errors: error('number.infinity') };\n        }\n\n        if (!Common.isNumber(value)) {\n            return { value, errors: error('number.base') };\n        }\n\n        const result = { value };\n\n        if (prefs.convert) {\n            const rule = schema.$_getRule('precision');\n            if (rule) {\n                const precision = Math.pow(10, rule.args.limit);                    // This is conceptually equivalent to using toFixed but it should be much faster\n                result.value = Math.round(result.value * precision) / precision;\n            }\n        }\n\n        if (result.value === 0) {\n            result.value = 0;           // -0\n        }\n\n        if (!schema._flags.unsafe &&\n            (value > Number.MAX_SAFE_INTEGER || value < Number.MIN_SAFE_INTEGER)) {\n\n            result.errors = error('number.unsafe');\n        }\n\n        return result;\n    },\n\n    rules: {\n\n        compare: {\n            method: false,\n            validate(value, helpers, { limit }, { name, operator, args }) {\n\n                if (Common.compare(value, limit, operator)) {\n                    return value;\n                }\n\n                return helpers.error('number.' + name, { limit: args.limit, value });\n            },\n            args: [\n                {\n                    name: 'limit',\n                    ref: true,\n                    assert: Common.isNumber,\n                    message: 'must be a number'\n                }\n            ]\n        },\n\n        greater: {\n            method(limit) {\n\n                return this.$_addRule({ name: 'greater', method: 'compare', args: { limit }, operator: '>' });\n            }\n        },\n\n        integer: {\n            method() {\n\n                return this.$_addRule('integer');\n            },\n            validate(value, helpers) {\n\n                if (Math.trunc(value) - value === 0) {\n                    return value;\n                }\n\n                return helpers.error('number.integer');\n            }\n        },\n\n        less: {\n            method(limit) {\n\n                return this.$_addRule({ name: 'less', method: 'compare', args: { limit }, operator: '<' });\n            }\n        },\n\n        max: {\n            method(limit) {\n\n                return this.$_addRule({ name: 'max', method: 'compare', args: { limit }, operator: '<=' });\n            }\n        },\n\n        min: {\n            method(limit) {\n\n                return this.$_addRule({ name: 'min', method: 'compare', args: { limit }, operator: '>=' });\n            }\n        },\n\n        multiple: {\n            method(base) {\n\n                return this.$_addRule({ name: 'multiple', args: { base } });\n            },\n            validate(value, helpers, { base }, options) {\n\n                if (value % base === 0) {\n                    return value;\n                }\n\n                return helpers.error('number.multiple', { multiple: options.args.base, value });\n            },\n            args: [\n                {\n                    name: 'base',\n                    ref: true,\n                    assert: (value) => typeof value === 'number' && isFinite(value) && value > 0,\n                    message: 'must be a positive number'\n                }\n            ],\n            multi: true\n        },\n\n        negative: {\n            method() {\n\n                return this.sign('negative');\n            }\n        },\n\n        port: {\n            method() {\n\n                return this.$_addRule('port');\n            },\n            validate(value, helpers) {\n\n                if (Number.isSafeInteger(value) &&\n                    value >= 0 &&\n                    value <= 65535) {\n\n                    return value;\n                }\n\n                return helpers.error('number.port');\n            }\n        },\n\n        positive: {\n            method() {\n\n                return this.sign('positive');\n            }\n        },\n\n        precision: {\n            method(limit) {\n\n                Assert(Number.isSafeInteger(limit), 'limit must be an integer');\n\n                return this.$_addRule({ name: 'precision', args: { limit } });\n            },\n            validate(value, helpers, { limit }) {\n\n                const places = value.toString().match(internals.precisionRx);\n                const decimals = Math.max((places[1] ? places[1].length : 0) - (places[2] ? parseInt(places[2], 10) : 0), 0);\n                if (decimals <= limit) {\n                    return value;\n                }\n\n                return helpers.error('number.precision', { limit, value });\n            },\n            convert: true\n        },\n\n        sign: {\n            method(sign) {\n\n                Assert(['negative', 'positive'].includes(sign), 'Invalid sign', sign);\n\n                return this.$_addRule({ name: 'sign', args: { sign } });\n            },\n            validate(value, helpers, { sign }) {\n\n                if (sign === 'negative' && value < 0 ||\n                    sign === 'positive' && value > 0) {\n\n                    return value;\n                }\n\n                return helpers.error(`number.${sign}`);\n            }\n        },\n\n        unsafe: {\n            method(enabled = true) {\n\n                Assert(typeof enabled === 'boolean', 'enabled must be a boolean');\n\n                return this.$_setFlag('unsafe', enabled);\n            }\n        }\n    },\n\n    cast: {\n        string: {\n            from: (value) => typeof value === 'number',\n            to(value, helpers) {\n\n                return value.toString();\n            }\n        }\n    },\n\n    messages: {\n        'number.base': '{{#label}} must be a number',\n        'number.greater': '{{#label}} must be greater than {{#limit}}',\n        'number.infinity': '{{#label}} cannot be infinity',\n        'number.integer': '{{#label}} must be an integer',\n        'number.less': '{{#label}} must be less than {{#limit}}',\n        'number.max': '{{#label}} must be less than or equal to {{#limit}}',\n        'number.min': '{{#label}} must be greater than or equal to {{#limit}}',\n        'number.multiple': '{{#label}} must be a multiple of {{#multiple}}',\n        'number.negative': '{{#label}} must be a negative number',\n        'number.port': '{{#label}} must be a valid port',\n        'number.positive': '{{#label}} must be a positive number',\n        'number.precision': '{{#label}} must have no more than {{#limit}} decimal places',\n        'number.unsafe': '{{#label}} must be a safe number'\n    }\n});\n\n\n// Helpers\n\ninternals.normalizeExponent = function (str) {\n\n    return str\n        .replace(/E/, 'e')\n        .replace(/\\.(\\d*[1-9])?0+e/, '.$1e')\n        .replace(/\\.e/, 'e')\n        .replace(/e\\+/, 'e')\n        .replace(/^\\+/, '')\n        .replace(/^(-?)0+([1-9])/, '$1$2');\n};\n\n\ninternals.normalizeDecimal = function (str) {\n\n    str = str\n        // Remove leading plus signs\n        .replace(/^\\+/, '')\n        // Remove trailing zeros if there is a decimal point and unecessary decimal points\n        .replace(/\\.0*$/, '')\n        // Add a integer 0 if the numbers starts with a decimal point\n        .replace(/^(-?)\\.([^\\.]*)$/, '$10.$2')\n        // Remove leading zeros\n        .replace(/^(-?)0+([0-9])/, '$1$2');\n\n    if (str.includes('.') &&\n        str.endsWith('0')) {\n\n        str = str.replace(/0+$/, '');\n    }\n\n    if (str === '-0') {\n        return '0';\n    }\n\n    return str;\n};\n"]},"metadata":{},"sourceType":"script"}