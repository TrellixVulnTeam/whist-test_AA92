{"ast":null,"code":"'use strict';\n\nconst Assert = require('@hapi/hoek/lib/assert');\n\nconst AssertError = require('@hapi/hoek/lib/error');\n\nconst Pkg = require('../package.json');\n\nlet Messages;\nlet Schemas;\nconst internals = {\n  isoDate: /^(?:[-+]\\d{2})?(?:\\d{4}(?!\\d{2}\\b))(?:(-?)(?:(?:0[1-9]|1[0-2])(?:\\1(?:[12]\\d|0[1-9]|3[01]))?|W(?:[0-4]\\d|5[0-2])(?:-?[1-7])?|(?:00[1-9]|0[1-9]\\d|[12]\\d{2}|3(?:[0-5]\\d|6[1-6])))(?![T]$|[T][\\d]+Z$)(?:[T\\s](?:(?:(?:[01]\\d|2[0-3])(?:(:?)[0-5]\\d)?|24\\:?00)(?:[.,]\\d+(?!:))?)(?:\\2[0-5]\\d(?:[.,]\\d+)?)?(?:[Z]|(?:[+-])(?:[01]\\d|2[0-3])(?::?[0-5]\\d)?)?)?)?$/\n};\nexports.version = Pkg.version;\nexports.defaults = {\n  abortEarly: true,\n  allowUnknown: false,\n  artifacts: false,\n  cache: true,\n  context: null,\n  convert: true,\n  dateFormat: 'iso',\n  errors: {\n    escapeHtml: false,\n    label: 'path',\n    language: null,\n    render: true,\n    stack: false,\n    wrap: {\n      label: '\"',\n      array: '[]'\n    }\n  },\n  externals: true,\n  messages: {},\n  nonEnumerables: false,\n  noDefaults: false,\n  presence: 'optional',\n  skipFunctions: false,\n  stripUnknown: false,\n  warnings: false\n};\nexports.symbols = {\n  any: Symbol.for('@hapi/joi/schema'),\n  // Used to internally identify any-based types (shared with other joi versions)\n  arraySingle: Symbol('arraySingle'),\n  deepDefault: Symbol('deepDefault'),\n  errors: Symbol('errors'),\n  literal: Symbol('literal'),\n  override: Symbol('override'),\n  parent: Symbol('parent'),\n  prefs: Symbol('prefs'),\n  ref: Symbol('ref'),\n  template: Symbol('template'),\n  values: Symbol('values')\n};\n\nexports.assertOptions = function (options, keys, name = 'Options') {\n  Assert(options && typeof options === 'object' && !Array.isArray(options), 'Options must be of type object');\n  const unknownKeys = Object.keys(options).filter(k => !keys.includes(k));\n  Assert(unknownKeys.length === 0, `${name} contain unknown keys: ${unknownKeys}`);\n};\n\nexports.checkPreferences = function (prefs) {\n  Schemas = Schemas || require('./schemas');\n  const result = Schemas.preferences.validate(prefs);\n\n  if (result.error) {\n    throw new AssertError([result.error.details[0].message]);\n  }\n};\n\nexports.compare = function (a, b, operator) {\n  switch (operator) {\n    case '=':\n      return a === b;\n\n    case '>':\n      return a > b;\n\n    case '<':\n      return a < b;\n\n    case '>=':\n      return a >= b;\n\n    case '<=':\n      return a <= b;\n  }\n};\n\nexports.default = function (value, defaultValue) {\n  return value === undefined ? defaultValue : value;\n};\n\nexports.isIsoDate = function (date) {\n  return internals.isoDate.test(date);\n};\n\nexports.isNumber = function (value) {\n  return typeof value === 'number' && !isNaN(value);\n};\n\nexports.isResolvable = function (obj) {\n  if (!obj) {\n    return false;\n  }\n\n  return obj[exports.symbols.ref] || obj[exports.symbols.template];\n};\n\nexports.isSchema = function (schema, options = {}) {\n  const any = schema && schema[exports.symbols.any];\n\n  if (!any) {\n    return false;\n  }\n\n  Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\n  return true;\n};\n\nexports.isValues = function (obj) {\n  return obj[exports.symbols.values];\n};\n\nexports.limit = function (value) {\n  return Number.isSafeInteger(value) && value >= 0;\n};\n\nexports.preferences = function (target, source) {\n  Messages = Messages || require('./messages');\n  target = target || {};\n  source = source || {};\n  const merged = Object.assign({}, target, source);\n\n  if (source.errors && target.errors) {\n    merged.errors = Object.assign({}, target.errors, source.errors);\n    merged.errors.wrap = Object.assign({}, target.errors.wrap, source.errors.wrap);\n  }\n\n  if (source.messages) {\n    merged.messages = Messages.compile(source.messages, target.messages);\n  }\n\n  delete merged[exports.symbols.prefs];\n  return merged;\n};\n\nexports.tryWithPath = function (fn, key, options = {}) {\n  try {\n    return fn();\n  } catch (err) {\n    if (err.path !== undefined) {\n      err.path = key + '.' + err.path;\n    } else {\n      err.path = key;\n    }\n\n    if (options.append) {\n      err.message = `${err.message} (${err.path})`;\n    }\n\n    throw err;\n  }\n};\n\nexports.validateArg = function (value, label, {\n  assert,\n  message\n}) {\n  if (exports.isSchema(assert)) {\n    const result = assert.validate(value);\n\n    if (!result.error) {\n      return;\n    }\n\n    return result.error.message;\n  } else if (!assert(value)) {\n    return label ? `${label} ${message}` : message;\n  }\n};\n\nexports.verifyFlat = function (args, method) {\n  for (const arg of args) {\n    Assert(!Array.isArray(arg), 'Method no longer accepts array arguments:', method);\n  }\n};","map":{"version":3,"sources":["C:/scripting/jobs assignments/whist/backend/node_modules/joi/lib/common.js"],"names":["Assert","require","AssertError","Pkg","Messages","Schemas","internals","isoDate","exports","version","defaults","abortEarly","allowUnknown","artifacts","cache","context","convert","dateFormat","errors","escapeHtml","label","language","render","stack","wrap","array","externals","messages","nonEnumerables","noDefaults","presence","skipFunctions","stripUnknown","warnings","symbols","any","Symbol","for","arraySingle","deepDefault","literal","override","parent","prefs","ref","template","values","assertOptions","options","keys","name","Array","isArray","unknownKeys","Object","filter","k","includes","length","checkPreferences","result","preferences","validate","error","details","message","compare","a","b","operator","default","value","defaultValue","undefined","isIsoDate","date","test","isNumber","isNaN","isResolvable","obj","isSchema","schema","legacy","isValues","limit","Number","isSafeInteger","target","source","merged","assign","compile","tryWithPath","fn","key","err","path","append","validateArg","assert","verifyFlat","args","method","arg"],"mappings":"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","sourcesContent":["'use strict';\n\nconst Assert = require('@hapi/hoek/lib/assert');\nconst AssertError = require('@hapi/hoek/lib/error');\n\nconst Pkg = require('../package.json');\n\nlet Messages;\nlet Schemas;\n\n\nconst internals = {\n    isoDate: /^(?:[-+]\\d{2})?(?:\\d{4}(?!\\d{2}\\b))(?:(-?)(?:(?:0[1-9]|1[0-2])(?:\\1(?:[12]\\d|0[1-9]|3[01]))?|W(?:[0-4]\\d|5[0-2])(?:-?[1-7])?|(?:00[1-9]|0[1-9]\\d|[12]\\d{2}|3(?:[0-5]\\d|6[1-6])))(?![T]$|[T][\\d]+Z$)(?:[T\\s](?:(?:(?:[01]\\d|2[0-3])(?:(:?)[0-5]\\d)?|24\\:?00)(?:[.,]\\d+(?!:))?)(?:\\2[0-5]\\d(?:[.,]\\d+)?)?(?:[Z]|(?:[+-])(?:[01]\\d|2[0-3])(?::?[0-5]\\d)?)?)?)?$/\n};\n\n\nexports.version = Pkg.version;\n\n\nexports.defaults = {\n    abortEarly: true,\n    allowUnknown: false,\n    artifacts: false,\n    cache: true,\n    context: null,\n    convert: true,\n    dateFormat: 'iso',\n    errors: {\n        escapeHtml: false,\n        label: 'path',\n        language: null,\n        render: true,\n        stack: false,\n        wrap: {\n            label: '\"',\n            array: '[]'\n        }\n    },\n    externals: true,\n    messages: {},\n    nonEnumerables: false,\n    noDefaults: false,\n    presence: 'optional',\n    skipFunctions: false,\n    stripUnknown: false,\n    warnings: false\n};\n\n\nexports.symbols = {\n    any: Symbol.for('@hapi/joi/schema'),            // Used to internally identify any-based types (shared with other joi versions)\n    arraySingle: Symbol('arraySingle'),\n    deepDefault: Symbol('deepDefault'),\n    errors: Symbol('errors'),\n    literal: Symbol('literal'),\n    override: Symbol('override'),\n    parent: Symbol('parent'),\n    prefs: Symbol('prefs'),\n    ref: Symbol('ref'),\n    template: Symbol('template'),\n    values: Symbol('values')\n};\n\n\nexports.assertOptions = function (options, keys, name = 'Options') {\n\n    Assert(options && typeof options === 'object' && !Array.isArray(options), 'Options must be of type object');\n    const unknownKeys = Object.keys(options).filter((k) => !keys.includes(k));\n    Assert(unknownKeys.length === 0, `${name} contain unknown keys: ${unknownKeys}`);\n};\n\n\nexports.checkPreferences = function (prefs) {\n\n    Schemas = Schemas || require('./schemas');\n\n    const result = Schemas.preferences.validate(prefs);\n\n    if (result.error) {\n        throw new AssertError([result.error.details[0].message]);\n    }\n};\n\n\nexports.compare = function (a, b, operator) {\n\n    switch (operator) {\n        case '=': return a === b;\n        case '>': return a > b;\n        case '<': return a < b;\n        case '>=': return a >= b;\n        case '<=': return a <= b;\n    }\n};\n\n\nexports.default = function (value, defaultValue) {\n\n    return value === undefined ? defaultValue : value;\n};\n\n\nexports.isIsoDate = function (date) {\n\n    return internals.isoDate.test(date);\n};\n\n\nexports.isNumber = function (value) {\n\n    return typeof value === 'number' && !isNaN(value);\n};\n\n\nexports.isResolvable = function (obj) {\n\n    if (!obj) {\n        return false;\n    }\n\n    return obj[exports.symbols.ref] || obj[exports.symbols.template];\n};\n\n\nexports.isSchema = function (schema, options = {}) {\n\n    const any = schema && schema[exports.symbols.any];\n    if (!any) {\n        return false;\n    }\n\n    Assert(options.legacy || any.version === exports.version, 'Cannot mix different versions of joi schemas');\n    return true;\n};\n\n\nexports.isValues = function (obj) {\n\n    return obj[exports.symbols.values];\n};\n\n\nexports.limit = function (value) {\n\n    return Number.isSafeInteger(value) && value >= 0;\n};\n\n\nexports.preferences = function (target, source) {\n\n    Messages = Messages || require('./messages');\n\n    target = target || {};\n    source = source || {};\n\n    const merged = Object.assign({}, target, source);\n    if (source.errors &&\n        target.errors) {\n\n        merged.errors = Object.assign({}, target.errors, source.errors);\n        merged.errors.wrap = Object.assign({}, target.errors.wrap, source.errors.wrap);\n    }\n\n    if (source.messages) {\n        merged.messages = Messages.compile(source.messages, target.messages);\n    }\n\n    delete merged[exports.symbols.prefs];\n    return merged;\n};\n\n\nexports.tryWithPath = function (fn, key, options = {}) {\n\n    try {\n        return fn();\n    }\n    catch (err) {\n        if (err.path !== undefined) {\n            err.path = key + '.' + err.path;\n        }\n        else {\n            err.path = key;\n        }\n\n        if (options.append) {\n            err.message = `${err.message} (${err.path})`;\n        }\n\n        throw err;\n    }\n};\n\n\nexports.validateArg = function (value, label, { assert, message }) {\n\n    if (exports.isSchema(assert)) {\n        const result = assert.validate(value);\n        if (!result.error) {\n            return;\n        }\n\n        return result.error.message;\n    }\n    else if (!assert(value)) {\n        return label ? `${label} ${message}` : message;\n    }\n};\n\n\nexports.verifyFlat = function (args, method) {\n\n    for (const arg of args) {\n        Assert(!Array.isArray(arg), 'Method no longer accepts array arguments:', method);\n    }\n};\n"]},"metadata":{},"sourceType":"script"}