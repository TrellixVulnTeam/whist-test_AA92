{"ast":null,"code":"'use strict';\n\nconst Assert = require('@hapi/hoek/lib/assert');\n\nconst Clone = require('@hapi/hoek/lib/clone');\n\nconst Reach = require('@hapi/hoek/lib/reach');\n\nconst Common = require('./common');\n\nlet Template;\nconst internals = {\n  symbol: Symbol('ref'),\n  // Used to internally identify references (shared with other joi versions)\n  defaults: {\n    adjust: null,\n    in: false,\n    iterables: null,\n    map: null,\n    separator: '.',\n    type: 'value'\n  }\n};\n\nexports.create = function (key, options = {}) {\n  Assert(typeof key === 'string', 'Invalid reference key:', key);\n  Common.assertOptions(options, ['adjust', 'ancestor', 'in', 'iterables', 'map', 'prefix', 'render', 'separator']);\n  Assert(!options.prefix || typeof options.prefix === 'object', 'options.prefix must be of type object');\n  const ref = Object.assign({}, internals.defaults, options);\n  delete ref.prefix;\n  const separator = ref.separator;\n  const context = internals.context(key, separator, options.prefix);\n  ref.type = context.type;\n  key = context.key;\n\n  if (ref.type === 'value') {\n    if (context.root) {\n      Assert(!separator || key[0] !== separator, 'Cannot specify relative path with root prefix');\n      ref.ancestor = 'root';\n\n      if (!key) {\n        key = null;\n      }\n    }\n\n    if (separator && separator === key) {\n      key = null;\n      ref.ancestor = 0;\n    } else {\n      if (ref.ancestor !== undefined) {\n        Assert(!separator || !key || key[0] !== separator, 'Cannot combine prefix with ancestor option');\n      } else {\n        const [ancestor, slice] = internals.ancestor(key, separator);\n\n        if (slice) {\n          key = key.slice(slice);\n\n          if (key === '') {\n            key = null;\n          }\n        }\n\n        ref.ancestor = ancestor;\n      }\n    }\n  }\n\n  ref.path = separator ? key === null ? [] : key.split(separator) : [key];\n  return new internals.Ref(ref);\n};\n\nexports.in = function (key, options = {}) {\n  return exports.create(key, { ...options,\n    in: true\n  });\n};\n\nexports.isRef = function (ref) {\n  return ref ? !!ref[Common.symbols.ref] : false;\n};\n\ninternals.Ref = class {\n  constructor(options) {\n    Assert(typeof options === 'object', 'Invalid reference construction');\n    Common.assertOptions(options, ['adjust', 'ancestor', 'in', 'iterables', 'map', 'path', 'render', 'separator', 'type', // Copied\n    'depth', 'key', 'root', 'display' // Overridden\n    ]);\n    Assert([false, undefined].includes(options.separator) || typeof options.separator === 'string' && options.separator.length === 1, 'Invalid separator');\n    Assert(!options.adjust || typeof options.adjust === 'function', 'options.adjust must be a function');\n    Assert(!options.map || Array.isArray(options.map), 'options.map must be an array');\n    Assert(!options.map || !options.adjust, 'Cannot set both map and adjust options');\n    Object.assign(this, internals.defaults, options);\n    Assert(this.type === 'value' || this.ancestor === undefined, 'Non-value references cannot reference ancestors');\n\n    if (Array.isArray(this.map)) {\n      this.map = new Map(this.map);\n    }\n\n    this.depth = this.path.length;\n    this.key = this.path.length ? this.path.join(this.separator) : null;\n    this.root = this.path[0];\n    this.updateDisplay();\n  }\n\n  resolve(value, state, prefs, local, options = {}) {\n    Assert(!this.in || options.in, 'Invalid in() reference usage');\n\n    if (this.type === 'global') {\n      return this._resolve(prefs.context, state, options);\n    }\n\n    if (this.type === 'local') {\n      return this._resolve(local, state, options);\n    }\n\n    if (!this.ancestor) {\n      return this._resolve(value, state, options);\n    }\n\n    if (this.ancestor === 'root') {\n      return this._resolve(state.ancestors[state.ancestors.length - 1], state, options);\n    }\n\n    Assert(this.ancestor <= state.ancestors.length, 'Invalid reference exceeds the schema root:', this.display);\n    return this._resolve(state.ancestors[this.ancestor - 1], state, options);\n  }\n\n  _resolve(target, state, options) {\n    let resolved;\n\n    if (this.type === 'value' && state.mainstay.shadow && options.shadow !== false) {\n      resolved = state.mainstay.shadow.get(this.absolute(state));\n    }\n\n    if (resolved === undefined) {\n      resolved = Reach(target, this.path, {\n        iterables: this.iterables,\n        functions: true\n      });\n    }\n\n    if (this.adjust) {\n      resolved = this.adjust(resolved);\n    }\n\n    if (this.map) {\n      const mapped = this.map.get(resolved);\n\n      if (mapped !== undefined) {\n        resolved = mapped;\n      }\n    }\n\n    if (state.mainstay) {\n      state.mainstay.tracer.resolve(state, this, resolved);\n    }\n\n    return resolved;\n  }\n\n  toString() {\n    return this.display;\n  }\n\n  absolute(state) {\n    return [...state.path.slice(0, -this.ancestor), ...this.path];\n  }\n\n  clone() {\n    return new internals.Ref(this);\n  }\n\n  describe() {\n    const ref = {\n      path: this.path\n    };\n\n    if (this.type !== 'value') {\n      ref.type = this.type;\n    }\n\n    if (this.separator !== '.') {\n      ref.separator = this.separator;\n    }\n\n    if (this.type === 'value' && this.ancestor !== 1) {\n      ref.ancestor = this.ancestor;\n    }\n\n    if (this.map) {\n      ref.map = [...this.map];\n    }\n\n    for (const key of ['adjust', 'iterables', 'render']) {\n      if (this[key] !== null && this[key] !== undefined) {\n        ref[key] = this[key];\n      }\n    }\n\n    if (this.in !== false) {\n      ref.in = true;\n    }\n\n    return {\n      ref\n    };\n  }\n\n  updateDisplay() {\n    const key = this.key !== null ? this.key : '';\n\n    if (this.type !== 'value') {\n      this.display = `ref:${this.type}:${key}`;\n      return;\n    }\n\n    if (!this.separator) {\n      this.display = `ref:${key}`;\n      return;\n    }\n\n    if (!this.ancestor) {\n      this.display = `ref:${this.separator}${key}`;\n      return;\n    }\n\n    if (this.ancestor === 'root') {\n      this.display = `ref:root:${key}`;\n      return;\n    }\n\n    if (this.ancestor === 1) {\n      this.display = `ref:${key || '..'}`;\n      return;\n    }\n\n    const lead = new Array(this.ancestor + 1).fill(this.separator).join('');\n    this.display = `ref:${lead}${key || ''}`;\n  }\n\n};\ninternals.Ref.prototype[Common.symbols.ref] = true;\n\nexports.build = function (desc) {\n  desc = Object.assign({}, internals.defaults, desc);\n\n  if (desc.type === 'value' && desc.ancestor === undefined) {\n    desc.ancestor = 1;\n  }\n\n  return new internals.Ref(desc);\n};\n\ninternals.context = function (key, separator, prefix = {}) {\n  key = key.trim();\n\n  if (prefix) {\n    const globalp = prefix.global === undefined ? '$' : prefix.global;\n\n    if (globalp !== separator && key.startsWith(globalp)) {\n      return {\n        key: key.slice(globalp.length),\n        type: 'global'\n      };\n    }\n\n    const local = prefix.local === undefined ? '#' : prefix.local;\n\n    if (local !== separator && key.startsWith(local)) {\n      return {\n        key: key.slice(local.length),\n        type: 'local'\n      };\n    }\n\n    const root = prefix.root === undefined ? '/' : prefix.root;\n\n    if (root !== separator && key.startsWith(root)) {\n      return {\n        key: key.slice(root.length),\n        type: 'value',\n        root: true\n      };\n    }\n  }\n\n  return {\n    key,\n    type: 'value'\n  };\n};\n\ninternals.ancestor = function (key, separator) {\n  if (!separator) {\n    return [1, 0]; // 'a_b' -> 1 (parent)\n  }\n\n  if (key[0] !== separator) {\n    // 'a.b' -> 1 (parent)\n    return [1, 0];\n  }\n\n  if (key[1] !== separator) {\n    // '.a.b' -> 0 (self)\n    return [0, 1];\n  }\n\n  let i = 2;\n\n  while (key[i] === separator) {\n    ++i;\n  }\n\n  return [i - 1, i]; // '...a.b.' -> 2 (grandparent)\n};\n\nexports.toSibling = 0;\nexports.toParent = 1;\nexports.Manager = class {\n  constructor() {\n    this.refs = []; // 0: [self refs], 1: [parent refs], 2: [grandparent refs], ...\n  }\n\n  register(source, target) {\n    if (!source) {\n      return;\n    }\n\n    target = target === undefined ? exports.toParent : target; // Array\n\n    if (Array.isArray(source)) {\n      for (const ref of source) {\n        this.register(ref, target);\n      }\n\n      return;\n    } // Schema\n\n\n    if (Common.isSchema(source)) {\n      for (const item of source._refs.refs) {\n        if (item.ancestor - target >= 0) {\n          this.refs.push({\n            ancestor: item.ancestor - target,\n            root: item.root\n          });\n        }\n      }\n\n      return;\n    } // Reference\n\n\n    if (exports.isRef(source) && source.type === 'value' && source.ancestor - target >= 0) {\n      this.refs.push({\n        ancestor: source.ancestor - target,\n        root: source.root\n      });\n    } // Template\n\n\n    Template = Template || require('./template');\n\n    if (Template.isTemplate(source)) {\n      this.register(source.refs(), target);\n    }\n  }\n\n  get length() {\n    return this.refs.length;\n  }\n\n  clone() {\n    const copy = new exports.Manager();\n    copy.refs = Clone(this.refs);\n    return copy;\n  }\n\n  reset() {\n    this.refs = [];\n  }\n\n  roots() {\n    return this.refs.filter(ref => !ref.ancestor).map(ref => ref.root);\n  }\n\n};","map":{"version":3,"sources":["C:/scripting/jobs assignments/whist/backend/node_modules/joi/lib/ref.js"],"names":["Assert","require","Clone","Reach","Common","Template","internals","symbol","Symbol","defaults","adjust","in","iterables","map","separator","type","exports","create","key","options","assertOptions","prefix","ref","Object","assign","context","root","ancestor","undefined","slice","path","split","Ref","isRef","symbols","constructor","includes","length","Array","isArray","Map","depth","join","updateDisplay","resolve","value","state","prefs","local","_resolve","ancestors","display","target","resolved","mainstay","shadow","get","absolute","functions","mapped","tracer","toString","clone","describe","lead","fill","prototype","build","desc","trim","globalp","global","startsWith","i","toSibling","toParent","Manager","refs","register","source","isSchema","item","_refs","push","isTemplate","copy","reset","roots","filter"],"mappings":"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","sourcesContent":["'use strict';\n\nconst Assert = require('@hapi/hoek/lib/assert');\nconst Clone = require('@hapi/hoek/lib/clone');\nconst Reach = require('@hapi/hoek/lib/reach');\n\nconst Common = require('./common');\n\nlet Template;\n\n\nconst internals = {\n    symbol: Symbol('ref'),      // Used to internally identify references (shared with other joi versions)\n    defaults: {\n        adjust: null,\n        in: false,\n        iterables: null,\n        map: null,\n        separator: '.',\n        type: 'value'\n    }\n};\n\n\nexports.create = function (key, options = {}) {\n\n    Assert(typeof key === 'string', 'Invalid reference key:', key);\n    Common.assertOptions(options, ['adjust', 'ancestor', 'in', 'iterables', 'map', 'prefix', 'render', 'separator']);\n    Assert(!options.prefix || typeof options.prefix === 'object', 'options.prefix must be of type object');\n\n    const ref = Object.assign({}, internals.defaults, options);\n    delete ref.prefix;\n\n    const separator = ref.separator;\n    const context = internals.context(key, separator, options.prefix);\n    ref.type = context.type;\n    key = context.key;\n\n    if (ref.type === 'value') {\n        if (context.root) {\n            Assert(!separator || key[0] !== separator, 'Cannot specify relative path with root prefix');\n            ref.ancestor = 'root';\n            if (!key) {\n                key = null;\n            }\n        }\n\n        if (separator &&\n            separator === key) {\n\n            key = null;\n            ref.ancestor = 0;\n        }\n        else {\n            if (ref.ancestor !== undefined) {\n                Assert(!separator || !key || key[0] !== separator, 'Cannot combine prefix with ancestor option');\n            }\n            else {\n                const [ancestor, slice] = internals.ancestor(key, separator);\n                if (slice) {\n                    key = key.slice(slice);\n                    if (key === '') {\n                        key = null;\n                    }\n                }\n\n                ref.ancestor = ancestor;\n            }\n        }\n    }\n\n    ref.path = separator ? (key === null ? [] : key.split(separator)) : [key];\n\n    return new internals.Ref(ref);\n};\n\n\nexports.in = function (key, options = {}) {\n\n    return exports.create(key, { ...options, in: true });\n};\n\n\nexports.isRef = function (ref) {\n\n    return ref ? !!ref[Common.symbols.ref] : false;\n};\n\n\ninternals.Ref = class {\n\n    constructor(options) {\n\n        Assert(typeof options === 'object', 'Invalid reference construction');\n        Common.assertOptions(options, [\n            'adjust', 'ancestor', 'in', 'iterables', 'map', 'path', 'render', 'separator', 'type',  // Copied\n            'depth', 'key', 'root', 'display'                                                       // Overridden\n        ]);\n\n        Assert([false, undefined].includes(options.separator) || typeof options.separator === 'string' && options.separator.length === 1, 'Invalid separator');\n        Assert(!options.adjust || typeof options.adjust === 'function', 'options.adjust must be a function');\n        Assert(!options.map || Array.isArray(options.map), 'options.map must be an array');\n        Assert(!options.map || !options.adjust, 'Cannot set both map and adjust options');\n\n        Object.assign(this, internals.defaults, options);\n\n        Assert(this.type === 'value' || this.ancestor === undefined, 'Non-value references cannot reference ancestors');\n\n        if (Array.isArray(this.map)) {\n            this.map = new Map(this.map);\n        }\n\n        this.depth = this.path.length;\n        this.key = this.path.length ? this.path.join(this.separator) : null;\n        this.root = this.path[0];\n\n        this.updateDisplay();\n    }\n\n    resolve(value, state, prefs, local, options = {}) {\n\n        Assert(!this.in || options.in, 'Invalid in() reference usage');\n\n        if (this.type === 'global') {\n            return this._resolve(prefs.context, state, options);\n        }\n\n        if (this.type === 'local') {\n            return this._resolve(local, state, options);\n        }\n\n        if (!this.ancestor) {\n            return this._resolve(value, state, options);\n        }\n\n        if (this.ancestor === 'root') {\n            return this._resolve(state.ancestors[state.ancestors.length - 1], state, options);\n        }\n\n        Assert(this.ancestor <= state.ancestors.length, 'Invalid reference exceeds the schema root:', this.display);\n        return this._resolve(state.ancestors[this.ancestor - 1], state, options);\n    }\n\n    _resolve(target, state, options) {\n\n        let resolved;\n\n        if (this.type === 'value' &&\n            state.mainstay.shadow &&\n            options.shadow !== false) {\n\n            resolved = state.mainstay.shadow.get(this.absolute(state));\n        }\n\n        if (resolved === undefined) {\n            resolved = Reach(target, this.path, { iterables: this.iterables, functions: true });\n        }\n\n        if (this.adjust) {\n            resolved = this.adjust(resolved);\n        }\n\n        if (this.map) {\n            const mapped = this.map.get(resolved);\n            if (mapped !== undefined) {\n                resolved = mapped;\n            }\n        }\n\n        if (state.mainstay) {\n            state.mainstay.tracer.resolve(state, this, resolved);\n        }\n\n        return resolved;\n    }\n\n    toString() {\n\n        return this.display;\n    }\n\n    absolute(state) {\n\n        return [...state.path.slice(0, -this.ancestor), ...this.path];\n    }\n\n    clone() {\n\n        return new internals.Ref(this);\n    }\n\n    describe() {\n\n        const ref = { path: this.path };\n\n        if (this.type !== 'value') {\n            ref.type = this.type;\n        }\n\n        if (this.separator !== '.') {\n            ref.separator = this.separator;\n        }\n\n        if (this.type === 'value' &&\n            this.ancestor !== 1) {\n\n            ref.ancestor = this.ancestor;\n        }\n\n        if (this.map) {\n            ref.map = [...this.map];\n        }\n\n        for (const key of ['adjust', 'iterables', 'render']) {\n            if (this[key] !== null &&\n                this[key] !== undefined) {\n\n                ref[key] = this[key];\n            }\n        }\n\n        if (this.in !== false) {\n            ref.in = true;\n        }\n\n        return { ref };\n    }\n\n    updateDisplay() {\n\n        const key = this.key !== null ? this.key : '';\n        if (this.type !== 'value') {\n            this.display = `ref:${this.type}:${key}`;\n            return;\n        }\n\n        if (!this.separator) {\n            this.display = `ref:${key}`;\n            return;\n        }\n\n        if (!this.ancestor) {\n            this.display = `ref:${this.separator}${key}`;\n            return;\n        }\n\n        if (this.ancestor === 'root') {\n            this.display = `ref:root:${key}`;\n            return;\n        }\n\n        if (this.ancestor === 1) {\n            this.display = `ref:${key || '..'}`;\n            return;\n        }\n\n        const lead = new Array(this.ancestor + 1).fill(this.separator).join('');\n        this.display = `ref:${lead}${key || ''}`;\n    }\n};\n\n\ninternals.Ref.prototype[Common.symbols.ref] = true;\n\n\nexports.build = function (desc) {\n\n    desc = Object.assign({}, internals.defaults, desc);\n    if (desc.type === 'value' &&\n        desc.ancestor === undefined) {\n\n        desc.ancestor = 1;\n    }\n\n    return new internals.Ref(desc);\n};\n\n\ninternals.context = function (key, separator, prefix = {}) {\n\n    key = key.trim();\n\n    if (prefix) {\n        const globalp = prefix.global === undefined ? '$' : prefix.global;\n        if (globalp !== separator &&\n            key.startsWith(globalp)) {\n\n            return { key: key.slice(globalp.length), type: 'global' };\n        }\n\n        const local = prefix.local === undefined ? '#' : prefix.local;\n        if (local !== separator &&\n            key.startsWith(local)) {\n\n            return { key: key.slice(local.length), type: 'local' };\n        }\n\n        const root = prefix.root === undefined ? '/' : prefix.root;\n        if (root !== separator &&\n            key.startsWith(root)) {\n\n            return { key: key.slice(root.length), type: 'value', root: true };\n        }\n    }\n\n    return { key, type: 'value' };\n};\n\n\ninternals.ancestor = function (key, separator) {\n\n    if (!separator) {\n        return [1, 0];              // 'a_b' -> 1 (parent)\n    }\n\n    if (key[0] !== separator) {     // 'a.b' -> 1 (parent)\n        return [1, 0];\n    }\n\n    if (key[1] !== separator) {     // '.a.b' -> 0 (self)\n        return [0, 1];\n    }\n\n    let i = 2;\n    while (key[i] === separator) {\n        ++i;\n    }\n\n    return [i - 1, i];              // '...a.b.' -> 2 (grandparent)\n};\n\n\nexports.toSibling = 0;\n\nexports.toParent = 1;\n\n\nexports.Manager = class {\n\n    constructor() {\n\n        this.refs = [];                     // 0: [self refs], 1: [parent refs], 2: [grandparent refs], ...\n    }\n\n    register(source, target) {\n\n        if (!source) {\n            return;\n        }\n\n        target = target === undefined ? exports.toParent : target;\n\n        // Array\n\n        if (Array.isArray(source)) {\n            for (const ref of source) {\n                this.register(ref, target);\n            }\n\n            return;\n        }\n\n        // Schema\n\n        if (Common.isSchema(source)) {\n            for (const item of source._refs.refs) {\n                if (item.ancestor - target >= 0) {\n                    this.refs.push({ ancestor: item.ancestor - target, root: item.root });\n                }\n            }\n\n            return;\n        }\n\n        // Reference\n\n        if (exports.isRef(source) &&\n            source.type === 'value' &&\n            source.ancestor - target >= 0) {\n\n            this.refs.push({ ancestor: source.ancestor - target, root: source.root });\n        }\n\n        // Template\n\n        Template = Template || require('./template');\n\n        if (Template.isTemplate(source)) {\n            this.register(source.refs(), target);\n        }\n    }\n\n    get length() {\n\n        return this.refs.length;\n    }\n\n    clone() {\n\n        const copy = new exports.Manager();\n        copy.refs = Clone(this.refs);\n        return copy;\n    }\n\n    reset() {\n\n        this.refs = [];\n    }\n\n    roots() {\n\n        return this.refs.filter((ref) => !ref.ancestor).map((ref) => ref.root);\n    }\n};\n"]},"metadata":{},"sourceType":"script"}