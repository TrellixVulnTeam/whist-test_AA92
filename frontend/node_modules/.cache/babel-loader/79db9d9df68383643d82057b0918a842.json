{"ast":null,"code":"'use strict';\n\nconst Assert = require('@hapi/hoek/lib/assert');\n\nconst Any = require('./any');\n\nconst Common = require('../common');\n\nconst Template = require('../template');\n\nconst internals = {};\n\ninternals.isDate = function (value) {\n  return value instanceof Date;\n};\n\nmodule.exports = Any.extend({\n  type: 'date',\n  coerce: {\n    from: ['number', 'string'],\n\n    method(value, {\n      schema\n    }) {\n      return {\n        value: internals.parse(value, schema._flags.format) || value\n      };\n    }\n\n  },\n\n  validate(value, {\n    schema,\n    error,\n    prefs\n  }) {\n    if (value instanceof Date && !isNaN(value.getTime())) {\n      return;\n    }\n\n    const format = schema._flags.format;\n\n    if (!prefs.convert || !format || typeof value !== 'string') {\n      return {\n        value,\n        errors: error('date.base')\n      };\n    }\n\n    return {\n      value,\n      errors: error('date.format', {\n        format\n      })\n    };\n  },\n\n  rules: {\n    compare: {\n      method: false,\n\n      validate(value, helpers, {\n        date\n      }, {\n        name,\n        operator,\n        args\n      }) {\n        const to = date === 'now' ? Date.now() : date.getTime();\n\n        if (Common.compare(value.getTime(), to, operator)) {\n          return value;\n        }\n\n        return helpers.error('date.' + name, {\n          limit: args.date,\n          value\n        });\n      },\n\n      args: [{\n        name: 'date',\n        ref: true,\n        normalize: date => {\n          return date === 'now' ? date : internals.parse(date);\n        },\n        assert: date => date !== null,\n        message: 'must have a valid date format'\n      }]\n    },\n    format: {\n      method(format) {\n        Assert(['iso', 'javascript', 'unix'].includes(format), 'Unknown date format', format);\n        return this.$_setFlag('format', format);\n      }\n\n    },\n    greater: {\n      method(date) {\n        return this.$_addRule({\n          name: 'greater',\n          method: 'compare',\n          args: {\n            date\n          },\n          operator: '>'\n        });\n      }\n\n    },\n    iso: {\n      method() {\n        return this.format('iso');\n      }\n\n    },\n    less: {\n      method(date) {\n        return this.$_addRule({\n          name: 'less',\n          method: 'compare',\n          args: {\n            date\n          },\n          operator: '<'\n        });\n      }\n\n    },\n    max: {\n      method(date) {\n        return this.$_addRule({\n          name: 'max',\n          method: 'compare',\n          args: {\n            date\n          },\n          operator: '<='\n        });\n      }\n\n    },\n    min: {\n      method(date) {\n        return this.$_addRule({\n          name: 'min',\n          method: 'compare',\n          args: {\n            date\n          },\n          operator: '>='\n        });\n      }\n\n    },\n    timestamp: {\n      method(type = 'javascript') {\n        Assert(['javascript', 'unix'].includes(type), '\"type\" must be one of \"javascript, unix\"');\n        return this.format(type);\n      }\n\n    }\n  },\n  cast: {\n    number: {\n      from: internals.isDate,\n\n      to(value, helpers) {\n        return value.getTime();\n      }\n\n    },\n    string: {\n      from: internals.isDate,\n\n      to(value, {\n        prefs\n      }) {\n        return Template.date(value, prefs);\n      }\n\n    }\n  },\n  messages: {\n    'date.base': '{{#label}} must be a valid date',\n    'date.format': '{{#label}} must be in {msg(\"date.format.\" + #format) || #format} format',\n    'date.greater': '{{#label}} must be greater than {{:#limit}}',\n    'date.less': '{{#label}} must be less than {{:#limit}}',\n    'date.max': '{{#label}} must be less than or equal to {{:#limit}}',\n    'date.min': '{{#label}} must be greater than or equal to {{:#limit}}',\n    // Messages used in date.format\n    'date.format.iso': 'ISO 8601 date',\n    'date.format.javascript': 'timestamp or number of milliseconds',\n    'date.format.unix': 'timestamp or number of seconds'\n  }\n}); // Helpers\n\ninternals.parse = function (value, format) {\n  if (value instanceof Date) {\n    return value;\n  }\n\n  if (typeof value !== 'string' && (isNaN(value) || !isFinite(value))) {\n    return null;\n  }\n\n  if (/^\\s*$/.test(value)) {\n    return null;\n  } // ISO\n\n\n  if (format === 'iso') {\n    if (!Common.isIsoDate(value)) {\n      return null;\n    }\n\n    return internals.date(value.toString());\n  } // Normalize number string\n\n\n  const original = value;\n\n  if (typeof value === 'string' && /^[+-]?\\d+(\\.\\d+)?$/.test(value)) {\n    value = parseFloat(value);\n  } // Timestamp\n\n\n  if (format) {\n    if (format === 'javascript') {\n      return internals.date(1 * value); // Casting to number\n    }\n\n    if (format === 'unix') {\n      return internals.date(1000 * value);\n    }\n\n    if (typeof original === 'string') {\n      return null;\n    }\n  } // Plain\n\n\n  return internals.date(value);\n};\n\ninternals.date = function (value) {\n  const date = new Date(value);\n\n  if (!isNaN(date.getTime())) {\n    return date;\n  }\n\n  return null;\n};","map":{"version":3,"sources":["C:/scripting/jobs assignments/whist/backend/node_modules/joi/lib/types/date.js"],"names":["Assert","require","Any","Common","Template","internals","isDate","value","Date","module","exports","extend","type","coerce","from","method","schema","parse","_flags","format","validate","error","prefs","isNaN","getTime","convert","errors","rules","compare","helpers","date","name","operator","args","to","now","limit","ref","normalize","assert","message","includes","$_setFlag","greater","$_addRule","iso","less","max","min","timestamp","cast","number","string","messages","isFinite","test","isIsoDate","toString","original","parseFloat"],"mappings":"AAAA;;AAEA,MAAMA,MAAM,GAAGC,OAAO,CAAC,uBAAD,CAAtB;;AAEA,MAAMC,GAAG,GAAGD,OAAO,CAAC,OAAD,CAAnB;;AACA,MAAME,MAAM,GAAGF,OAAO,CAAC,WAAD,CAAtB;;AACA,MAAMG,QAAQ,GAAGH,OAAO,CAAC,aAAD,CAAxB;;AAGA,MAAMI,SAAS,GAAG,EAAlB;;AAGAA,SAAS,CAACC,MAAV,GAAmB,UAAUC,KAAV,EAAiB;AAEhC,SAAOA,KAAK,YAAYC,IAAxB;AACH,CAHD;;AAMAC,MAAM,CAACC,OAAP,GAAiBR,GAAG,CAACS,MAAJ,CAAW;AAExBC,EAAAA,IAAI,EAAE,MAFkB;AAIxBC,EAAAA,MAAM,EAAE;AACJC,IAAAA,IAAI,EAAE,CAAC,QAAD,EAAW,QAAX,CADF;;AAEJC,IAAAA,MAAM,CAACR,KAAD,EAAQ;AAAES,MAAAA;AAAF,KAAR,EAAoB;AAEtB,aAAO;AAAET,QAAAA,KAAK,EAAEF,SAAS,CAACY,KAAV,CAAgBV,KAAhB,EAAuBS,MAAM,CAACE,MAAP,CAAcC,MAArC,KAAgDZ;AAAzD,OAAP;AACH;;AALG,GAJgB;;AAYxBa,EAAAA,QAAQ,CAACb,KAAD,EAAQ;AAAES,IAAAA,MAAF;AAAUK,IAAAA,KAAV;AAAiBC,IAAAA;AAAjB,GAAR,EAAkC;AAEtC,QAAIf,KAAK,YAAYC,IAAjB,IACA,CAACe,KAAK,CAAChB,KAAK,CAACiB,OAAN,EAAD,CADV,EAC6B;AAEzB;AACH;;AAED,UAAML,MAAM,GAAGH,MAAM,CAACE,MAAP,CAAcC,MAA7B;;AAEA,QAAI,CAACG,KAAK,CAACG,OAAP,IACA,CAACN,MADD,IAEA,OAAOZ,KAAP,KAAiB,QAFrB,EAE+B;AAE3B,aAAO;AAAEA,QAAAA,KAAF;AAASmB,QAAAA,MAAM,EAAEL,KAAK,CAAC,WAAD;AAAtB,OAAP;AACH;;AAED,WAAO;AAAEd,MAAAA,KAAF;AAASmB,MAAAA,MAAM,EAAEL,KAAK,CAAC,aAAD,EAAgB;AAAEF,QAAAA;AAAF,OAAhB;AAAtB,KAAP;AACH,GA9BuB;;AAgCxBQ,EAAAA,KAAK,EAAE;AAEHC,IAAAA,OAAO,EAAE;AACLb,MAAAA,MAAM,EAAE,KADH;;AAELK,MAAAA,QAAQ,CAACb,KAAD,EAAQsB,OAAR,EAAiB;AAAEC,QAAAA;AAAF,OAAjB,EAA2B;AAAEC,QAAAA,IAAF;AAAQC,QAAAA,QAAR;AAAkBC,QAAAA;AAAlB,OAA3B,EAAqD;AAEzD,cAAMC,EAAE,GAAGJ,IAAI,KAAK,KAAT,GAAiBtB,IAAI,CAAC2B,GAAL,EAAjB,GAA8BL,IAAI,CAACN,OAAL,EAAzC;;AACA,YAAIrB,MAAM,CAACyB,OAAP,CAAerB,KAAK,CAACiB,OAAN,EAAf,EAAgCU,EAAhC,EAAoCF,QAApC,CAAJ,EAAmD;AAC/C,iBAAOzB,KAAP;AACH;;AAED,eAAOsB,OAAO,CAACR,KAAR,CAAc,UAAUU,IAAxB,EAA8B;AAAEK,UAAAA,KAAK,EAAEH,IAAI,CAACH,IAAd;AAAoBvB,UAAAA;AAApB,SAA9B,CAAP;AACH,OAVI;;AAWL0B,MAAAA,IAAI,EAAE,CACF;AACIF,QAAAA,IAAI,EAAE,MADV;AAEIM,QAAAA,GAAG,EAAE,IAFT;AAGIC,QAAAA,SAAS,EAAGR,IAAD,IAAU;AAEjB,iBAAOA,IAAI,KAAK,KAAT,GAAiBA,IAAjB,GAAwBzB,SAAS,CAACY,KAAV,CAAgBa,IAAhB,CAA/B;AACH,SANL;AAOIS,QAAAA,MAAM,EAAGT,IAAD,IAAUA,IAAI,KAAK,IAP/B;AAQIU,QAAAA,OAAO,EAAE;AARb,OADE;AAXD,KAFN;AA2BHrB,IAAAA,MAAM,EAAE;AACJJ,MAAAA,MAAM,CAACI,MAAD,EAAS;AAEXnB,QAAAA,MAAM,CAAC,CAAC,KAAD,EAAQ,YAAR,EAAsB,MAAtB,EAA8ByC,QAA9B,CAAuCtB,MAAvC,CAAD,EAAiD,qBAAjD,EAAwEA,MAAxE,CAAN;AAEA,eAAO,KAAKuB,SAAL,CAAe,QAAf,EAAyBvB,MAAzB,CAAP;AACH;;AANG,KA3BL;AAoCHwB,IAAAA,OAAO,EAAE;AACL5B,MAAAA,MAAM,CAACe,IAAD,EAAO;AAET,eAAO,KAAKc,SAAL,CAAe;AAAEb,UAAAA,IAAI,EAAE,SAAR;AAAmBhB,UAAAA,MAAM,EAAE,SAA3B;AAAsCkB,UAAAA,IAAI,EAAE;AAAEH,YAAAA;AAAF,WAA5C;AAAsDE,UAAAA,QAAQ,EAAE;AAAhE,SAAf,CAAP;AACH;;AAJI,KApCN;AA2CHa,IAAAA,GAAG,EAAE;AACD9B,MAAAA,MAAM,GAAG;AAEL,eAAO,KAAKI,MAAL,CAAY,KAAZ,CAAP;AACH;;AAJA,KA3CF;AAkDH2B,IAAAA,IAAI,EAAE;AACF/B,MAAAA,MAAM,CAACe,IAAD,EAAO;AAET,eAAO,KAAKc,SAAL,CAAe;AAAEb,UAAAA,IAAI,EAAE,MAAR;AAAgBhB,UAAAA,MAAM,EAAE,SAAxB;AAAmCkB,UAAAA,IAAI,EAAE;AAAEH,YAAAA;AAAF,WAAzC;AAAmDE,UAAAA,QAAQ,EAAE;AAA7D,SAAf,CAAP;AACH;;AAJC,KAlDH;AAyDHe,IAAAA,GAAG,EAAE;AACDhC,MAAAA,MAAM,CAACe,IAAD,EAAO;AAET,eAAO,KAAKc,SAAL,CAAe;AAAEb,UAAAA,IAAI,EAAE,KAAR;AAAehB,UAAAA,MAAM,EAAE,SAAvB;AAAkCkB,UAAAA,IAAI,EAAE;AAAEH,YAAAA;AAAF,WAAxC;AAAkDE,UAAAA,QAAQ,EAAE;AAA5D,SAAf,CAAP;AACH;;AAJA,KAzDF;AAgEHgB,IAAAA,GAAG,EAAE;AACDjC,MAAAA,MAAM,CAACe,IAAD,EAAO;AAET,eAAO,KAAKc,SAAL,CAAe;AAAEb,UAAAA,IAAI,EAAE,KAAR;AAAehB,UAAAA,MAAM,EAAE,SAAvB;AAAkCkB,UAAAA,IAAI,EAAE;AAAEH,YAAAA;AAAF,WAAxC;AAAkDE,UAAAA,QAAQ,EAAE;AAA5D,SAAf,CAAP;AACH;;AAJA,KAhEF;AAuEHiB,IAAAA,SAAS,EAAE;AACPlC,MAAAA,MAAM,CAACH,IAAI,GAAG,YAAR,EAAsB;AAExBZ,QAAAA,MAAM,CAAC,CAAC,YAAD,EAAe,MAAf,EAAuByC,QAAvB,CAAgC7B,IAAhC,CAAD,EAAwC,0CAAxC,CAAN;AAEA,eAAO,KAAKO,MAAL,CAAYP,IAAZ,CAAP;AACH;;AANM;AAvER,GAhCiB;AAiHxBsC,EAAAA,IAAI,EAAE;AACFC,IAAAA,MAAM,EAAE;AACJrC,MAAAA,IAAI,EAAET,SAAS,CAACC,MADZ;;AAEJ4B,MAAAA,EAAE,CAAC3B,KAAD,EAAQsB,OAAR,EAAiB;AAEf,eAAOtB,KAAK,CAACiB,OAAN,EAAP;AACH;;AALG,KADN;AAQF4B,IAAAA,MAAM,EAAE;AACJtC,MAAAA,IAAI,EAAET,SAAS,CAACC,MADZ;;AAEJ4B,MAAAA,EAAE,CAAC3B,KAAD,EAAQ;AAAEe,QAAAA;AAAF,OAAR,EAAmB;AAEjB,eAAOlB,QAAQ,CAAC0B,IAAT,CAAcvB,KAAd,EAAqBe,KAArB,CAAP;AACH;;AALG;AARN,GAjHkB;AAkIxB+B,EAAAA,QAAQ,EAAE;AACN,iBAAa,iCADP;AAEN,mBAAe,yEAFT;AAGN,oBAAgB,6CAHV;AAIN,iBAAa,0CAJP;AAKN,gBAAY,sDALN;AAMN,gBAAY,yDANN;AAQN;AAEA,uBAAmB,eAVb;AAWN,8BAA0B,qCAXpB;AAYN,wBAAoB;AAZd;AAlIc,CAAX,CAAjB,C,CAmJA;;AAEAhD,SAAS,CAACY,KAAV,GAAkB,UAAUV,KAAV,EAAiBY,MAAjB,EAAyB;AAEvC,MAAIZ,KAAK,YAAYC,IAArB,EAA2B;AACvB,WAAOD,KAAP;AACH;;AAED,MAAI,OAAOA,KAAP,KAAiB,QAAjB,KACCgB,KAAK,CAAChB,KAAD,CAAL,IAAgB,CAAC+C,QAAQ,CAAC/C,KAAD,CAD1B,CAAJ,EACwC;AAEpC,WAAO,IAAP;AACH;;AAED,MAAI,QAAQgD,IAAR,CAAahD,KAAb,CAAJ,EAAyB;AACrB,WAAO,IAAP;AACH,GAdsC,CAgBvC;;;AAEA,MAAIY,MAAM,KAAK,KAAf,EAAsB;AAClB,QAAI,CAAChB,MAAM,CAACqD,SAAP,CAAiBjD,KAAjB,CAAL,EAA8B;AAC1B,aAAO,IAAP;AACH;;AAED,WAAOF,SAAS,CAACyB,IAAV,CAAevB,KAAK,CAACkD,QAAN,EAAf,CAAP;AACH,GAxBsC,CA0BvC;;;AAEA,QAAMC,QAAQ,GAAGnD,KAAjB;;AACA,MAAI,OAAOA,KAAP,KAAiB,QAAjB,IACA,qBAAqBgD,IAArB,CAA0BhD,KAA1B,CADJ,EACsC;AAElCA,IAAAA,KAAK,GAAGoD,UAAU,CAACpD,KAAD,CAAlB;AACH,GAjCsC,CAmCvC;;;AAEA,MAAIY,MAAJ,EAAY;AACR,QAAIA,MAAM,KAAK,YAAf,EAA6B;AACzB,aAAOd,SAAS,CAACyB,IAAV,CAAe,IAAIvB,KAAnB,CAAP,CADyB,CACgB;AAC5C;;AAED,QAAIY,MAAM,KAAK,MAAf,EAAuB;AACnB,aAAOd,SAAS,CAACyB,IAAV,CAAe,OAAOvB,KAAtB,CAAP;AACH;;AAED,QAAI,OAAOmD,QAAP,KAAoB,QAAxB,EAAkC;AAC9B,aAAO,IAAP;AACH;AACJ,GAjDsC,CAmDvC;;;AAEA,SAAOrD,SAAS,CAACyB,IAAV,CAAevB,KAAf,CAAP;AACH,CAtDD;;AAyDAF,SAAS,CAACyB,IAAV,GAAiB,UAAUvB,KAAV,EAAiB;AAE9B,QAAMuB,IAAI,GAAG,IAAItB,IAAJ,CAASD,KAAT,CAAb;;AACA,MAAI,CAACgB,KAAK,CAACO,IAAI,CAACN,OAAL,EAAD,CAAV,EAA4B;AACxB,WAAOM,IAAP;AACH;;AAED,SAAO,IAAP;AACH,CARD","sourcesContent":["'use strict';\n\nconst Assert = require('@hapi/hoek/lib/assert');\n\nconst Any = require('./any');\nconst Common = require('../common');\nconst Template = require('../template');\n\n\nconst internals = {};\n\n\ninternals.isDate = function (value) {\n\n    return value instanceof Date;\n};\n\n\nmodule.exports = Any.extend({\n\n    type: 'date',\n\n    coerce: {\n        from: ['number', 'string'],\n        method(value, { schema }) {\n\n            return { value: internals.parse(value, schema._flags.format) || value };\n        }\n    },\n\n    validate(value, { schema, error, prefs }) {\n\n        if (value instanceof Date &&\n            !isNaN(value.getTime())) {\n\n            return;\n        }\n\n        const format = schema._flags.format;\n\n        if (!prefs.convert ||\n            !format ||\n            typeof value !== 'string') {\n\n            return { value, errors: error('date.base') };\n        }\n\n        return { value, errors: error('date.format', { format }) };\n    },\n\n    rules: {\n\n        compare: {\n            method: false,\n            validate(value, helpers, { date }, { name, operator, args }) {\n\n                const to = date === 'now' ? Date.now() : date.getTime();\n                if (Common.compare(value.getTime(), to, operator)) {\n                    return value;\n                }\n\n                return helpers.error('date.' + name, { limit: args.date, value });\n            },\n            args: [\n                {\n                    name: 'date',\n                    ref: true,\n                    normalize: (date) => {\n\n                        return date === 'now' ? date : internals.parse(date);\n                    },\n                    assert: (date) => date !== null,\n                    message: 'must have a valid date format'\n                }\n            ]\n        },\n\n        format: {\n            method(format) {\n\n                Assert(['iso', 'javascript', 'unix'].includes(format), 'Unknown date format', format);\n\n                return this.$_setFlag('format', format);\n            }\n        },\n\n        greater: {\n            method(date) {\n\n                return this.$_addRule({ name: 'greater', method: 'compare', args: { date }, operator: '>' });\n            }\n        },\n\n        iso: {\n            method() {\n\n                return this.format('iso');\n            }\n        },\n\n        less: {\n            method(date) {\n\n                return this.$_addRule({ name: 'less', method: 'compare', args: { date }, operator: '<' });\n            }\n        },\n\n        max: {\n            method(date) {\n\n                return this.$_addRule({ name: 'max', method: 'compare', args: { date }, operator: '<=' });\n            }\n        },\n\n        min: {\n            method(date) {\n\n                return this.$_addRule({ name: 'min', method: 'compare', args: { date }, operator: '>=' });\n            }\n        },\n\n        timestamp: {\n            method(type = 'javascript') {\n\n                Assert(['javascript', 'unix'].includes(type), '\"type\" must be one of \"javascript, unix\"');\n\n                return this.format(type);\n            }\n        }\n    },\n\n    cast: {\n        number: {\n            from: internals.isDate,\n            to(value, helpers) {\n\n                return value.getTime();\n            }\n        },\n        string: {\n            from: internals.isDate,\n            to(value, { prefs }) {\n\n                return Template.date(value, prefs);\n            }\n        }\n    },\n\n    messages: {\n        'date.base': '{{#label}} must be a valid date',\n        'date.format': '{{#label}} must be in {msg(\"date.format.\" + #format) || #format} format',\n        'date.greater': '{{#label}} must be greater than {{:#limit}}',\n        'date.less': '{{#label}} must be less than {{:#limit}}',\n        'date.max': '{{#label}} must be less than or equal to {{:#limit}}',\n        'date.min': '{{#label}} must be greater than or equal to {{:#limit}}',\n\n        // Messages used in date.format\n\n        'date.format.iso': 'ISO 8601 date',\n        'date.format.javascript': 'timestamp or number of milliseconds',\n        'date.format.unix': 'timestamp or number of seconds'\n    }\n});\n\n\n// Helpers\n\ninternals.parse = function (value, format) {\n\n    if (value instanceof Date) {\n        return value;\n    }\n\n    if (typeof value !== 'string' &&\n        (isNaN(value) || !isFinite(value))) {\n\n        return null;\n    }\n\n    if (/^\\s*$/.test(value)) {\n        return null;\n    }\n\n    // ISO\n\n    if (format === 'iso') {\n        if (!Common.isIsoDate(value)) {\n            return null;\n        }\n\n        return internals.date(value.toString());\n    }\n\n    // Normalize number string\n\n    const original = value;\n    if (typeof value === 'string' &&\n        /^[+-]?\\d+(\\.\\d+)?$/.test(value)) {\n\n        value = parseFloat(value);\n    }\n\n    // Timestamp\n\n    if (format) {\n        if (format === 'javascript') {\n            return internals.date(1 * value);        // Casting to number\n        }\n\n        if (format === 'unix') {\n            return internals.date(1000 * value);\n        }\n\n        if (typeof original === 'string') {\n            return null;\n        }\n    }\n\n    // Plain\n\n    return internals.date(value);\n};\n\n\ninternals.date = function (value) {\n\n    const date = new Date(value);\n    if (!isNaN(date.getTime())) {\n        return date;\n    }\n\n    return null;\n};\n"]},"metadata":{},"sourceType":"script"}