{"ast":null,"code":"'use strict';\n\nconst internals = {\n  operators: ['!', '^', '*', '/', '%', '+', '-', '<', '<=', '>', '>=', '==', '!=', '&&', '||', '??'],\n  operatorCharacters: ['!', '^', '*', '/', '%', '+', '-', '<', '=', '>', '&', '|', '?'],\n  operatorsOrder: [['^'], ['*', '/', '%'], ['+', '-'], ['<', '<=', '>', '>='], ['==', '!='], ['&&'], ['||', '??']],\n  operatorsPrefix: ['!', 'n'],\n  literals: {\n    '\"': '\"',\n    '`': '`',\n    '\\'': '\\'',\n    '[': ']'\n  },\n  numberRx: /^(?:[0-9]*\\.?[0-9]*){1}$/,\n  tokenRx: /^[\\w\\$\\#\\.\\@\\:\\{\\}]+$/,\n  symbol: Symbol('formula'),\n  settings: Symbol('settings')\n};\nexports.Parser = class {\n  constructor(string, options = {}) {\n    if (!options[internals.settings] && options.constants) {\n      for (const constant in options.constants) {\n        const value = options.constants[constant];\n\n        if (value !== null && !['boolean', 'number', 'string'].includes(typeof value)) {\n          throw new Error(`Formula constant ${constant} contains invalid ${typeof value} value type`);\n        }\n      }\n    }\n\n    this.settings = options[internals.settings] ? options : Object.assign({\n      [internals.settings]: true,\n      constants: {},\n      functions: {}\n    }, options);\n    this.single = null;\n    this._parts = null;\n\n    this._parse(string);\n  }\n\n  _parse(string) {\n    let parts = [];\n    let current = '';\n    let parenthesis = 0;\n    let literal = false;\n\n    const flush = inner => {\n      if (parenthesis) {\n        throw new Error('Formula missing closing parenthesis');\n      }\n\n      const last = parts.length ? parts[parts.length - 1] : null;\n\n      if (!literal && !current && !inner) {\n        return;\n      }\n\n      if (last && last.type === 'reference' && inner === ')') {\n        // Function\n        last.type = 'function';\n        last.value = this._subFormula(current, last.value);\n        current = '';\n        return;\n      }\n\n      if (inner === ')') {\n        // Segment\n        const sub = new exports.Parser(current, this.settings);\n        parts.push({\n          type: 'segment',\n          value: sub\n        });\n      } else if (literal) {\n        if (literal === ']') {\n          // Reference\n          parts.push({\n            type: 'reference',\n            value: current\n          });\n          current = '';\n          return;\n        }\n\n        parts.push({\n          type: 'literal',\n          value: current\n        }); // Literal\n      } else if (internals.operatorCharacters.includes(current)) {\n        // Operator\n        if (last && last.type === 'operator' && internals.operators.includes(last.value + current)) {\n          // 2 characters operator\n          last.value += current;\n        } else {\n          parts.push({\n            type: 'operator',\n            value: current\n          });\n        }\n      } else if (current.match(internals.numberRx)) {\n        // Number\n        parts.push({\n          type: 'constant',\n          value: parseFloat(current)\n        });\n      } else if (this.settings.constants[current] !== undefined) {\n        // Constant\n        parts.push({\n          type: 'constant',\n          value: this.settings.constants[current]\n        });\n      } else {\n        // Reference\n        if (!current.match(internals.tokenRx)) {\n          throw new Error(`Formula contains invalid token: ${current}`);\n        }\n\n        parts.push({\n          type: 'reference',\n          value: current\n        });\n      }\n\n      current = '';\n    };\n\n    for (const c of string) {\n      if (literal) {\n        if (c === literal) {\n          flush();\n          literal = false;\n        } else {\n          current += c;\n        }\n      } else if (parenthesis) {\n        if (c === '(') {\n          current += c;\n          ++parenthesis;\n        } else if (c === ')') {\n          --parenthesis;\n\n          if (!parenthesis) {\n            flush(c);\n          } else {\n            current += c;\n          }\n        } else {\n          current += c;\n        }\n      } else if (c in internals.literals) {\n        literal = internals.literals[c];\n      } else if (c === '(') {\n        flush();\n        ++parenthesis;\n      } else if (internals.operatorCharacters.includes(c)) {\n        flush();\n        current = c;\n        flush();\n      } else if (c !== ' ') {\n        current += c;\n      } else {\n        flush();\n      }\n    }\n\n    flush(); // Replace prefix - to internal negative operator\n\n    parts = parts.map((part, i) => {\n      if (part.type !== 'operator' || part.value !== '-' || i && parts[i - 1].type !== 'operator') {\n        return part;\n      }\n\n      return {\n        type: 'operator',\n        value: 'n'\n      };\n    }); // Validate tokens order\n\n    let operator = false;\n\n    for (const part of parts) {\n      if (part.type === 'operator') {\n        if (internals.operatorsPrefix.includes(part.value)) {\n          continue;\n        }\n\n        if (!operator) {\n          throw new Error('Formula contains an operator in invalid position');\n        }\n\n        if (!internals.operators.includes(part.value)) {\n          throw new Error(`Formula contains an unknown operator ${part.value}`);\n        }\n      } else if (operator) {\n        throw new Error('Formula missing expected operator');\n      }\n\n      operator = !operator;\n    }\n\n    if (!operator) {\n      throw new Error('Formula contains invalid trailing operator');\n    } // Identify single part\n\n\n    if (parts.length === 1 && ['reference', 'literal', 'constant'].includes(parts[0].type)) {\n      this.single = {\n        type: parts[0].type === 'reference' ? 'reference' : 'value',\n        value: parts[0].value\n      };\n    } // Process parts\n\n\n    this._parts = parts.map(part => {\n      // Operators\n      if (part.type === 'operator') {\n        return internals.operatorsPrefix.includes(part.value) ? part : part.value;\n      } // Literals, constants, segments\n\n\n      if (part.type !== 'reference') {\n        return part.value;\n      } // References\n\n\n      if (this.settings.tokenRx && !this.settings.tokenRx.test(part.value)) {\n        throw new Error(`Formula contains invalid reference ${part.value}`);\n      }\n\n      if (this.settings.reference) {\n        return this.settings.reference(part.value);\n      }\n\n      return internals.reference(part.value);\n    });\n  }\n\n  _subFormula(string, name) {\n    const method = this.settings.functions[name];\n\n    if (typeof method !== 'function') {\n      throw new Error(`Formula contains unknown function ${name}`);\n    }\n\n    let args = [];\n\n    if (string) {\n      let current = '';\n      let parenthesis = 0;\n      let literal = false;\n\n      const flush = () => {\n        if (!current) {\n          throw new Error(`Formula contains function ${name} with invalid arguments ${string}`);\n        }\n\n        args.push(current);\n        current = '';\n      };\n\n      for (let i = 0; i < string.length; ++i) {\n        const c = string[i];\n\n        if (literal) {\n          current += c;\n\n          if (c === literal) {\n            literal = false;\n          }\n        } else if (c in internals.literals && !parenthesis) {\n          current += c;\n          literal = internals.literals[c];\n        } else if (c === ',' && !parenthesis) {\n          flush();\n        } else {\n          current += c;\n\n          if (c === '(') {\n            ++parenthesis;\n          } else if (c === ')') {\n            --parenthesis;\n          }\n        }\n      }\n\n      flush();\n    }\n\n    args = args.map(arg => new exports.Parser(arg, this.settings));\n    return function (context) {\n      const innerValues = [];\n\n      for (const arg of args) {\n        innerValues.push(arg.evaluate(context));\n      }\n\n      return method.call(context, ...innerValues);\n    };\n  }\n\n  evaluate(context) {\n    const parts = this._parts.slice(); // Prefix operators\n\n\n    for (let i = parts.length - 2; i >= 0; --i) {\n      const part = parts[i];\n\n      if (part && part.type === 'operator') {\n        const current = parts[i + 1];\n        parts.splice(i + 1, 1);\n        const value = internals.evaluate(current, context);\n        parts[i] = internals.single(part.value, value);\n      }\n    } // Left-right operators\n\n\n    internals.operatorsOrder.forEach(set => {\n      for (let i = 1; i < parts.length - 1;) {\n        if (set.includes(parts[i])) {\n          const operator = parts[i];\n          const left = internals.evaluate(parts[i - 1], context);\n          const right = internals.evaluate(parts[i + 1], context);\n          parts.splice(i, 2);\n          const result = internals.calculate(operator, left, right);\n          parts[i - 1] = result === 0 ? 0 : result; // Convert -0\n        } else {\n          i += 2;\n        }\n      }\n    });\n    return internals.evaluate(parts[0], context);\n  }\n\n};\nexports.Parser.prototype[internals.symbol] = true;\n\ninternals.reference = function (name) {\n  return function (context) {\n    return context && context[name] !== undefined ? context[name] : null;\n  };\n};\n\ninternals.evaluate = function (part, context) {\n  if (part === null) {\n    return null;\n  }\n\n  if (typeof part === 'function') {\n    return part(context);\n  }\n\n  if (part[internals.symbol]) {\n    return part.evaluate(context);\n  }\n\n  return part;\n};\n\ninternals.single = function (operator, value) {\n  if (operator === '!') {\n    return value ? false : true;\n  } // operator === 'n'\n\n\n  const negative = -value;\n\n  if (negative === 0) {\n    // Override -0\n    return 0;\n  }\n\n  return negative;\n};\n\ninternals.calculate = function (operator, left, right) {\n  if (operator === '??') {\n    return internals.exists(left) ? left : right;\n  }\n\n  if (typeof left === 'string' || typeof right === 'string') {\n    if (operator === '+') {\n      left = internals.exists(left) ? left : '';\n      right = internals.exists(right) ? right : '';\n      return left + right;\n    }\n  } else {\n    switch (operator) {\n      case '^':\n        return Math.pow(left, right);\n\n      case '*':\n        return left * right;\n\n      case '/':\n        return left / right;\n\n      case '%':\n        return left % right;\n\n      case '+':\n        return left + right;\n\n      case '-':\n        return left - right;\n    }\n  }\n\n  switch (operator) {\n    case '<':\n      return left < right;\n\n    case '<=':\n      return left <= right;\n\n    case '>':\n      return left > right;\n\n    case '>=':\n      return left >= right;\n\n    case '==':\n      return left === right;\n\n    case '!=':\n      return left !== right;\n\n    case '&&':\n      return left && right;\n\n    case '||':\n      return left || right;\n  }\n\n  return null;\n};\n\ninternals.exists = function (value) {\n  return value !== null && value !== undefined;\n};","map":{"version":3,"sources":["C:/scripting/jobs assignments/whist/backend/node_modules/@sideway/formula/lib/index.js"],"names":["internals","operators","operatorCharacters","operatorsOrder","operatorsPrefix","literals","numberRx","tokenRx","symbol","Symbol","settings","exports","Parser","constructor","string","options","constants","constant","value","includes","Error","Object","assign","functions","single","_parts","_parse","parts","current","parenthesis","literal","flush","inner","last","length","type","_subFormula","sub","push","match","parseFloat","undefined","c","map","part","i","operator","test","reference","name","method","args","arg","context","innerValues","evaluate","call","slice","splice","forEach","set","left","right","result","calculate","prototype","negative","exists","Math","pow"],"mappings":"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","sourcesContent":["'use strict';\n\nconst internals = {\n    operators: ['!', '^', '*', '/', '%', '+', '-', '<', '<=', '>', '>=', '==', '!=', '&&', '||', '??'],\n    operatorCharacters: ['!', '^', '*', '/', '%', '+', '-', '<', '=', '>', '&', '|', '?'],\n    operatorsOrder: [['^'], ['*', '/', '%'], ['+', '-'], ['<', '<=', '>', '>='], ['==', '!='], ['&&'], ['||', '??']],\n    operatorsPrefix: ['!', 'n'],\n\n    literals: {\n        '\"': '\"',\n        '`': '`',\n        '\\'': '\\'',\n        '[': ']'\n    },\n\n    numberRx: /^(?:[0-9]*\\.?[0-9]*){1}$/,\n    tokenRx: /^[\\w\\$\\#\\.\\@\\:\\{\\}]+$/,\n\n    symbol: Symbol('formula'),\n    settings: Symbol('settings')\n};\n\n\nexports.Parser = class {\n\n    constructor(string, options = {}) {\n\n        if (!options[internals.settings] &&\n            options.constants) {\n\n            for (const constant in options.constants) {\n                const value = options.constants[constant];\n                if (value !== null &&\n                    !['boolean', 'number', 'string'].includes(typeof value)) {\n\n                    throw new Error(`Formula constant ${constant} contains invalid ${typeof value} value type`);\n                }\n            }\n        }\n\n        this.settings = options[internals.settings] ? options : Object.assign({ [internals.settings]: true, constants: {}, functions: {} }, options);\n        this.single = null;\n\n        this._parts = null;\n        this._parse(string);\n    }\n\n    _parse(string) {\n\n        let parts = [];\n        let current = '';\n        let parenthesis = 0;\n        let literal = false;\n\n        const flush = (inner) => {\n\n            if (parenthesis) {\n                throw new Error('Formula missing closing parenthesis');\n            }\n\n            const last = parts.length ? parts[parts.length - 1] : null;\n\n            if (!literal &&\n                !current &&\n                !inner) {\n\n                return;\n            }\n\n            if (last &&\n                last.type === 'reference' &&\n                inner === ')') {                                                                // Function\n\n                last.type = 'function';\n                last.value = this._subFormula(current, last.value);\n                current = '';\n                return;\n            }\n\n            if (inner === ')') {                                                                // Segment\n                const sub = new exports.Parser(current, this.settings);\n                parts.push({ type: 'segment', value: sub });\n            }\n            else if (literal) {\n                if (literal === ']') {                                                          // Reference\n                    parts.push({ type: 'reference', value: current });\n                    current = '';\n                    return;\n                }\n\n                parts.push({ type: 'literal', value: current });                                // Literal\n            }\n            else if (internals.operatorCharacters.includes(current)) {                          // Operator\n                if (last &&\n                    last.type === 'operator' &&\n                    internals.operators.includes(last.value + current)) {                       // 2 characters operator\n\n                    last.value += current;\n                }\n                else {\n                    parts.push({ type: 'operator', value: current });\n                }\n            }\n            else if (current.match(internals.numberRx)) {                                       // Number\n                parts.push({ type: 'constant', value: parseFloat(current) });\n            }\n            else if (this.settings.constants[current] !== undefined) {                          // Constant\n                parts.push({ type: 'constant', value: this.settings.constants[current] });\n            }\n            else {                                                                              // Reference\n                if (!current.match(internals.tokenRx)) {\n                    throw new Error(`Formula contains invalid token: ${current}`);\n                }\n\n                parts.push({ type: 'reference', value: current });\n            }\n\n            current = '';\n        };\n\n        for (const c of string) {\n            if (literal) {\n                if (c === literal) {\n                    flush();\n                    literal = false;\n                }\n                else {\n                    current += c;\n                }\n            }\n            else if (parenthesis) {\n                if (c === '(') {\n                    current += c;\n                    ++parenthesis;\n                }\n                else if (c === ')') {\n                    --parenthesis;\n                    if (!parenthesis) {\n                        flush(c);\n                    }\n                    else {\n                        current += c;\n                    }\n                }\n                else {\n                    current += c;\n                }\n            }\n            else if (c in internals.literals) {\n                literal = internals.literals[c];\n            }\n            else if (c === '(') {\n                flush();\n                ++parenthesis;\n            }\n            else if (internals.operatorCharacters.includes(c)) {\n                flush();\n                current = c;\n                flush();\n            }\n            else if (c !== ' ') {\n                current += c;\n            }\n            else {\n                flush();\n            }\n        }\n\n        flush();\n\n        // Replace prefix - to internal negative operator\n\n        parts = parts.map((part, i) => {\n\n            if (part.type !== 'operator' ||\n                part.value !== '-' ||\n                i && parts[i - 1].type !== 'operator') {\n\n                return part;\n            }\n\n            return { type: 'operator', value: 'n' };\n        });\n\n        // Validate tokens order\n\n        let operator = false;\n        for (const part of parts) {\n            if (part.type === 'operator') {\n                if (internals.operatorsPrefix.includes(part.value)) {\n                    continue;\n                }\n\n                if (!operator) {\n                    throw new Error('Formula contains an operator in invalid position');\n                }\n\n                if (!internals.operators.includes(part.value)) {\n                    throw new Error(`Formula contains an unknown operator ${part.value}`);\n                }\n            }\n            else if (operator) {\n                throw new Error('Formula missing expected operator');\n            }\n\n            operator = !operator;\n        }\n\n        if (!operator) {\n            throw new Error('Formula contains invalid trailing operator');\n        }\n\n        // Identify single part\n\n        if (parts.length === 1 &&\n            ['reference', 'literal', 'constant'].includes(parts[0].type)) {\n\n            this.single = { type: parts[0].type === 'reference' ? 'reference' : 'value', value: parts[0].value };\n        }\n\n        // Process parts\n\n        this._parts = parts.map((part) => {\n\n            // Operators\n\n            if (part.type === 'operator') {\n                return internals.operatorsPrefix.includes(part.value) ? part : part.value;\n            }\n\n            // Literals, constants, segments\n\n            if (part.type !== 'reference') {\n                return part.value;\n            }\n\n            // References\n\n            if (this.settings.tokenRx &&\n                !this.settings.tokenRx.test(part.value)) {\n\n                throw new Error(`Formula contains invalid reference ${part.value}`);\n            }\n\n            if (this.settings.reference) {\n                return this.settings.reference(part.value);\n            }\n\n            return internals.reference(part.value);\n        });\n    }\n\n    _subFormula(string, name) {\n\n        const method = this.settings.functions[name];\n        if (typeof method !== 'function') {\n            throw new Error(`Formula contains unknown function ${name}`);\n        }\n\n        let args = [];\n        if (string) {\n            let current = '';\n            let parenthesis = 0;\n            let literal = false;\n\n            const flush = () => {\n\n                if (!current) {\n                    throw new Error(`Formula contains function ${name} with invalid arguments ${string}`);\n                }\n\n                args.push(current);\n                current = '';\n            };\n\n            for (let i = 0; i < string.length; ++i) {\n                const c = string[i];\n                if (literal) {\n                    current += c;\n                    if (c === literal) {\n                        literal = false;\n                    }\n                }\n                else if (c in internals.literals &&\n                    !parenthesis) {\n\n                    current += c;\n                    literal = internals.literals[c];\n                }\n                else if (c === ',' &&\n                    !parenthesis) {\n\n                    flush();\n                }\n                else {\n                    current += c;\n                    if (c === '(') {\n                        ++parenthesis;\n                    }\n                    else if (c === ')') {\n                        --parenthesis;\n                    }\n                }\n            }\n\n            flush();\n        }\n\n        args = args.map((arg) => new exports.Parser(arg, this.settings));\n\n        return function (context) {\n\n            const innerValues = [];\n            for (const arg of args) {\n                innerValues.push(arg.evaluate(context));\n            }\n\n            return method.call(context, ...innerValues);\n        };\n    }\n\n    evaluate(context) {\n\n        const parts = this._parts.slice();\n\n        // Prefix operators\n\n        for (let i = parts.length - 2; i >= 0; --i) {\n            const part = parts[i];\n            if (part &&\n                part.type === 'operator') {\n\n                const current = parts[i + 1];\n                parts.splice(i + 1, 1);\n                const value = internals.evaluate(current, context);\n                parts[i] = internals.single(part.value, value);\n            }\n        }\n\n        // Left-right operators\n\n        internals.operatorsOrder.forEach((set) => {\n\n            for (let i = 1; i < parts.length - 1;) {\n                if (set.includes(parts[i])) {\n                    const operator = parts[i];\n                    const left = internals.evaluate(parts[i - 1], context);\n                    const right = internals.evaluate(parts[i + 1], context);\n\n                    parts.splice(i, 2);\n                    const result = internals.calculate(operator, left, right);\n                    parts[i - 1] = result === 0 ? 0 : result;                               // Convert -0\n                }\n                else {\n                    i += 2;\n                }\n            }\n        });\n\n        return internals.evaluate(parts[0], context);\n    }\n};\n\n\nexports.Parser.prototype[internals.symbol] = true;\n\n\ninternals.reference = function (name) {\n\n    return function (context) {\n\n        return context && context[name] !== undefined ? context[name] : null;\n    };\n};\n\n\ninternals.evaluate = function (part, context) {\n\n    if (part === null) {\n        return null;\n    }\n\n    if (typeof part === 'function') {\n        return part(context);\n    }\n\n    if (part[internals.symbol]) {\n        return part.evaluate(context);\n    }\n\n    return part;\n};\n\n\ninternals.single = function (operator, value) {\n\n    if (operator === '!') {\n        return value ? false : true;\n    }\n\n    // operator === 'n'\n\n    const negative = -value;\n    if (negative === 0) {       // Override -0\n        return 0;\n    }\n\n    return negative;\n};\n\n\ninternals.calculate = function (operator, left, right) {\n\n    if (operator === '??') {\n        return internals.exists(left) ? left : right;\n    }\n\n    if (typeof left === 'string' ||\n        typeof right === 'string') {\n\n        if (operator === '+') {\n            left = internals.exists(left) ? left : '';\n            right = internals.exists(right) ? right : '';\n            return left + right;\n        }\n    }\n    else {\n        switch (operator) {\n            case '^': return Math.pow(left, right);\n            case '*': return left * right;\n            case '/': return left / right;\n            case '%': return left % right;\n            case '+': return left + right;\n            case '-': return left - right;\n        }\n    }\n\n    switch (operator) {\n        case '<': return left < right;\n        case '<=': return left <= right;\n        case '>': return left > right;\n        case '>=': return left >= right;\n        case '==': return left === right;\n        case '!=': return left !== right;\n        case '&&': return left && right;\n        case '||': return left || right;\n    }\n\n    return null;\n};\n\n\ninternals.exists = function (value) {\n\n    return value !== null && value !== undefined;\n};\n"]},"metadata":{},"sourceType":"script"}