{"ast":null,"code":"'use strict';\n\nconst DeepEqual = require('@hapi/hoek/lib/deepEqual');\n\nconst Pinpoint = require('@sideway/pinpoint');\n\nconst Errors = require('./errors');\n\nconst internals = {\n  codes: {\n    error: 1,\n    pass: 2,\n    full: 3\n  },\n  labels: {\n    0: 'never used',\n    1: 'always error',\n    2: 'always pass'\n  }\n};\n\nexports.setup = function (root) {\n  const trace = function () {\n    root._tracer = root._tracer || new internals.Tracer();\n    return root._tracer;\n  };\n\n  root.trace = trace;\n  root[Symbol.for('@hapi/lab/coverage/initialize')] = trace;\n\n  root.untrace = () => {\n    root._tracer = null;\n  };\n};\n\nexports.location = function (schema) {\n  return schema.$_setFlag('_tracerLocation', Pinpoint.location(2)); // base.tracer(), caller\n};\n\ninternals.Tracer = class {\n  constructor() {\n    this.name = 'Joi';\n    this._schemas = new Map();\n  }\n\n  _register(schema) {\n    const existing = this._schemas.get(schema);\n\n    if (existing) {\n      return existing.store;\n    }\n\n    const store = new internals.Store(schema);\n    const {\n      filename,\n      line\n    } = schema._flags._tracerLocation || Pinpoint.location(5); // internals.tracer(), internals.entry(), exports.entry(), validate(), caller\n\n    this._schemas.set(schema, {\n      filename,\n      line,\n      store\n    });\n\n    return store;\n  }\n\n  _combine(merged, sources) {\n    for (const {\n      store\n    } of this._schemas.values()) {\n      store._combine(merged, sources);\n    }\n  }\n\n  report(file) {\n    const coverage = []; // Process each registered schema\n\n    for (const {\n      filename,\n      line,\n      store\n    } of this._schemas.values()) {\n      if (file && file !== filename) {\n        continue;\n      } // Process sub schemas of the registered root\n\n\n      const missing = [];\n      const skipped = [];\n\n      for (const [schema, log] of store._sources.entries()) {\n        // Check if sub schema parent skipped\n        if (internals.sub(log.paths, skipped)) {\n          continue;\n        } // Check if sub schema reached\n\n\n        if (!log.entry) {\n          missing.push({\n            status: 'never reached',\n            paths: [...log.paths]\n          });\n          skipped.push(...log.paths);\n          continue;\n        } // Check values\n\n\n        for (const type of ['valid', 'invalid']) {\n          const set = schema[`_${type}s`];\n\n          if (!set) {\n            continue;\n          }\n\n          const values = new Set(set._values);\n          const refs = new Set(set._refs);\n\n          for (const {\n            value,\n            ref\n          } of log[type]) {\n            values.delete(value);\n            refs.delete(ref);\n          }\n\n          if (values.size || refs.size) {\n            missing.push({\n              status: [...values, ...[...refs].map(ref => ref.display)],\n              rule: `${type}s`\n            });\n          }\n        } // Check rules status\n\n\n        const rules = schema._rules.map(rule => rule.name);\n\n        for (const type of ['default', 'failover']) {\n          if (schema._flags[type] !== undefined) {\n            rules.push(type);\n          }\n        }\n\n        for (const name of rules) {\n          const status = internals.labels[log.rule[name] || 0];\n\n          if (status) {\n            const report = {\n              rule: name,\n              status\n            };\n\n            if (log.paths.size) {\n              report.paths = [...log.paths];\n            }\n\n            missing.push(report);\n          }\n        }\n      }\n\n      if (missing.length) {\n        coverage.push({\n          filename,\n          line,\n          missing,\n          severity: 'error',\n          message: `Schema missing tests for ${missing.map(internals.message).join(', ')}`\n        });\n      }\n    }\n\n    return coverage.length ? coverage : null;\n  }\n\n};\ninternals.Store = class {\n  constructor(schema) {\n    this.active = true;\n    this._sources = new Map(); // schema -> { paths, entry, rule, valid, invalid }\n\n    this._combos = new Map(); // merged -> [sources]\n\n    this._scan(schema);\n  }\n\n  debug(state, source, name, result) {\n    state.mainstay.debug && state.mainstay.debug.push({\n      type: source,\n      name,\n      result,\n      path: state.path\n    });\n  }\n\n  entry(schema, state) {\n    internals.debug(state, {\n      type: 'entry'\n    });\n\n    this._record(schema, log => {\n      log.entry = true;\n    });\n  }\n\n  filter(schema, state, source, value) {\n    internals.debug(state, {\n      type: source,\n      ...value\n    });\n\n    this._record(schema, log => {\n      log[source].add(value);\n    });\n  }\n\n  log(schema, state, source, name, result) {\n    internals.debug(state, {\n      type: source,\n      name,\n      result: result === 'full' ? 'pass' : result\n    });\n\n    this._record(schema, log => {\n      log[source][name] = log[source][name] || 0;\n      log[source][name] |= internals.codes[result];\n    });\n  }\n\n  resolve(state, ref, to) {\n    if (!state.mainstay.debug) {\n      return;\n    }\n\n    const log = {\n      type: 'resolve',\n      ref: ref.display,\n      to,\n      path: state.path\n    };\n    state.mainstay.debug.push(log);\n  }\n\n  value(state, by, from, to, name) {\n    if (!state.mainstay.debug || DeepEqual(from, to)) {\n      return;\n    }\n\n    const log = {\n      type: 'value',\n      by,\n      from,\n      to,\n      path: state.path\n    };\n\n    if (name) {\n      log.name = name;\n    }\n\n    state.mainstay.debug.push(log);\n  }\n\n  _record(schema, each) {\n    const log = this._sources.get(schema);\n\n    if (log) {\n      each(log);\n      return;\n    }\n\n    const sources = this._combos.get(schema);\n\n    for (const source of sources) {\n      this._record(source, each);\n    }\n  }\n\n  _scan(schema, _path) {\n    const path = _path || [];\n\n    let log = this._sources.get(schema);\n\n    if (!log) {\n      log = {\n        paths: new Set(),\n        entry: false,\n        rule: {},\n        valid: new Set(),\n        invalid: new Set()\n      };\n\n      this._sources.set(schema, log);\n    }\n\n    if (path.length) {\n      log.paths.add(path);\n    }\n\n    const each = (sub, source) => {\n      const subId = internals.id(sub, source);\n\n      this._scan(sub, path.concat(subId));\n    };\n\n    schema.$_modify({\n      each,\n      ref: false\n    });\n  }\n\n  _combine(merged, sources) {\n    this._combos.set(merged, sources);\n  }\n\n};\n\ninternals.message = function (item) {\n  const path = item.paths ? Errors.path(item.paths[0]) + (item.rule ? ':' : '') : '';\n  return `${path}${item.rule || ''} (${item.status})`;\n};\n\ninternals.id = function (schema, {\n  source,\n  name,\n  path,\n  key\n}) {\n  if (schema._flags.id) {\n    return schema._flags.id;\n  }\n\n  if (key) {\n    return key;\n  }\n\n  name = `@${name}`;\n\n  if (source === 'terms') {\n    return [name, path[Math.min(path.length - 1, 1)]];\n  }\n\n  return name;\n};\n\ninternals.sub = function (paths, skipped) {\n  for (const path of paths) {\n    for (const skip of skipped) {\n      if (DeepEqual(path.slice(0, skip.length), skip)) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n};\n\ninternals.debug = function (state, event) {\n  if (state.mainstay.debug) {\n    event.path = state.debug ? [...state.path, state.debug] : state.path;\n    state.mainstay.debug.push(event);\n  }\n};","map":{"version":3,"sources":["C:/scripting/jobs assignments/whist/backend/node_modules/joi/lib/trace.js"],"names":["DeepEqual","require","Pinpoint","Errors","internals","codes","error","pass","full","labels","exports","setup","root","trace","_tracer","Tracer","Symbol","for","untrace","location","schema","$_setFlag","constructor","name","_schemas","Map","_register","existing","get","store","Store","filename","line","_flags","_tracerLocation","set","_combine","merged","sources","values","report","file","coverage","missing","skipped","log","_sources","entries","sub","paths","entry","push","status","type","Set","_values","refs","_refs","value","ref","delete","size","map","display","rule","rules","_rules","undefined","length","severity","message","join","active","_combos","_scan","debug","state","source","result","mainstay","path","_record","filter","add","resolve","to","by","from","each","_path","valid","invalid","subId","id","concat","$_modify","item","key","Math","min","skip","slice","event"],"mappings":"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","sourcesContent":["'use strict';\n\nconst DeepEqual = require('@hapi/hoek/lib/deepEqual');\nconst Pinpoint = require('@sideway/pinpoint');\n\nconst Errors = require('./errors');\n\n\nconst internals = {\n    codes: {\n        error: 1,\n        pass: 2,\n        full: 3\n    },\n    labels: {\n        0: 'never used',\n        1: 'always error',\n        2: 'always pass'\n    }\n};\n\n\nexports.setup = function (root) {\n\n    const trace = function () {\n\n        root._tracer = root._tracer || new internals.Tracer();\n        return root._tracer;\n    };\n\n    root.trace = trace;\n    root[Symbol.for('@hapi/lab/coverage/initialize')] = trace;\n\n    root.untrace = () => {\n\n        root._tracer = null;\n    };\n};\n\n\nexports.location = function (schema) {\n\n    return schema.$_setFlag('_tracerLocation', Pinpoint.location(2));                       // base.tracer(), caller\n};\n\n\ninternals.Tracer = class {\n\n    constructor() {\n\n        this.name = 'Joi';\n        this._schemas = new Map();\n    }\n\n    _register(schema) {\n\n        const existing = this._schemas.get(schema);\n        if (existing) {\n            return existing.store;\n        }\n\n        const store = new internals.Store(schema);\n        const { filename, line } = schema._flags._tracerLocation || Pinpoint.location(5);   // internals.tracer(), internals.entry(), exports.entry(), validate(), caller\n        this._schemas.set(schema, { filename, line, store });\n        return store;\n    }\n\n    _combine(merged, sources) {\n\n        for (const { store } of this._schemas.values()) {\n            store._combine(merged, sources);\n        }\n    }\n\n    report(file) {\n\n        const coverage = [];\n\n        // Process each registered schema\n\n        for (const { filename, line, store } of this._schemas.values()) {\n            if (file &&\n                file !== filename) {\n\n                continue;\n            }\n\n            // Process sub schemas of the registered root\n\n            const missing = [];\n            const skipped = [];\n\n            for (const [schema, log] of store._sources.entries()) {\n\n                // Check if sub schema parent skipped\n\n                if (internals.sub(log.paths, skipped)) {\n                    continue;\n                }\n\n                // Check if sub schema reached\n\n                if (!log.entry) {\n                    missing.push({\n                        status: 'never reached',\n                        paths: [...log.paths]\n                    });\n\n                    skipped.push(...log.paths);\n                    continue;\n                }\n\n                // Check values\n\n                for (const type of ['valid', 'invalid']) {\n                    const set = schema[`_${type}s`];\n                    if (!set) {\n                        continue;\n                    }\n\n                    const values = new Set(set._values);\n                    const refs = new Set(set._refs);\n                    for (const { value, ref } of log[type]) {\n                        values.delete(value);\n                        refs.delete(ref);\n                    }\n\n                    if (values.size ||\n                        refs.size) {\n\n                        missing.push({\n                            status: [...values, ...[...refs].map((ref) => ref.display)],\n                            rule: `${type}s`\n                        });\n                    }\n                }\n\n                // Check rules status\n\n                const rules = schema._rules.map((rule) => rule.name);\n                for (const type of ['default', 'failover']) {\n                    if (schema._flags[type] !== undefined) {\n                        rules.push(type);\n                    }\n                }\n\n                for (const name of rules) {\n                    const status = internals.labels[log.rule[name] || 0];\n                    if (status) {\n                        const report = { rule: name, status };\n                        if (log.paths.size) {\n                            report.paths = [...log.paths];\n                        }\n\n                        missing.push(report);\n                    }\n                }\n            }\n\n            if (missing.length) {\n                coverage.push({\n                    filename,\n                    line,\n                    missing,\n                    severity: 'error',\n                    message: `Schema missing tests for ${missing.map(internals.message).join(', ')}`\n                });\n            }\n        }\n\n        return coverage.length ? coverage : null;\n    }\n};\n\n\ninternals.Store = class {\n\n    constructor(schema) {\n\n        this.active = true;\n        this._sources = new Map();          // schema -> { paths, entry, rule, valid, invalid }\n        this._combos = new Map();           // merged -> [sources]\n        this._scan(schema);\n    }\n\n    debug(state, source, name, result) {\n\n        state.mainstay.debug && state.mainstay.debug.push({ type: source, name, result, path: state.path });\n    }\n\n    entry(schema, state) {\n\n        internals.debug(state, { type: 'entry' });\n\n        this._record(schema, (log) => {\n\n            log.entry = true;\n        });\n    }\n\n    filter(schema, state, source, value) {\n\n        internals.debug(state, { type: source, ...value });\n\n        this._record(schema, (log) => {\n\n            log[source].add(value);\n        });\n    }\n\n    log(schema, state, source, name, result) {\n\n        internals.debug(state, { type: source, name, result: result === 'full' ? 'pass' : result });\n\n        this._record(schema, (log) => {\n\n            log[source][name] = log[source][name] || 0;\n            log[source][name] |= internals.codes[result];\n        });\n    }\n\n    resolve(state, ref, to) {\n\n        if (!state.mainstay.debug) {\n            return;\n        }\n\n        const log = { type: 'resolve', ref: ref.display, to, path: state.path };\n        state.mainstay.debug.push(log);\n    }\n\n    value(state, by, from, to, name) {\n\n        if (!state.mainstay.debug ||\n            DeepEqual(from, to)) {\n\n            return;\n        }\n\n        const log = { type: 'value', by, from, to, path: state.path };\n        if (name) {\n            log.name = name;\n        }\n\n        state.mainstay.debug.push(log);\n    }\n\n    _record(schema, each) {\n\n        const log = this._sources.get(schema);\n        if (log) {\n            each(log);\n            return;\n        }\n\n        const sources = this._combos.get(schema);\n        for (const source of sources) {\n            this._record(source, each);\n        }\n    }\n\n    _scan(schema, _path) {\n\n        const path = _path || [];\n\n        let log = this._sources.get(schema);\n        if (!log) {\n            log = {\n                paths: new Set(),\n                entry: false,\n                rule: {},\n                valid: new Set(),\n                invalid: new Set()\n            };\n\n            this._sources.set(schema, log);\n        }\n\n        if (path.length) {\n            log.paths.add(path);\n        }\n\n        const each = (sub, source) => {\n\n            const subId = internals.id(sub, source);\n            this._scan(sub, path.concat(subId));\n        };\n\n        schema.$_modify({ each, ref: false });\n    }\n\n    _combine(merged, sources) {\n\n        this._combos.set(merged, sources);\n    }\n};\n\n\ninternals.message = function (item) {\n\n    const path = item.paths ? Errors.path(item.paths[0]) + (item.rule ? ':' : '') : '';\n    return `${path}${item.rule || ''} (${item.status})`;\n};\n\n\ninternals.id = function (schema, { source, name, path, key }) {\n\n    if (schema._flags.id) {\n        return schema._flags.id;\n    }\n\n    if (key) {\n        return key;\n    }\n\n    name = `@${name}`;\n\n    if (source === 'terms') {\n        return [name, path[Math.min(path.length - 1, 1)]];\n    }\n\n    return name;\n};\n\n\ninternals.sub = function (paths, skipped) {\n\n    for (const path of paths) {\n        for (const skip of skipped) {\n            if (DeepEqual(path.slice(0, skip.length), skip)) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n};\n\n\ninternals.debug = function (state, event) {\n\n    if (state.mainstay.debug) {\n        event.path = state.debug ? [...state.path, state.debug] : state.path;\n        state.mainstay.debug.push(event);\n    }\n};\n"]},"metadata":{},"sourceType":"script"}