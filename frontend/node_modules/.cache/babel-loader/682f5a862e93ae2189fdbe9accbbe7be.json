{"ast":null,"code":"'use strict';\n\nconst Assert = require('@hapi/hoek/lib/assert');\n\nconst Clone = require('@hapi/hoek/lib/clone');\n\nconst DeepEqual = require('@hapi/hoek/lib/deepEqual');\n\nconst Merge = require('@hapi/hoek/lib/merge');\n\nconst Cache = require('./cache');\n\nconst Common = require('./common');\n\nconst Compile = require('./compile');\n\nconst Errors = require('./errors');\n\nconst Extend = require('./extend');\n\nconst Manifest = require('./manifest');\n\nconst Messages = require('./messages');\n\nconst Modify = require('./modify');\n\nconst Ref = require('./ref');\n\nconst Trace = require('./trace');\n\nconst Validator = require('./validator');\n\nconst Values = require('./values');\n\nconst internals = {};\ninternals.Base = class {\n  constructor(type) {\n    // Naming: public, _private, $_extension, $_mutate{action}\n    this.type = type;\n    this.$_root = null;\n    this._definition = {};\n\n    this._reset();\n  }\n\n  _reset() {\n    this._ids = new Modify.Ids();\n    this._preferences = null;\n    this._refs = new Ref.Manager();\n    this._cache = null;\n    this._valids = null;\n    this._invalids = null;\n    this._flags = {};\n    this._rules = [];\n    this._singleRules = new Map(); // The rule options passed for non-multi rules\n\n    this.$_terms = {}; // Hash of arrays of immutable objects (extended by other types)\n\n    this.$_temp = {\n      // Runtime state (not cloned)\n      ruleset: null,\n      // null: use last, false: error, number: start position\n      whens: {} // Runtime cache of generated whens\n\n    };\n  } // Manifest\n\n\n  describe() {\n    Assert(typeof Manifest.describe === 'function', 'Manifest functionality disabled');\n    return Manifest.describe(this);\n  } // Rules\n\n\n  allow(...values) {\n    Common.verifyFlat(values, 'allow');\n    return this._values(values, '_valids');\n  }\n\n  alter(targets) {\n    Assert(targets && typeof targets === 'object' && !Array.isArray(targets), 'Invalid targets argument');\n    Assert(!this._inRuleset(), 'Cannot set alterations inside a ruleset');\n    const obj = this.clone();\n    obj.$_terms.alterations = obj.$_terms.alterations || [];\n\n    for (const target in targets) {\n      const adjuster = targets[target];\n      Assert(typeof adjuster === 'function', 'Alteration adjuster for', target, 'must be a function');\n      obj.$_terms.alterations.push({\n        target,\n        adjuster\n      });\n    }\n\n    obj.$_temp.ruleset = false;\n    return obj;\n  }\n\n  artifact(id) {\n    Assert(id !== undefined, 'Artifact cannot be undefined');\n    Assert(!this._cache, 'Cannot set an artifact with a rule cache');\n    return this.$_setFlag('artifact', id);\n  }\n\n  cast(to) {\n    Assert(to === false || typeof to === 'string', 'Invalid to value');\n    Assert(to === false || this._definition.cast[to], 'Type', this.type, 'does not support casting to', to);\n    return this.$_setFlag('cast', to === false ? undefined : to);\n  }\n\n  default(value, options) {\n    return this._default('default', value, options);\n  }\n\n  description(desc) {\n    Assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\n    return this.$_setFlag('description', desc);\n  }\n\n  empty(schema) {\n    const obj = this.clone();\n\n    if (schema !== undefined) {\n      schema = obj.$_compile(schema, {\n        override: false\n      });\n    }\n\n    return obj.$_setFlag('empty', schema, {\n      clone: false\n    });\n  }\n\n  error(err) {\n    Assert(err, 'Missing error');\n    Assert(err instanceof Error || typeof err === 'function', 'Must provide a valid Error object or a function');\n    return this.$_setFlag('error', err);\n  }\n\n  example(example, options = {}) {\n    Assert(example !== undefined, 'Missing example');\n    Common.assertOptions(options, ['override']);\n    return this._inner('examples', example, {\n      single: true,\n      override: options.override\n    });\n  }\n\n  external(method, description) {\n    if (typeof method === 'object') {\n      Assert(!description, 'Cannot combine options with description');\n      description = method.description;\n      method = method.method;\n    }\n\n    Assert(typeof method === 'function', 'Method must be a function');\n    Assert(description === undefined || description && typeof description === 'string', 'Description must be a non-empty string');\n    return this._inner('externals', {\n      method,\n      description\n    }, {\n      single: true\n    });\n  }\n\n  failover(value, options) {\n    return this._default('failover', value, options);\n  }\n\n  forbidden() {\n    return this.presence('forbidden');\n  }\n\n  id(id) {\n    if (!id) {\n      return this.$_setFlag('id', undefined);\n    }\n\n    Assert(typeof id === 'string', 'id must be a non-empty string');\n    Assert(/^[^\\.]+$/.test(id), 'id cannot contain period character');\n    return this.$_setFlag('id', id);\n  }\n\n  invalid(...values) {\n    return this._values(values, '_invalids');\n  }\n\n  label(name) {\n    Assert(name && typeof name === 'string', 'Label name must be a non-empty string');\n    return this.$_setFlag('label', name);\n  }\n\n  meta(meta) {\n    Assert(meta !== undefined, 'Meta cannot be undefined');\n    return this._inner('metas', meta, {\n      single: true\n    });\n  }\n\n  note(...notes) {\n    Assert(notes.length, 'Missing notes');\n\n    for (const note of notes) {\n      Assert(note && typeof note === 'string', 'Notes must be non-empty strings');\n    }\n\n    return this._inner('notes', notes);\n  }\n\n  only(mode = true) {\n    Assert(typeof mode === 'boolean', 'Invalid mode:', mode);\n    return this.$_setFlag('only', mode);\n  }\n\n  optional() {\n    return this.presence('optional');\n  }\n\n  prefs(prefs) {\n    Assert(prefs, 'Missing preferences');\n    Assert(prefs.context === undefined, 'Cannot override context');\n    Assert(prefs.externals === undefined, 'Cannot override externals');\n    Assert(prefs.warnings === undefined, 'Cannot override warnings');\n    Assert(prefs.debug === undefined, 'Cannot override debug');\n    Common.checkPreferences(prefs);\n    const obj = this.clone();\n    obj._preferences = Common.preferences(obj._preferences, prefs);\n    return obj;\n  }\n\n  presence(mode) {\n    Assert(['optional', 'required', 'forbidden'].includes(mode), 'Unknown presence mode', mode);\n    return this.$_setFlag('presence', mode);\n  }\n\n  raw(enabled = true) {\n    return this.$_setFlag('result', enabled ? 'raw' : undefined);\n  }\n\n  result(mode) {\n    Assert(['raw', 'strip'].includes(mode), 'Unknown result mode', mode);\n    return this.$_setFlag('result', mode);\n  }\n\n  required() {\n    return this.presence('required');\n  }\n\n  strict(enabled) {\n    const obj = this.clone();\n    const convert = enabled === undefined ? false : !enabled;\n    obj._preferences = Common.preferences(obj._preferences, {\n      convert\n    });\n    return obj;\n  }\n\n  strip(enabled = true) {\n    return this.$_setFlag('result', enabled ? 'strip' : undefined);\n  }\n\n  tag(...tags) {\n    Assert(tags.length, 'Missing tags');\n\n    for (const tag of tags) {\n      Assert(tag && typeof tag === 'string', 'Tags must be non-empty strings');\n    }\n\n    return this._inner('tags', tags);\n  }\n\n  unit(name) {\n    Assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\n    return this.$_setFlag('unit', name);\n  }\n\n  valid(...values) {\n    Common.verifyFlat(values, 'valid');\n    const obj = this.allow(...values);\n    obj.$_setFlag('only', !!obj._valids, {\n      clone: false\n    });\n    return obj;\n  }\n\n  when(condition, options) {\n    const obj = this.clone();\n\n    if (!obj.$_terms.whens) {\n      obj.$_terms.whens = [];\n    }\n\n    const when = Compile.when(obj, condition, options);\n\n    if (!['any', 'link'].includes(obj.type)) {\n      const conditions = when.is ? [when] : when.switch;\n\n      for (const item of conditions) {\n        Assert(!item.then || item.then.type === 'any' || item.then.type === obj.type, 'Cannot combine', obj.type, 'with', item.then && item.then.type);\n        Assert(!item.otherwise || item.otherwise.type === 'any' || item.otherwise.type === obj.type, 'Cannot combine', obj.type, 'with', item.otherwise && item.otherwise.type);\n      }\n    }\n\n    obj.$_terms.whens.push(when);\n    return obj.$_mutateRebuild();\n  } // Helpers\n\n\n  cache(cache) {\n    Assert(!this._inRuleset(), 'Cannot set caching inside a ruleset');\n    Assert(!this._cache, 'Cannot override schema cache');\n    Assert(this._flags.artifact === undefined, 'Cannot cache a rule with an artifact');\n    const obj = this.clone();\n    obj._cache = cache || Cache.provider.provision();\n    obj.$_temp.ruleset = false;\n    return obj;\n  }\n\n  clone() {\n    const obj = Object.create(Object.getPrototypeOf(this));\n    return this._assign(obj);\n  }\n\n  concat(source) {\n    Assert(Common.isSchema(source), 'Invalid schema object');\n    Assert(this.type === 'any' || source.type === 'any' || source.type === this.type, 'Cannot merge type', this.type, 'with another type:', source.type);\n    Assert(!this._inRuleset(), 'Cannot concatenate onto a schema with open ruleset');\n    Assert(!source._inRuleset(), 'Cannot concatenate a schema with open ruleset');\n    let obj = this.clone();\n\n    if (this.type === 'any' && source.type !== 'any') {\n      // Change obj to match source type\n      const tmpObj = source.clone();\n\n      for (const key of Object.keys(obj)) {\n        if (key !== 'type') {\n          tmpObj[key] = obj[key];\n        }\n      }\n\n      obj = tmpObj;\n    }\n\n    obj._ids.concat(source._ids);\n\n    obj._refs.register(source, Ref.toSibling);\n\n    obj._preferences = obj._preferences ? Common.preferences(obj._preferences, source._preferences) : source._preferences;\n    obj._valids = Values.merge(obj._valids, source._valids, source._invalids);\n    obj._invalids = Values.merge(obj._invalids, source._invalids, source._valids); // Remove unique rules present in source\n\n    for (const name of source._singleRules.keys()) {\n      if (obj._singleRules.has(name)) {\n        obj._rules = obj._rules.filter(target => target.keep || target.name !== name);\n\n        obj._singleRules.delete(name);\n      }\n    } // Rules\n\n\n    for (const test of source._rules) {\n      if (!source._definition.rules[test.method].multi) {\n        obj._singleRules.set(test.name, test);\n      }\n\n      obj._rules.push(test);\n    } // Flags\n\n\n    if (obj._flags.empty && source._flags.empty) {\n      obj._flags.empty = obj._flags.empty.concat(source._flags.empty);\n      const flags = Object.assign({}, source._flags);\n      delete flags.empty;\n      Merge(obj._flags, flags);\n    } else if (source._flags.empty) {\n      obj._flags.empty = source._flags.empty;\n      const flags = Object.assign({}, source._flags);\n      delete flags.empty;\n      Merge(obj._flags, flags);\n    } else {\n      Merge(obj._flags, source._flags);\n    } // Terms\n\n\n    for (const key in source.$_terms) {\n      const terms = source.$_terms[key];\n\n      if (!terms) {\n        if (!obj.$_terms[key]) {\n          obj.$_terms[key] = terms;\n        }\n\n        continue;\n      }\n\n      if (!obj.$_terms[key]) {\n        obj.$_terms[key] = terms.slice();\n        continue;\n      }\n\n      obj.$_terms[key] = obj.$_terms[key].concat(terms);\n    } // Tracing\n\n\n    if (this.$_root._tracer) {\n      this.$_root._tracer._combine(obj, [this, source]);\n    } // Rebuild\n\n\n    return obj.$_mutateRebuild();\n  }\n\n  extend(options) {\n    Assert(!options.base, 'Cannot extend type with another base');\n    return Extend.type(this, options);\n  }\n\n  extract(path) {\n    path = Array.isArray(path) ? path : path.split('.');\n    return this._ids.reach(path);\n  }\n\n  fork(paths, adjuster) {\n    Assert(!this._inRuleset(), 'Cannot fork inside a ruleset');\n    let obj = this; // eslint-disable-line consistent-this\n\n    for (let path of [].concat(paths)) {\n      path = Array.isArray(path) ? path : path.split('.');\n      obj = obj._ids.fork(path, adjuster, obj);\n    }\n\n    obj.$_temp.ruleset = false;\n    return obj;\n  }\n\n  rule(options) {\n    const def = this._definition;\n    Common.assertOptions(options, Object.keys(def.modifiers));\n    Assert(this.$_temp.ruleset !== false, 'Cannot apply rules to empty ruleset or the last rule added does not support rule properties');\n    const start = this.$_temp.ruleset === null ? this._rules.length - 1 : this.$_temp.ruleset;\n    Assert(start >= 0 && start < this._rules.length, 'Cannot apply rules to empty ruleset');\n    const obj = this.clone();\n\n    for (let i = start; i < obj._rules.length; ++i) {\n      const original = obj._rules[i];\n      const rule = Clone(original);\n\n      for (const name in options) {\n        def.modifiers[name](rule, options[name]);\n        Assert(rule.name === original.name, 'Cannot change rule name');\n      }\n\n      obj._rules[i] = rule;\n\n      if (obj._singleRules.get(rule.name) === original) {\n        obj._singleRules.set(rule.name, rule);\n      }\n    }\n\n    obj.$_temp.ruleset = false;\n    return obj.$_mutateRebuild();\n  }\n\n  get ruleset() {\n    Assert(!this._inRuleset(), 'Cannot start a new ruleset without closing the previous one');\n    const obj = this.clone();\n    obj.$_temp.ruleset = obj._rules.length;\n    return obj;\n  }\n\n  get $() {\n    return this.ruleset;\n  }\n\n  tailor(targets) {\n    targets = [].concat(targets);\n    Assert(!this._inRuleset(), 'Cannot tailor inside a ruleset');\n    let obj = this; // eslint-disable-line consistent-this\n\n    if (this.$_terms.alterations) {\n      for (const {\n        target,\n        adjuster\n      } of this.$_terms.alterations) {\n        if (targets.includes(target)) {\n          obj = adjuster(obj);\n          Assert(Common.isSchema(obj), 'Alteration adjuster for', target, 'failed to return a schema object');\n        }\n      }\n    }\n\n    obj = obj.$_modify({\n      each: item => item.tailor(targets),\n      ref: false\n    });\n    obj.$_temp.ruleset = false;\n    return obj.$_mutateRebuild();\n  }\n\n  tracer() {\n    return Trace.location ? Trace.location(this) : this; // $lab:coverage:ignore$\n  }\n\n  validate(value, options) {\n    return Validator.entry(value, this, options);\n  }\n\n  validateAsync(value, options) {\n    return Validator.entryAsync(value, this, options);\n  } // Extensions\n\n\n  $_addRule(options) {\n    // Normalize rule\n    if (typeof options === 'string') {\n      options = {\n        name: options\n      };\n    }\n\n    Assert(options && typeof options === 'object', 'Invalid options');\n    Assert(options.name && typeof options.name === 'string', 'Invalid rule name');\n\n    for (const key in options) {\n      Assert(key[0] !== '_', 'Cannot set private rule properties');\n    }\n\n    const rule = Object.assign({}, options); // Shallow cloned\n\n    rule._resolve = [];\n    rule.method = rule.method || rule.name;\n    const definition = this._definition.rules[rule.method];\n    const args = rule.args;\n    Assert(definition, 'Unknown rule', rule.method); // Args\n\n    const obj = this.clone();\n\n    if (args) {\n      Assert(Object.keys(args).length === 1 || Object.keys(args).length === this._definition.rules[rule.name].args.length, 'Invalid rule definition for', this.type, rule.name);\n\n      for (const key in args) {\n        let arg = args[key];\n\n        if (arg === undefined) {\n          delete args[key];\n          continue;\n        }\n\n        if (definition.argsByName) {\n          const resolver = definition.argsByName.get(key);\n\n          if (resolver.ref && Common.isResolvable(arg)) {\n            rule._resolve.push(key);\n\n            obj.$_mutateRegister(arg);\n          } else {\n            if (resolver.normalize) {\n              arg = resolver.normalize(arg);\n              args[key] = arg;\n            }\n\n            if (resolver.assert) {\n              const error = Common.validateArg(arg, key, resolver);\n              Assert(!error, error, 'or reference');\n            }\n          }\n        }\n\n        args[key] = arg;\n      }\n    } // Unique rules\n\n\n    if (!definition.multi) {\n      obj._ruleRemove(rule.name, {\n        clone: false\n      });\n\n      obj._singleRules.set(rule.name, rule);\n    }\n\n    if (obj.$_temp.ruleset === false) {\n      obj.$_temp.ruleset = null;\n    }\n\n    if (definition.priority) {\n      obj._rules.unshift(rule);\n    } else {\n      obj._rules.push(rule);\n    }\n\n    return obj;\n  }\n\n  $_compile(schema, options) {\n    return Compile.schema(this.$_root, schema, options);\n  }\n\n  $_createError(code, value, local, state, prefs, options = {}) {\n    const flags = options.flags !== false ? this._flags : {};\n    const messages = options.messages ? Messages.merge(this._definition.messages, options.messages) : this._definition.messages;\n    return new Errors.Report(code, value, local, flags, messages, state, prefs);\n  }\n\n  $_getFlag(name) {\n    return this._flags[name];\n  }\n\n  $_getRule(name) {\n    return this._singleRules.get(name);\n  }\n\n  $_mapLabels(path) {\n    path = Array.isArray(path) ? path : path.split('.');\n    return this._ids.labels(path);\n  }\n\n  $_match(value, state, prefs, overrides) {\n    prefs = Object.assign({}, prefs); // Shallow cloned\n\n    prefs.abortEarly = true;\n    prefs._externals = false;\n    state.snapshot();\n    const result = !Validator.validate(value, this, state, prefs, overrides).errors;\n    state.restore();\n    return result;\n  }\n\n  $_modify(options) {\n    Common.assertOptions(options, ['each', 'once', 'ref', 'schema']);\n    return Modify.schema(this, options) || this;\n  }\n\n  $_mutateRebuild() {\n    Assert(!this._inRuleset(), 'Cannot add this rule inside a ruleset');\n\n    this._refs.reset();\n\n    this._ids.reset();\n\n    const each = (item, {\n      source,\n      name,\n      path,\n      key\n    }) => {\n      const family = this._definition[source][name] && this._definition[source][name].register;\n\n      if (family !== false) {\n        this.$_mutateRegister(item, {\n          family,\n          key\n        });\n      }\n    };\n\n    this.$_modify({\n      each\n    });\n\n    if (this._definition.rebuild) {\n      this._definition.rebuild(this);\n    }\n\n    this.$_temp.ruleset = false;\n    return this;\n  }\n\n  $_mutateRegister(schema, {\n    family,\n    key\n  } = {}) {\n    this._refs.register(schema, family);\n\n    this._ids.register(schema, {\n      key\n    });\n  }\n\n  $_property(name) {\n    return this._definition.properties[name];\n  }\n\n  $_reach(path) {\n    return this._ids.reach(path);\n  }\n\n  $_rootReferences() {\n    return this._refs.roots();\n  }\n\n  $_setFlag(name, value, options = {}) {\n    Assert(name[0] === '_' || !this._inRuleset(), 'Cannot set flag inside a ruleset');\n    const flag = this._definition.flags[name] || {};\n\n    if (DeepEqual(value, flag.default)) {\n      value = undefined;\n    }\n\n    if (DeepEqual(value, this._flags[name])) {\n      return this;\n    }\n\n    const obj = options.clone !== false ? this.clone() : this;\n\n    if (value !== undefined) {\n      obj._flags[name] = value;\n      obj.$_mutateRegister(value);\n    } else {\n      delete obj._flags[name];\n    }\n\n    if (name[0] !== '_') {\n      obj.$_temp.ruleset = false;\n    }\n\n    return obj;\n  }\n\n  $_parent(method, ...args) {\n    return this[method][Common.symbols.parent].call(this, ...args);\n  }\n\n  $_validate(value, state, prefs) {\n    return Validator.validate(value, this, state, prefs);\n  } // Internals\n\n\n  _assign(target) {\n    target.type = this.type;\n    target.$_root = this.$_root;\n    target.$_temp = Object.assign({}, this.$_temp);\n    target.$_temp.whens = {};\n    target._ids = this._ids.clone();\n    target._preferences = this._preferences;\n    target._valids = this._valids && this._valids.clone();\n    target._invalids = this._invalids && this._invalids.clone();\n    target._rules = this._rules.slice();\n    target._singleRules = Clone(this._singleRules, {\n      shallow: true\n    });\n    target._refs = this._refs.clone();\n    target._flags = Object.assign({}, this._flags);\n    target._cache = null;\n    target.$_terms = {};\n\n    for (const key in this.$_terms) {\n      target.$_terms[key] = this.$_terms[key] ? this.$_terms[key].slice() : null;\n    } // Backwards compatibility\n\n\n    target.$_super = {};\n\n    for (const override in this.$_super) {\n      target.$_super[override] = this._super[override].bind(target);\n    }\n\n    return target;\n  }\n\n  _bare() {\n    const obj = this.clone();\n\n    obj._reset();\n\n    const terms = obj._definition.terms;\n\n    for (const name in terms) {\n      const term = terms[name];\n      obj.$_terms[name] = term.init;\n    }\n\n    return obj.$_mutateRebuild();\n  }\n\n  _default(flag, value, options = {}) {\n    Common.assertOptions(options, 'literal');\n    Assert(value !== undefined, 'Missing', flag, 'value');\n    Assert(typeof value === 'function' || !options.literal, 'Only function value supports literal option');\n\n    if (typeof value === 'function' && options.literal) {\n      value = {\n        [Common.symbols.literal]: true,\n        literal: value\n      };\n    }\n\n    const obj = this.$_setFlag(flag, value);\n    return obj;\n  }\n\n  _generate(value, state, prefs) {\n    if (!this.$_terms.whens) {\n      return {\n        schema: this\n      };\n    } // Collect matching whens\n\n\n    const whens = [];\n    const ids = [];\n\n    for (let i = 0; i < this.$_terms.whens.length; ++i) {\n      const when = this.$_terms.whens[i];\n\n      if (when.concat) {\n        whens.push(when.concat);\n        ids.push(`${i}.concat`);\n        continue;\n      }\n\n      const input = when.ref ? when.ref.resolve(value, state, prefs) : value;\n      const tests = when.is ? [when] : when.switch;\n      const before = ids.length;\n\n      for (let j = 0; j < tests.length; ++j) {\n        const {\n          is,\n          then,\n          otherwise\n        } = tests[j];\n        const baseId = `${i}${when.switch ? '.' + j : ''}`;\n\n        if (is.$_match(input, state.nest(is, `${baseId}.is`), prefs)) {\n          if (then) {\n            const localState = state.localize([...state.path, `${baseId}.then`], state.ancestors, state.schemas);\n\n            const {\n              schema: generated,\n              id\n            } = then._generate(value, localState, prefs);\n\n            whens.push(generated);\n            ids.push(`${baseId}.then${id ? `(${id})` : ''}`);\n            break;\n          }\n        } else if (otherwise) {\n          const localState = state.localize([...state.path, `${baseId}.otherwise`], state.ancestors, state.schemas);\n\n          const {\n            schema: generated,\n            id\n          } = otherwise._generate(value, localState, prefs);\n\n          whens.push(generated);\n          ids.push(`${baseId}.otherwise${id ? `(${id})` : ''}`);\n          break;\n        }\n      }\n\n      if (when.break && ids.length > before) {\n        // Something matched\n        break;\n      }\n    } // Check cache\n\n\n    const id = ids.join(', ');\n    state.mainstay.tracer.debug(state, 'rule', 'when', id);\n\n    if (!id) {\n      return {\n        schema: this\n      };\n    }\n\n    if (!state.mainstay.tracer.active && this.$_temp.whens[id]) {\n      return {\n        schema: this.$_temp.whens[id],\n        id\n      };\n    } // Generate dynamic schema\n\n\n    let obj = this; // eslint-disable-line consistent-this\n\n    if (this._definition.generate) {\n      obj = this._definition.generate(this, value, state, prefs);\n    } // Apply whens\n\n\n    for (const when of whens) {\n      obj = obj.concat(when);\n    } // Tracing\n\n\n    if (this.$_root._tracer) {\n      this.$_root._tracer._combine(obj, [this, ...whens]);\n    } // Cache result\n\n\n    this.$_temp.whens[id] = obj;\n    return {\n      schema: obj,\n      id\n    };\n  }\n\n  _inner(type, values, options = {}) {\n    Assert(!this._inRuleset(), `Cannot set ${type} inside a ruleset`);\n    const obj = this.clone();\n\n    if (!obj.$_terms[type] || options.override) {\n      obj.$_terms[type] = [];\n    }\n\n    if (options.single) {\n      obj.$_terms[type].push(values);\n    } else {\n      obj.$_terms[type].push(...values);\n    }\n\n    obj.$_temp.ruleset = false;\n    return obj;\n  }\n\n  _inRuleset() {\n    return this.$_temp.ruleset !== null && this.$_temp.ruleset !== false;\n  }\n\n  _ruleRemove(name, options = {}) {\n    if (!this._singleRules.has(name)) {\n      return this;\n    }\n\n    const obj = options.clone !== false ? this.clone() : this;\n\n    obj._singleRules.delete(name);\n\n    const filtered = [];\n\n    for (let i = 0; i < obj._rules.length; ++i) {\n      const test = obj._rules[i];\n\n      if (test.name === name && !test.keep) {\n        if (obj._inRuleset() && i < obj.$_temp.ruleset) {\n          --obj.$_temp.ruleset;\n        }\n\n        continue;\n      }\n\n      filtered.push(test);\n    }\n\n    obj._rules = filtered;\n    return obj;\n  }\n\n  _values(values, key) {\n    Common.verifyFlat(values, key.slice(1, -1));\n    const obj = this.clone();\n    const override = values[0] === Common.symbols.override;\n\n    if (override) {\n      values = values.slice(1);\n    }\n\n    if (!obj[key] && values.length) {\n      obj[key] = new Values();\n    } else if (override) {\n      obj[key] = values.length ? new Values() : null;\n      obj.$_mutateRebuild();\n    }\n\n    if (!obj[key]) {\n      return obj;\n    }\n\n    if (override) {\n      obj[key].override();\n    }\n\n    for (const value of values) {\n      Assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\n      Assert(value !== Common.symbols.override, 'Override must be the first value');\n      const other = key === '_invalids' ? '_valids' : '_invalids';\n\n      if (obj[other]) {\n        obj[other].remove(value);\n\n        if (!obj[other].length) {\n          Assert(key === '_valids' || !obj._flags.only, 'Setting invalid value', value, 'leaves schema rejecting all values due to previous valid rule');\n          obj[other] = null;\n        }\n      }\n\n      obj[key].add(value, obj._refs);\n    }\n\n    return obj;\n  }\n\n};\ninternals.Base.prototype[Common.symbols.any] = {\n  version: Common.version,\n  compile: Compile.compile,\n  root: '$_root'\n};\ninternals.Base.prototype.isImmutable = true; // Prevents Hoek from deep cloning schema objects (must be on prototype)\n// Aliases\n\ninternals.Base.prototype.deny = internals.Base.prototype.invalid;\ninternals.Base.prototype.disallow = internals.Base.prototype.invalid;\ninternals.Base.prototype.equal = internals.Base.prototype.valid;\ninternals.Base.prototype.exist = internals.Base.prototype.required;\ninternals.Base.prototype.not = internals.Base.prototype.invalid;\ninternals.Base.prototype.options = internals.Base.prototype.prefs;\ninternals.Base.prototype.preferences = internals.Base.prototype.prefs;\nmodule.exports = new internals.Base();","map":{"version":3,"sources":["C:/scripting/jobs assignments/whist/backend/node_modules/joi/lib/base.js"],"names":["Assert","require","Clone","DeepEqual","Merge","Cache","Common","Compile","Errors","Extend","Manifest","Messages","Modify","Ref","Trace","Validator","Values","internals","Base","constructor","type","$_root","_definition","_reset","_ids","Ids","_preferences","_refs","Manager","_cache","_valids","_invalids","_flags","_rules","_singleRules","Map","$_terms","$_temp","ruleset","whens","describe","allow","values","verifyFlat","_values","alter","targets","Array","isArray","_inRuleset","obj","clone","alterations","target","adjuster","push","artifact","id","undefined","$_setFlag","cast","to","default","value","options","_default","description","desc","empty","schema","$_compile","override","error","err","Error","example","assertOptions","_inner","single","external","method","failover","forbidden","presence","test","invalid","label","name","meta","note","notes","length","only","mode","optional","prefs","context","externals","warnings","debug","checkPreferences","preferences","includes","raw","enabled","result","required","strict","convert","strip","tag","tags","unit","valid","when","condition","conditions","is","switch","item","then","otherwise","$_mutateRebuild","cache","provider","provision","Object","create","getPrototypeOf","_assign","concat","source","isSchema","tmpObj","key","keys","register","toSibling","merge","has","filter","keep","delete","rules","multi","set","flags","assign","terms","slice","_tracer","_combine","extend","base","extract","path","split","reach","fork","paths","rule","def","modifiers","start","i","original","get","$","tailor","$_modify","each","ref","tracer","location","validate","entry","validateAsync","entryAsync","$_addRule","_resolve","definition","args","arg","argsByName","resolver","isResolvable","$_mutateRegister","normalize","assert","validateArg","_ruleRemove","priority","unshift","$_createError","code","local","state","messages","Report","$_getFlag","$_getRule","$_mapLabels","labels","$_match","overrides","abortEarly","_externals","snapshot","errors","restore","reset","family","rebuild","$_property","properties","$_reach","$_rootReferences","roots","flag","$_parent","symbols","parent","call","$_validate","shallow","$_super","_super","bind","_bare","term","init","literal","_generate","ids","input","resolve","tests","before","j","baseId","nest","localState","localize","ancestors","schemas","generated","break","join","mainstay","active","generate","filtered","other","remove","add","prototype","any","version","compile","root","isImmutable","deny","disallow","equal","exist","not","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst Assert = require('@hapi/hoek/lib/assert');\nconst Clone = require('@hapi/hoek/lib/clone');\nconst DeepEqual = require('@hapi/hoek/lib/deepEqual');\nconst Merge = require('@hapi/hoek/lib/merge');\n\nconst Cache = require('./cache');\nconst Common = require('./common');\nconst Compile = require('./compile');\nconst Errors = require('./errors');\nconst Extend = require('./extend');\nconst Manifest = require('./manifest');\nconst Messages = require('./messages');\nconst Modify = require('./modify');\nconst Ref = require('./ref');\nconst Trace = require('./trace');\nconst Validator = require('./validator');\nconst Values = require('./values');\n\n\nconst internals = {};\n\n\ninternals.Base = class {\n\n    constructor(type) {\n\n        // Naming: public, _private, $_extension, $_mutate{action}\n\n        this.type = type;\n\n        this.$_root = null;\n        this._definition = {};\n        this._reset();\n    }\n\n    _reset() {\n\n        this._ids = new Modify.Ids();\n        this._preferences = null;\n        this._refs = new Ref.Manager();\n        this._cache = null;\n\n        this._valids = null;\n        this._invalids = null;\n\n        this._flags = {};\n        this._rules = [];\n        this._singleRules = new Map();              // The rule options passed for non-multi rules\n\n        this.$_terms = {};                          // Hash of arrays of immutable objects (extended by other types)\n\n        this.$_temp = {                             // Runtime state (not cloned)\n            ruleset: null,                          // null: use last, false: error, number: start position\n            whens: {}                               // Runtime cache of generated whens\n        };\n    }\n\n    // Manifest\n\n    describe() {\n\n        Assert(typeof Manifest.describe === 'function', 'Manifest functionality disabled');\n        return Manifest.describe(this);\n    }\n\n    // Rules\n\n    allow(...values) {\n\n        Common.verifyFlat(values, 'allow');\n        return this._values(values, '_valids');\n    }\n\n    alter(targets) {\n\n        Assert(targets && typeof targets === 'object' && !Array.isArray(targets), 'Invalid targets argument');\n        Assert(!this._inRuleset(), 'Cannot set alterations inside a ruleset');\n\n        const obj = this.clone();\n        obj.$_terms.alterations = obj.$_terms.alterations || [];\n        for (const target in targets) {\n            const adjuster = targets[target];\n            Assert(typeof adjuster === 'function', 'Alteration adjuster for', target, 'must be a function');\n            obj.$_terms.alterations.push({ target, adjuster });\n        }\n\n        obj.$_temp.ruleset = false;\n        return obj;\n    }\n\n    artifact(id) {\n\n        Assert(id !== undefined, 'Artifact cannot be undefined');\n        Assert(!this._cache, 'Cannot set an artifact with a rule cache');\n\n        return this.$_setFlag('artifact', id);\n    }\n\n    cast(to) {\n\n        Assert(to === false || typeof to === 'string', 'Invalid to value');\n        Assert(to === false || this._definition.cast[to], 'Type', this.type, 'does not support casting to', to);\n\n        return this.$_setFlag('cast', to === false ? undefined : to);\n    }\n\n    default(value, options) {\n\n        return this._default('default', value, options);\n    }\n\n    description(desc) {\n\n        Assert(desc && typeof desc === 'string', 'Description must be a non-empty string');\n\n        return this.$_setFlag('description', desc);\n    }\n\n    empty(schema) {\n\n        const obj = this.clone();\n\n        if (schema !== undefined) {\n            schema = obj.$_compile(schema, { override: false });\n        }\n\n        return obj.$_setFlag('empty', schema, { clone: false });\n    }\n\n    error(err) {\n\n        Assert(err, 'Missing error');\n        Assert(err instanceof Error || typeof err === 'function', 'Must provide a valid Error object or a function');\n\n        return this.$_setFlag('error', err);\n    }\n\n    example(example, options = {}) {\n\n        Assert(example !== undefined, 'Missing example');\n        Common.assertOptions(options, ['override']);\n\n        return this._inner('examples', example, { single: true, override: options.override });\n    }\n\n    external(method, description) {\n\n        if (typeof method === 'object') {\n            Assert(!description, 'Cannot combine options with description');\n            description = method.description;\n            method = method.method;\n        }\n\n        Assert(typeof method === 'function', 'Method must be a function');\n        Assert(description === undefined || description && typeof description === 'string', 'Description must be a non-empty string');\n\n        return this._inner('externals', { method, description }, { single: true });\n    }\n\n    failover(value, options) {\n\n        return this._default('failover', value, options);\n    }\n\n    forbidden() {\n\n        return this.presence('forbidden');\n    }\n\n    id(id) {\n\n        if (!id) {\n            return this.$_setFlag('id', undefined);\n        }\n\n        Assert(typeof id === 'string', 'id must be a non-empty string');\n        Assert(/^[^\\.]+$/.test(id), 'id cannot contain period character');\n\n        return this.$_setFlag('id', id);\n    }\n\n    invalid(...values) {\n\n        return this._values(values, '_invalids');\n    }\n\n    label(name) {\n\n        Assert(name && typeof name === 'string', 'Label name must be a non-empty string');\n\n        return this.$_setFlag('label', name);\n    }\n\n    meta(meta) {\n\n        Assert(meta !== undefined, 'Meta cannot be undefined');\n\n        return this._inner('metas', meta, { single: true });\n    }\n\n    note(...notes) {\n\n        Assert(notes.length, 'Missing notes');\n        for (const note of notes) {\n            Assert(note && typeof note === 'string', 'Notes must be non-empty strings');\n        }\n\n        return this._inner('notes', notes);\n    }\n\n    only(mode = true) {\n\n        Assert(typeof mode === 'boolean', 'Invalid mode:', mode);\n\n        return this.$_setFlag('only', mode);\n    }\n\n    optional() {\n\n        return this.presence('optional');\n    }\n\n    prefs(prefs) {\n\n        Assert(prefs, 'Missing preferences');\n        Assert(prefs.context === undefined, 'Cannot override context');\n        Assert(prefs.externals === undefined, 'Cannot override externals');\n        Assert(prefs.warnings === undefined, 'Cannot override warnings');\n        Assert(prefs.debug === undefined, 'Cannot override debug');\n\n        Common.checkPreferences(prefs);\n\n        const obj = this.clone();\n        obj._preferences = Common.preferences(obj._preferences, prefs);\n        return obj;\n    }\n\n    presence(mode) {\n\n        Assert(['optional', 'required', 'forbidden'].includes(mode), 'Unknown presence mode', mode);\n\n        return this.$_setFlag('presence', mode);\n    }\n\n    raw(enabled = true) {\n\n        return this.$_setFlag('result', enabled ? 'raw' : undefined);\n    }\n\n    result(mode) {\n\n        Assert(['raw', 'strip'].includes(mode), 'Unknown result mode', mode);\n\n        return this.$_setFlag('result', mode);\n    }\n\n    required() {\n\n        return this.presence('required');\n    }\n\n    strict(enabled) {\n\n        const obj = this.clone();\n\n        const convert = enabled === undefined ? false : !enabled;\n        obj._preferences = Common.preferences(obj._preferences, { convert });\n        return obj;\n    }\n\n    strip(enabled = true) {\n\n        return this.$_setFlag('result', enabled ? 'strip' : undefined);\n    }\n\n    tag(...tags) {\n\n        Assert(tags.length, 'Missing tags');\n        for (const tag of tags) {\n            Assert(tag && typeof tag === 'string', 'Tags must be non-empty strings');\n        }\n\n        return this._inner('tags', tags);\n    }\n\n    unit(name) {\n\n        Assert(name && typeof name === 'string', 'Unit name must be a non-empty string');\n\n        return this.$_setFlag('unit', name);\n    }\n\n    valid(...values) {\n\n        Common.verifyFlat(values, 'valid');\n\n        const obj = this.allow(...values);\n        obj.$_setFlag('only', !!obj._valids, { clone: false });\n        return obj;\n    }\n\n    when(condition, options) {\n\n        const obj = this.clone();\n\n        if (!obj.$_terms.whens) {\n            obj.$_terms.whens = [];\n        }\n\n        const when = Compile.when(obj, condition, options);\n        if (!['any', 'link'].includes(obj.type)) {\n            const conditions = when.is ? [when] : when.switch;\n            for (const item of conditions) {\n                Assert(!item.then || item.then.type === 'any' || item.then.type === obj.type, 'Cannot combine', obj.type, 'with', item.then && item.then.type);\n                Assert(!item.otherwise || item.otherwise.type === 'any' || item.otherwise.type === obj.type, 'Cannot combine', obj.type, 'with', item.otherwise && item.otherwise.type);\n\n            }\n        }\n\n        obj.$_terms.whens.push(when);\n        return obj.$_mutateRebuild();\n    }\n\n    // Helpers\n\n    cache(cache) {\n\n        Assert(!this._inRuleset(), 'Cannot set caching inside a ruleset');\n        Assert(!this._cache, 'Cannot override schema cache');\n        Assert(this._flags.artifact === undefined, 'Cannot cache a rule with an artifact');\n\n        const obj = this.clone();\n        obj._cache = cache || Cache.provider.provision();\n        obj.$_temp.ruleset = false;\n        return obj;\n    }\n\n    clone() {\n\n        const obj = Object.create(Object.getPrototypeOf(this));\n        return this._assign(obj);\n    }\n\n    concat(source) {\n\n        Assert(Common.isSchema(source), 'Invalid schema object');\n        Assert(this.type === 'any' || source.type === 'any' || source.type === this.type, 'Cannot merge type', this.type, 'with another type:', source.type);\n        Assert(!this._inRuleset(), 'Cannot concatenate onto a schema with open ruleset');\n        Assert(!source._inRuleset(), 'Cannot concatenate a schema with open ruleset');\n\n        let obj = this.clone();\n\n        if (this.type === 'any' &&\n            source.type !== 'any') {\n\n            // Change obj to match source type\n\n            const tmpObj = source.clone();\n            for (const key of Object.keys(obj)) {\n                if (key !== 'type') {\n                    tmpObj[key] = obj[key];\n                }\n            }\n\n            obj = tmpObj;\n        }\n\n        obj._ids.concat(source._ids);\n        obj._refs.register(source, Ref.toSibling);\n\n        obj._preferences = obj._preferences ? Common.preferences(obj._preferences, source._preferences) : source._preferences;\n        obj._valids = Values.merge(obj._valids, source._valids, source._invalids);\n        obj._invalids = Values.merge(obj._invalids, source._invalids, source._valids);\n\n        // Remove unique rules present in source\n\n        for (const name of source._singleRules.keys()) {\n            if (obj._singleRules.has(name)) {\n                obj._rules = obj._rules.filter((target) => target.keep || target.name !== name);\n                obj._singleRules.delete(name);\n            }\n        }\n\n        // Rules\n\n        for (const test of source._rules) {\n            if (!source._definition.rules[test.method].multi) {\n                obj._singleRules.set(test.name, test);\n            }\n\n            obj._rules.push(test);\n        }\n\n        // Flags\n\n        if (obj._flags.empty &&\n            source._flags.empty) {\n\n            obj._flags.empty = obj._flags.empty.concat(source._flags.empty);\n            const flags = Object.assign({}, source._flags);\n            delete flags.empty;\n            Merge(obj._flags, flags);\n        }\n        else if (source._flags.empty) {\n            obj._flags.empty = source._flags.empty;\n            const flags = Object.assign({}, source._flags);\n            delete flags.empty;\n            Merge(obj._flags, flags);\n        }\n        else {\n            Merge(obj._flags, source._flags);\n        }\n\n        // Terms\n\n        for (const key in source.$_terms) {\n            const terms = source.$_terms[key];\n            if (!terms) {\n                if (!obj.$_terms[key]) {\n                    obj.$_terms[key] = terms;\n                }\n\n                continue;\n            }\n\n            if (!obj.$_terms[key]) {\n                obj.$_terms[key] = terms.slice();\n                continue;\n            }\n\n            obj.$_terms[key] = obj.$_terms[key].concat(terms);\n        }\n\n        // Tracing\n\n        if (this.$_root._tracer) {\n            this.$_root._tracer._combine(obj, [this, source]);\n        }\n\n        // Rebuild\n\n        return obj.$_mutateRebuild();\n    }\n\n    extend(options) {\n\n        Assert(!options.base, 'Cannot extend type with another base');\n\n        return Extend.type(this, options);\n    }\n\n    extract(path) {\n\n        path = Array.isArray(path) ? path : path.split('.');\n        return this._ids.reach(path);\n    }\n\n    fork(paths, adjuster) {\n\n        Assert(!this._inRuleset(), 'Cannot fork inside a ruleset');\n\n        let obj = this;                                             // eslint-disable-line consistent-this\n        for (let path of [].concat(paths)) {\n            path = Array.isArray(path) ? path : path.split('.');\n            obj = obj._ids.fork(path, adjuster, obj);\n        }\n\n        obj.$_temp.ruleset = false;\n        return obj;\n    }\n\n    rule(options) {\n\n        const def = this._definition;\n        Common.assertOptions(options, Object.keys(def.modifiers));\n\n        Assert(this.$_temp.ruleset !== false, 'Cannot apply rules to empty ruleset or the last rule added does not support rule properties');\n        const start = this.$_temp.ruleset === null ? this._rules.length - 1 : this.$_temp.ruleset;\n        Assert(start >= 0 && start < this._rules.length, 'Cannot apply rules to empty ruleset');\n\n        const obj = this.clone();\n\n        for (let i = start; i < obj._rules.length; ++i) {\n            const original = obj._rules[i];\n            const rule = Clone(original);\n\n            for (const name in options) {\n                def.modifiers[name](rule, options[name]);\n                Assert(rule.name === original.name, 'Cannot change rule name');\n            }\n\n            obj._rules[i] = rule;\n\n            if (obj._singleRules.get(rule.name) === original) {\n                obj._singleRules.set(rule.name, rule);\n            }\n        }\n\n        obj.$_temp.ruleset = false;\n        return obj.$_mutateRebuild();\n    }\n\n    get ruleset() {\n\n        Assert(!this._inRuleset(), 'Cannot start a new ruleset without closing the previous one');\n\n        const obj = this.clone();\n        obj.$_temp.ruleset = obj._rules.length;\n        return obj;\n    }\n\n    get $() {\n\n        return this.ruleset;\n    }\n\n    tailor(targets) {\n\n        targets = [].concat(targets);\n\n        Assert(!this._inRuleset(), 'Cannot tailor inside a ruleset');\n\n        let obj = this;                                                     // eslint-disable-line consistent-this\n\n        if (this.$_terms.alterations) {\n            for (const { target, adjuster } of this.$_terms.alterations) {\n                if (targets.includes(target)) {\n                    obj = adjuster(obj);\n                    Assert(Common.isSchema(obj), 'Alteration adjuster for', target, 'failed to return a schema object');\n                }\n            }\n        }\n\n        obj = obj.$_modify({ each: (item) => item.tailor(targets), ref: false });\n        obj.$_temp.ruleset = false;\n        return obj.$_mutateRebuild();\n    }\n\n    tracer() {\n\n        return Trace.location ? Trace.location(this) : this;                // $lab:coverage:ignore$\n    }\n\n    validate(value, options) {\n\n        return Validator.entry(value, this, options);\n    }\n\n    validateAsync(value, options) {\n\n        return Validator.entryAsync(value, this, options);\n    }\n\n    // Extensions\n\n    $_addRule(options) {\n\n        // Normalize rule\n\n        if (typeof options === 'string') {\n            options = { name: options };\n        }\n\n        Assert(options && typeof options === 'object', 'Invalid options');\n        Assert(options.name && typeof options.name === 'string', 'Invalid rule name');\n\n        for (const key in options) {\n            Assert(key[0] !== '_', 'Cannot set private rule properties');\n        }\n\n        const rule = Object.assign({}, options);        // Shallow cloned\n        rule._resolve = [];\n        rule.method = rule.method || rule.name;\n\n        const definition = this._definition.rules[rule.method];\n        const args = rule.args;\n\n        Assert(definition, 'Unknown rule', rule.method);\n\n        // Args\n\n        const obj = this.clone();\n\n        if (args) {\n            Assert(Object.keys(args).length === 1 || Object.keys(args).length === this._definition.rules[rule.name].args.length, 'Invalid rule definition for', this.type, rule.name);\n\n            for (const key in args) {\n                let arg = args[key];\n                if (arg === undefined) {\n                    delete args[key];\n                    continue;\n                }\n\n                if (definition.argsByName) {\n                    const resolver = definition.argsByName.get(key);\n\n                    if (resolver.ref &&\n                        Common.isResolvable(arg)) {\n\n                        rule._resolve.push(key);\n                        obj.$_mutateRegister(arg);\n                    }\n                    else {\n                        if (resolver.normalize) {\n                            arg = resolver.normalize(arg);\n                            args[key] = arg;\n                        }\n\n                        if (resolver.assert) {\n                            const error = Common.validateArg(arg, key, resolver);\n                            Assert(!error, error, 'or reference');\n                        }\n                    }\n                }\n\n                args[key] = arg;\n            }\n        }\n\n        // Unique rules\n\n        if (!definition.multi) {\n            obj._ruleRemove(rule.name, { clone: false });\n            obj._singleRules.set(rule.name, rule);\n        }\n\n        if (obj.$_temp.ruleset === false) {\n            obj.$_temp.ruleset = null;\n        }\n\n        if (definition.priority) {\n            obj._rules.unshift(rule);\n        }\n        else {\n            obj._rules.push(rule);\n        }\n\n        return obj;\n    }\n\n    $_compile(schema, options) {\n\n        return Compile.schema(this.$_root, schema, options);\n    }\n\n    $_createError(code, value, local, state, prefs, options = {}) {\n\n        const flags = options.flags !== false ? this._flags : {};\n        const messages = options.messages ? Messages.merge(this._definition.messages, options.messages) : this._definition.messages;\n        return new Errors.Report(code, value, local, flags, messages, state, prefs);\n    }\n\n    $_getFlag(name) {\n\n        return this._flags[name];\n    }\n\n    $_getRule(name) {\n\n        return this._singleRules.get(name);\n    }\n\n    $_mapLabels(path) {\n\n        path = Array.isArray(path) ? path : path.split('.');\n        return this._ids.labels(path);\n    }\n\n    $_match(value, state, prefs, overrides) {\n\n        prefs = Object.assign({}, prefs);       // Shallow cloned\n        prefs.abortEarly = true;\n        prefs._externals = false;\n\n        state.snapshot();\n        const result = !Validator.validate(value, this, state, prefs, overrides).errors;\n        state.restore();\n\n        return result;\n    }\n\n    $_modify(options) {\n\n        Common.assertOptions(options, ['each', 'once', 'ref', 'schema']);\n        return Modify.schema(this, options) || this;\n    }\n\n    $_mutateRebuild() {\n\n        Assert(!this._inRuleset(), 'Cannot add this rule inside a ruleset');\n\n        this._refs.reset();\n        this._ids.reset();\n\n        const each = (item, { source, name, path, key }) => {\n\n            const family = this._definition[source][name] && this._definition[source][name].register;\n            if (family !== false) {\n                this.$_mutateRegister(item, { family, key });\n            }\n        };\n\n        this.$_modify({ each });\n\n        if (this._definition.rebuild) {\n            this._definition.rebuild(this);\n        }\n\n        this.$_temp.ruleset = false;\n        return this;\n    }\n\n    $_mutateRegister(schema, { family, key } = {}) {\n\n        this._refs.register(schema, family);\n        this._ids.register(schema, { key });\n    }\n\n    $_property(name) {\n\n        return this._definition.properties[name];\n    }\n\n    $_reach(path) {\n\n        return this._ids.reach(path);\n    }\n\n    $_rootReferences() {\n\n        return this._refs.roots();\n    }\n\n    $_setFlag(name, value, options = {}) {\n\n        Assert(name[0] === '_' || !this._inRuleset(), 'Cannot set flag inside a ruleset');\n\n        const flag = this._definition.flags[name] || {};\n        if (DeepEqual(value, flag.default)) {\n            value = undefined;\n        }\n\n        if (DeepEqual(value, this._flags[name])) {\n            return this;\n        }\n\n        const obj = options.clone !== false ? this.clone() : this;\n\n        if (value !== undefined) {\n            obj._flags[name] = value;\n            obj.$_mutateRegister(value);\n        }\n        else {\n            delete obj._flags[name];\n        }\n\n        if (name[0] !== '_') {\n            obj.$_temp.ruleset = false;\n        }\n\n        return obj;\n    }\n\n    $_parent(method, ...args) {\n\n        return this[method][Common.symbols.parent].call(this, ...args);\n    }\n\n    $_validate(value, state, prefs) {\n\n        return Validator.validate(value, this, state, prefs);\n    }\n\n    // Internals\n\n    _assign(target) {\n\n        target.type = this.type;\n\n        target.$_root = this.$_root;\n\n        target.$_temp = Object.assign({}, this.$_temp);\n        target.$_temp.whens = {};\n\n        target._ids = this._ids.clone();\n        target._preferences = this._preferences;\n        target._valids = this._valids && this._valids.clone();\n        target._invalids = this._invalids && this._invalids.clone();\n        target._rules = this._rules.slice();\n        target._singleRules = Clone(this._singleRules, { shallow: true });\n        target._refs = this._refs.clone();\n        target._flags = Object.assign({}, this._flags);\n        target._cache = null;\n\n        target.$_terms = {};\n        for (const key in this.$_terms) {\n            target.$_terms[key] = this.$_terms[key] ? this.$_terms[key].slice() : null;\n        }\n\n        // Backwards compatibility\n\n        target.$_super = {};\n        for (const override in this.$_super) {\n            target.$_super[override] = this._super[override].bind(target);\n        }\n\n        return target;\n    }\n\n    _bare() {\n\n        const obj = this.clone();\n        obj._reset();\n\n        const terms = obj._definition.terms;\n        for (const name in terms) {\n            const term = terms[name];\n            obj.$_terms[name] = term.init;\n        }\n\n        return obj.$_mutateRebuild();\n    }\n\n    _default(flag, value, options = {}) {\n\n        Common.assertOptions(options, 'literal');\n\n        Assert(value !== undefined, 'Missing', flag, 'value');\n        Assert(typeof value === 'function' || !options.literal, 'Only function value supports literal option');\n\n        if (typeof value === 'function' &&\n            options.literal) {\n\n            value = {\n                [Common.symbols.literal]: true,\n                literal: value\n            };\n        }\n\n        const obj = this.$_setFlag(flag, value);\n        return obj;\n    }\n\n    _generate(value, state, prefs) {\n\n        if (!this.$_terms.whens) {\n            return { schema: this };\n        }\n\n        // Collect matching whens\n\n        const whens = [];\n        const ids = [];\n        for (let i = 0; i < this.$_terms.whens.length; ++i) {\n            const when = this.$_terms.whens[i];\n\n            if (when.concat) {\n                whens.push(when.concat);\n                ids.push(`${i}.concat`);\n                continue;\n            }\n\n            const input = when.ref ? when.ref.resolve(value, state, prefs) : value;\n            const tests = when.is ? [when] : when.switch;\n            const before = ids.length;\n\n            for (let j = 0; j < tests.length; ++j) {\n                const { is, then, otherwise } = tests[j];\n\n                const baseId = `${i}${when.switch ? '.' + j : ''}`;\n                if (is.$_match(input, state.nest(is, `${baseId}.is`), prefs)) {\n                    if (then) {\n                        const localState = state.localize([...state.path, `${baseId}.then`], state.ancestors, state.schemas);\n                        const { schema: generated, id } = then._generate(value, localState, prefs);\n                        whens.push(generated);\n                        ids.push(`${baseId}.then${id ? `(${id})` : ''}`);\n                        break;\n                    }\n                }\n                else if (otherwise) {\n                    const localState = state.localize([...state.path, `${baseId}.otherwise`], state.ancestors, state.schemas);\n                    const { schema: generated, id } = otherwise._generate(value, localState, prefs);\n                    whens.push(generated);\n                    ids.push(`${baseId}.otherwise${id ? `(${id})` : ''}`);\n                    break;\n                }\n            }\n\n            if (when.break &&\n                ids.length > before) {          // Something matched\n\n                break;\n            }\n        }\n\n        // Check cache\n\n        const id = ids.join(', ');\n        state.mainstay.tracer.debug(state, 'rule', 'when', id);\n\n        if (!id) {\n            return { schema: this };\n        }\n\n        if (!state.mainstay.tracer.active &&\n            this.$_temp.whens[id]) {\n\n            return { schema: this.$_temp.whens[id], id };\n        }\n\n        // Generate dynamic schema\n\n        let obj = this;                                             // eslint-disable-line consistent-this\n        if (this._definition.generate) {\n            obj = this._definition.generate(this, value, state, prefs);\n        }\n\n        // Apply whens\n\n        for (const when of whens) {\n            obj = obj.concat(when);\n        }\n\n        // Tracing\n\n        if (this.$_root._tracer) {\n            this.$_root._tracer._combine(obj, [this, ...whens]);\n        }\n\n        // Cache result\n\n        this.$_temp.whens[id] = obj;\n        return { schema: obj, id };\n    }\n\n    _inner(type, values, options = {}) {\n\n        Assert(!this._inRuleset(), `Cannot set ${type} inside a ruleset`);\n\n        const obj = this.clone();\n        if (!obj.$_terms[type] ||\n            options.override) {\n\n            obj.$_terms[type] = [];\n        }\n\n        if (options.single) {\n            obj.$_terms[type].push(values);\n        }\n        else {\n            obj.$_terms[type].push(...values);\n        }\n\n        obj.$_temp.ruleset = false;\n        return obj;\n    }\n\n    _inRuleset() {\n\n        return this.$_temp.ruleset !== null && this.$_temp.ruleset !== false;\n    }\n\n    _ruleRemove(name, options = {}) {\n\n        if (!this._singleRules.has(name)) {\n            return this;\n        }\n\n        const obj = options.clone !== false ? this.clone() : this;\n\n        obj._singleRules.delete(name);\n\n        const filtered = [];\n        for (let i = 0; i < obj._rules.length; ++i) {\n            const test = obj._rules[i];\n            if (test.name === name &&\n                !test.keep) {\n\n                if (obj._inRuleset() &&\n                    i < obj.$_temp.ruleset) {\n\n                    --obj.$_temp.ruleset;\n                }\n\n                continue;\n            }\n\n            filtered.push(test);\n        }\n\n        obj._rules = filtered;\n        return obj;\n    }\n\n    _values(values, key) {\n\n        Common.verifyFlat(values, key.slice(1, -1));\n\n        const obj = this.clone();\n\n        const override = values[0] === Common.symbols.override;\n        if (override) {\n            values = values.slice(1);\n        }\n\n        if (!obj[key] &&\n            values.length) {\n\n            obj[key] = new Values();\n        }\n        else if (override) {\n            obj[key] = values.length ? new Values() : null;\n            obj.$_mutateRebuild();\n        }\n\n        if (!obj[key]) {\n            return obj;\n        }\n\n        if (override) {\n            obj[key].override();\n        }\n\n        for (const value of values) {\n            Assert(value !== undefined, 'Cannot call allow/valid/invalid with undefined');\n            Assert(value !== Common.symbols.override, 'Override must be the first value');\n\n            const other = key === '_invalids' ? '_valids' : '_invalids';\n            if (obj[other]) {\n                obj[other].remove(value);\n                if (!obj[other].length) {\n                    Assert(key === '_valids' || !obj._flags.only, 'Setting invalid value', value, 'leaves schema rejecting all values due to previous valid rule');\n                    obj[other] = null;\n                }\n            }\n\n            obj[key].add(value, obj._refs);\n        }\n\n        return obj;\n    }\n};\n\n\ninternals.Base.prototype[Common.symbols.any] = {\n    version: Common.version,\n    compile: Compile.compile,\n    root: '$_root'\n};\n\n\ninternals.Base.prototype.isImmutable = true;                // Prevents Hoek from deep cloning schema objects (must be on prototype)\n\n\n// Aliases\n\ninternals.Base.prototype.deny = internals.Base.prototype.invalid;\ninternals.Base.prototype.disallow = internals.Base.prototype.invalid;\ninternals.Base.prototype.equal = internals.Base.prototype.valid;\ninternals.Base.prototype.exist = internals.Base.prototype.required;\ninternals.Base.prototype.not = internals.Base.prototype.invalid;\ninternals.Base.prototype.options = internals.Base.prototype.prefs;\ninternals.Base.prototype.preferences = internals.Base.prototype.prefs;\n\n\nmodule.exports = new internals.Base();\n"]},"metadata":{},"sourceType":"script"}