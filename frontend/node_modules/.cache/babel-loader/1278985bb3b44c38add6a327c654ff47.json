{"ast":null,"code":"'use strict';\n\nconst Assert = require('@hapi/hoek/lib/assert');\n\nconst DeepEqual = require('@hapi/hoek/lib/deepEqual');\n\nconst Reach = require('@hapi/hoek/lib/reach');\n\nconst Any = require('./any');\n\nconst Common = require('../common');\n\nconst Compile = require('../compile');\n\nconst internals = {};\nmodule.exports = Any.extend({\n  type: 'array',\n  flags: {\n    single: {\n      default: false\n    },\n    sparse: {\n      default: false\n    }\n  },\n  terms: {\n    items: {\n      init: [],\n      manifest: 'schema'\n    },\n    ordered: {\n      init: [],\n      manifest: 'schema'\n    },\n    _exclusions: {\n      init: []\n    },\n    _inclusions: {\n      init: []\n    },\n    _requireds: {\n      init: []\n    }\n  },\n  coerce: {\n    from: 'object',\n\n    method(value, {\n      schema,\n      state,\n      prefs\n    }) {\n      if (!Array.isArray(value)) {\n        return;\n      }\n\n      const sort = schema.$_getRule('sort');\n\n      if (!sort) {\n        return;\n      }\n\n      return internals.sort(schema, value, sort.args.options, state, prefs);\n    }\n\n  },\n\n  validate(value, {\n    schema,\n    error\n  }) {\n    if (!Array.isArray(value)) {\n      if (schema._flags.single) {\n        const single = [value];\n        single[Common.symbols.arraySingle] = true;\n        return {\n          value: single\n        };\n      }\n\n      return {\n        errors: error('array.base')\n      };\n    }\n\n    if (!schema.$_getRule('items') && !schema.$_terms.externals) {\n      return;\n    }\n\n    return {\n      value: value.slice()\n    }; // Clone the array so that we don't modify the original\n  },\n\n  rules: {\n    has: {\n      method(schema) {\n        schema = this.$_compile(schema, {\n          appendPath: true\n        });\n        const obj = this.$_addRule({\n          name: 'has',\n          args: {\n            schema\n          }\n        });\n        obj.$_mutateRegister(schema);\n        return obj;\n      },\n\n      validate(value, {\n        state,\n        prefs,\n        error\n      }, {\n        schema: has\n      }) {\n        const ancestors = [value, ...state.ancestors];\n\n        for (let i = 0; i < value.length; ++i) {\n          const localState = state.localize([...state.path, i], ancestors, has);\n\n          if (has.$_match(value[i], localState, prefs)) {\n            return value;\n          }\n        }\n\n        const patternLabel = has._flags.label;\n\n        if (patternLabel) {\n          return error('array.hasKnown', {\n            patternLabel\n          });\n        }\n\n        return error('array.hasUnknown', null);\n      },\n\n      multi: true\n    },\n    items: {\n      method(...schemas) {\n        Common.verifyFlat(schemas, 'items');\n        const obj = this.$_addRule('items');\n\n        for (let i = 0; i < schemas.length; ++i) {\n          const type = Common.tryWithPath(() => this.$_compile(schemas[i]), i, {\n            append: true\n          });\n          obj.$_terms.items.push(type);\n        }\n\n        return obj.$_mutateRebuild();\n      },\n\n      validate(value, {\n        schema,\n        error,\n        state,\n        prefs,\n        errorsArray\n      }) {\n        const requireds = schema.$_terms._requireds.slice();\n\n        const ordereds = schema.$_terms.ordered.slice();\n        const inclusions = [...schema.$_terms._inclusions, ...requireds];\n        const wasArray = !value[Common.symbols.arraySingle];\n        delete value[Common.symbols.arraySingle];\n        const errors = errorsArray();\n        let il = value.length;\n\n        for (let i = 0; i < il; ++i) {\n          const item = value[i];\n          let errored = false;\n          let isValid = false;\n          const key = wasArray ? i : new Number(i); // eslint-disable-line no-new-wrappers\n\n          const path = [...state.path, key]; // Sparse\n\n          if (!schema._flags.sparse && item === undefined) {\n            errors.push(error('array.sparse', {\n              key,\n              path,\n              pos: i,\n              value: undefined\n            }, state.localize(path)));\n\n            if (prefs.abortEarly) {\n              return errors;\n            }\n\n            ordereds.shift();\n            continue;\n          } // Exclusions\n\n\n          const ancestors = [value, ...state.ancestors];\n\n          for (const exclusion of schema.$_terms._exclusions) {\n            if (!exclusion.$_match(item, state.localize(path, ancestors, exclusion), prefs, {\n              presence: 'ignore'\n            })) {\n              continue;\n            }\n\n            errors.push(error('array.excludes', {\n              pos: i,\n              value: item\n            }, state.localize(path)));\n\n            if (prefs.abortEarly) {\n              return errors;\n            }\n\n            errored = true;\n            ordereds.shift();\n            break;\n          }\n\n          if (errored) {\n            continue;\n          } // Ordered\n\n\n          if (schema.$_terms.ordered.length) {\n            if (ordereds.length) {\n              const ordered = ordereds.shift();\n              const res = ordered.$_validate(item, state.localize(path, ancestors, ordered), prefs);\n\n              if (!res.errors) {\n                if (ordered._flags.result === 'strip') {\n                  internals.fastSplice(value, i);\n                  --i;\n                  --il;\n                } else if (!schema._flags.sparse && res.value === undefined) {\n                  errors.push(error('array.sparse', {\n                    key,\n                    path,\n                    pos: i,\n                    value: undefined\n                  }, state.localize(path)));\n\n                  if (prefs.abortEarly) {\n                    return errors;\n                  }\n\n                  continue;\n                } else {\n                  value[i] = res.value;\n                }\n              } else {\n                errors.push(...res.errors);\n\n                if (prefs.abortEarly) {\n                  return errors;\n                }\n              }\n\n              continue;\n            } else if (!schema.$_terms.items.length) {\n              errors.push(error('array.orderedLength', {\n                pos: i,\n                limit: schema.$_terms.ordered.length\n              }));\n\n              if (prefs.abortEarly) {\n                return errors;\n              }\n\n              break; // No reason to continue since there are no other rules to validate other than array.orderedLength\n            }\n          } // Requireds\n\n\n          const requiredChecks = [];\n          let jl = requireds.length;\n\n          for (let j = 0; j < jl; ++j) {\n            const localState = state.localize(path, ancestors, requireds[j]);\n            localState.snapshot();\n            const res = requireds[j].$_validate(item, localState, prefs);\n            requiredChecks[j] = res;\n\n            if (!res.errors) {\n              value[i] = res.value;\n              isValid = true;\n              internals.fastSplice(requireds, j);\n              --j;\n              --jl;\n\n              if (!schema._flags.sparse && res.value === undefined) {\n                errors.push(error('array.sparse', {\n                  key,\n                  path,\n                  pos: i,\n                  value: undefined\n                }, state.localize(path)));\n\n                if (prefs.abortEarly) {\n                  return errors;\n                }\n              }\n\n              break;\n            }\n\n            localState.restore();\n          }\n\n          if (isValid) {\n            continue;\n          } // Inclusions\n\n\n          const stripUnknown = prefs.stripUnknown && !!prefs.stripUnknown.arrays || false;\n          jl = inclusions.length;\n\n          for (const inclusion of inclusions) {\n            // Avoid re-running requireds that already didn't match in the previous loop\n            let res;\n            const previousCheck = requireds.indexOf(inclusion);\n\n            if (previousCheck !== -1) {\n              res = requiredChecks[previousCheck];\n            } else {\n              const localState = state.localize(path, ancestors, inclusion);\n              localState.snapshot();\n              res = inclusion.$_validate(item, localState, prefs);\n\n              if (!res.errors) {\n                if (inclusion._flags.result === 'strip') {\n                  internals.fastSplice(value, i);\n                  --i;\n                  --il;\n                } else if (!schema._flags.sparse && res.value === undefined) {\n                  errors.push(error('array.sparse', {\n                    key,\n                    path,\n                    pos: i,\n                    value: undefined\n                  }, state.localize(path)));\n                  errored = true;\n                } else {\n                  value[i] = res.value;\n                }\n\n                isValid = true;\n                break;\n              }\n\n              localState.restore();\n            } // Return the actual error if only one inclusion defined\n\n\n            if (jl === 1) {\n              if (stripUnknown) {\n                internals.fastSplice(value, i);\n                --i;\n                --il;\n                isValid = true;\n                break;\n              }\n\n              errors.push(...res.errors);\n\n              if (prefs.abortEarly) {\n                return errors;\n              }\n\n              errored = true;\n              break;\n            }\n          }\n\n          if (errored) {\n            continue;\n          }\n\n          if ((schema.$_terms._inclusions.length || schema.$_terms._requireds.length) && !isValid) {\n            if (stripUnknown) {\n              internals.fastSplice(value, i);\n              --i;\n              --il;\n              continue;\n            }\n\n            errors.push(error('array.includes', {\n              pos: i,\n              value: item\n            }, state.localize(path)));\n\n            if (prefs.abortEarly) {\n              return errors;\n            }\n          }\n        }\n\n        if (requireds.length) {\n          internals.fillMissedErrors(schema, errors, requireds, value, state, prefs);\n        }\n\n        if (ordereds.length) {\n          internals.fillOrderedErrors(schema, errors, ordereds, value, state, prefs);\n\n          if (!errors.length) {\n            internals.fillDefault(ordereds, value, state, prefs);\n          }\n        }\n\n        return errors.length ? errors : value;\n      },\n\n      priority: true,\n      manifest: false\n    },\n    length: {\n      method(limit) {\n        return this.$_addRule({\n          name: 'length',\n          args: {\n            limit\n          },\n          operator: '='\n        });\n      },\n\n      validate(value, helpers, {\n        limit\n      }, {\n        name,\n        operator,\n        args\n      }) {\n        if (Common.compare(value.length, limit, operator)) {\n          return value;\n        }\n\n        return helpers.error('array.' + name, {\n          limit: args.limit,\n          value\n        });\n      },\n\n      args: [{\n        name: 'limit',\n        ref: true,\n        assert: Common.limit,\n        message: 'must be a positive integer'\n      }]\n    },\n    max: {\n      method(limit) {\n        return this.$_addRule({\n          name: 'max',\n          method: 'length',\n          args: {\n            limit\n          },\n          operator: '<='\n        });\n      }\n\n    },\n    min: {\n      method(limit) {\n        return this.$_addRule({\n          name: 'min',\n          method: 'length',\n          args: {\n            limit\n          },\n          operator: '>='\n        });\n      }\n\n    },\n    ordered: {\n      method(...schemas) {\n        Common.verifyFlat(schemas, 'ordered');\n        const obj = this.$_addRule('items');\n\n        for (let i = 0; i < schemas.length; ++i) {\n          const type = Common.tryWithPath(() => this.$_compile(schemas[i]), i, {\n            append: true\n          });\n          internals.validateSingle(type, obj);\n          obj.$_mutateRegister(type);\n          obj.$_terms.ordered.push(type);\n        }\n\n        return obj.$_mutateRebuild();\n      }\n\n    },\n    single: {\n      method(enabled) {\n        const value = enabled === undefined ? true : !!enabled;\n        Assert(!value || !this._flags._arrayItems, 'Cannot specify single rule when array has array items');\n        return this.$_setFlag('single', value);\n      }\n\n    },\n    sort: {\n      method(options = {}) {\n        Common.assertOptions(options, ['by', 'order']);\n        const settings = {\n          order: options.order || 'ascending'\n        };\n\n        if (options.by) {\n          settings.by = Compile.ref(options.by, {\n            ancestor: 0\n          });\n          Assert(!settings.by.ancestor, 'Cannot sort by ancestor');\n        }\n\n        return this.$_addRule({\n          name: 'sort',\n          args: {\n            options: settings\n          }\n        });\n      },\n\n      validate(value, {\n        error,\n        state,\n        prefs,\n        schema\n      }, {\n        options\n      }) {\n        const {\n          value: sorted,\n          errors\n        } = internals.sort(schema, value, options, state, prefs);\n\n        if (errors) {\n          return errors;\n        }\n\n        for (let i = 0; i < value.length; ++i) {\n          if (value[i] !== sorted[i]) {\n            return error('array.sort', {\n              order: options.order,\n              by: options.by ? options.by.key : 'value'\n            });\n          }\n        }\n\n        return value;\n      },\n\n      convert: true\n    },\n    sparse: {\n      method(enabled) {\n        const value = enabled === undefined ? true : !!enabled;\n\n        if (this._flags.sparse === value) {\n          return this;\n        }\n\n        const obj = value ? this.clone() : this.$_addRule('items');\n        return obj.$_setFlag('sparse', value, {\n          clone: false\n        });\n      }\n\n    },\n    unique: {\n      method(comparator, options = {}) {\n        Assert(!comparator || typeof comparator === 'function' || typeof comparator === 'string', 'comparator must be a function or a string');\n        Common.assertOptions(options, ['ignoreUndefined', 'separator']);\n        const rule = {\n          name: 'unique',\n          args: {\n            options,\n            comparator\n          }\n        };\n\n        if (comparator) {\n          if (typeof comparator === 'string') {\n            const separator = Common.default(options.separator, '.');\n            rule.path = separator ? comparator.split(separator) : [comparator];\n          } else {\n            rule.comparator = comparator;\n          }\n        }\n\n        return this.$_addRule(rule);\n      },\n\n      validate(value, {\n        state,\n        error,\n        schema\n      }, {\n        comparator: raw,\n        options\n      }, {\n        comparator,\n        path\n      }) {\n        const found = {\n          string: Object.create(null),\n          number: Object.create(null),\n          undefined: Object.create(null),\n          boolean: Object.create(null),\n          object: new Map(),\n          function: new Map(),\n          custom: new Map()\n        };\n        const compare = comparator || DeepEqual;\n        const ignoreUndefined = options.ignoreUndefined;\n\n        for (let i = 0; i < value.length; ++i) {\n          const item = path ? Reach(value[i], path) : value[i];\n          const records = comparator ? found.custom : found[typeof item];\n          Assert(records, 'Failed to find unique map container for type', typeof item);\n\n          if (records instanceof Map) {\n            const entries = records.entries();\n            let current;\n\n            while (!(current = entries.next()).done) {\n              if (compare(current.value[0], item)) {\n                const localState = state.localize([...state.path, i], [value, ...state.ancestors]);\n                const context = {\n                  pos: i,\n                  value: value[i],\n                  dupePos: current.value[1],\n                  dupeValue: value[current.value[1]]\n                };\n\n                if (path) {\n                  context.path = raw;\n                }\n\n                return error('array.unique', context, localState);\n              }\n            }\n\n            records.set(item, i);\n          } else {\n            if ((!ignoreUndefined || item !== undefined) && records[item] !== undefined) {\n              const context = {\n                pos: i,\n                value: value[i],\n                dupePos: records[item],\n                dupeValue: value[records[item]]\n              };\n\n              if (path) {\n                context.path = raw;\n              }\n\n              const localState = state.localize([...state.path, i], [value, ...state.ancestors]);\n              return error('array.unique', context, localState);\n            }\n\n            records[item] = i;\n          }\n        }\n\n        return value;\n      },\n\n      args: ['comparator', 'options'],\n      multi: true\n    }\n  },\n  cast: {\n    set: {\n      from: Array.isArray,\n\n      to(value, helpers) {\n        return new Set(value);\n      }\n\n    }\n  },\n\n  rebuild(schema) {\n    schema.$_terms._inclusions = [];\n    schema.$_terms._exclusions = [];\n    schema.$_terms._requireds = [];\n\n    for (const type of schema.$_terms.items) {\n      internals.validateSingle(type, schema);\n\n      if (type._flags.presence === 'required') {\n        schema.$_terms._requireds.push(type);\n      } else if (type._flags.presence === 'forbidden') {\n        schema.$_terms._exclusions.push(type);\n      } else {\n        schema.$_terms._inclusions.push(type);\n      }\n    }\n\n    for (const type of schema.$_terms.ordered) {\n      internals.validateSingle(type, schema);\n    }\n  },\n\n  manifest: {\n    build(obj, desc) {\n      if (desc.items) {\n        obj = obj.items(...desc.items);\n      }\n\n      if (desc.ordered) {\n        obj = obj.ordered(...desc.ordered);\n      }\n\n      return obj;\n    }\n\n  },\n  messages: {\n    'array.base': '{{#label}} must be an array',\n    'array.excludes': '{{#label}} contains an excluded value',\n    'array.hasKnown': '{{#label}} does not contain at least one required match for type {:#patternLabel}',\n    'array.hasUnknown': '{{#label}} does not contain at least one required match',\n    'array.includes': '{{#label}} does not match any of the allowed types',\n    'array.includesRequiredBoth': '{{#label}} does not contain {{#knownMisses}} and {{#unknownMisses}} other required value(s)',\n    'array.includesRequiredKnowns': '{{#label}} does not contain {{#knownMisses}}',\n    'array.includesRequiredUnknowns': '{{#label}} does not contain {{#unknownMisses}} required value(s)',\n    'array.length': '{{#label}} must contain {{#limit}} items',\n    'array.max': '{{#label}} must contain less than or equal to {{#limit}} items',\n    'array.min': '{{#label}} must contain at least {{#limit}} items',\n    'array.orderedLength': '{{#label}} must contain at most {{#limit}} items',\n    'array.sort': '{{#label}} must be sorted in {#order} order by {{#by}}',\n    'array.sort.mismatching': '{{#label}} cannot be sorted due to mismatching types',\n    'array.sort.unsupported': '{{#label}} cannot be sorted due to unsupported type {#type}',\n    'array.sparse': '{{#label}} must not be a sparse array item',\n    'array.unique': '{{#label}} contains a duplicate value'\n  }\n}); // Helpers\n\ninternals.fillMissedErrors = function (schema, errors, requireds, value, state, prefs) {\n  const knownMisses = [];\n  let unknownMisses = 0;\n\n  for (const required of requireds) {\n    const label = required._flags.label;\n\n    if (label) {\n      knownMisses.push(label);\n    } else {\n      ++unknownMisses;\n    }\n  }\n\n  if (knownMisses.length) {\n    if (unknownMisses) {\n      errors.push(schema.$_createError('array.includesRequiredBoth', value, {\n        knownMisses,\n        unknownMisses\n      }, state, prefs));\n    } else {\n      errors.push(schema.$_createError('array.includesRequiredKnowns', value, {\n        knownMisses\n      }, state, prefs));\n    }\n  } else {\n    errors.push(schema.$_createError('array.includesRequiredUnknowns', value, {\n      unknownMisses\n    }, state, prefs));\n  }\n};\n\ninternals.fillOrderedErrors = function (schema, errors, ordereds, value, state, prefs) {\n  const requiredOrdereds = [];\n\n  for (const ordered of ordereds) {\n    if (ordered._flags.presence === 'required') {\n      requiredOrdereds.push(ordered);\n    }\n  }\n\n  if (requiredOrdereds.length) {\n    internals.fillMissedErrors(schema, errors, requiredOrdereds, value, state, prefs);\n  }\n};\n\ninternals.fillDefault = function (ordereds, value, state, prefs) {\n  const overrides = [];\n  let trailingUndefined = true;\n\n  for (let i = ordereds.length - 1; i >= 0; --i) {\n    const ordered = ordereds[i];\n    const ancestors = [value, ...state.ancestors];\n    const override = ordered.$_validate(undefined, state.localize(state.path, ancestors, ordered), prefs).value;\n\n    if (trailingUndefined) {\n      if (override === undefined) {\n        continue;\n      }\n\n      trailingUndefined = false;\n    }\n\n    overrides.unshift(override);\n  }\n\n  if (overrides.length) {\n    value.push(...overrides);\n  }\n};\n\ninternals.fastSplice = function (arr, i) {\n  let pos = i;\n\n  while (pos < arr.length) {\n    arr[pos++] = arr[pos];\n  }\n\n  --arr.length;\n};\n\ninternals.validateSingle = function (type, obj) {\n  if (type.type === 'array' || type._flags._arrayItems) {\n    Assert(!obj._flags.single, 'Cannot specify array item with single rule enabled');\n    obj.$_setFlag('_arrayItems', true, {\n      clone: false\n    });\n  }\n};\n\ninternals.sort = function (schema, value, settings, state, prefs) {\n  const order = settings.order === 'ascending' ? 1 : -1;\n  const aFirst = -1 * order;\n  const bFirst = order;\n\n  const sort = (a, b) => {\n    let compare = internals.compare(a, b, aFirst, bFirst);\n\n    if (compare !== null) {\n      return compare;\n    }\n\n    if (settings.by) {\n      a = settings.by.resolve(a, state, prefs);\n      b = settings.by.resolve(b, state, prefs);\n    }\n\n    compare = internals.compare(a, b, aFirst, bFirst);\n\n    if (compare !== null) {\n      return compare;\n    }\n\n    const type = typeof a;\n\n    if (type !== typeof b) {\n      throw schema.$_createError('array.sort.mismatching', value, null, state, prefs);\n    }\n\n    if (type !== 'number' && type !== 'string') {\n      throw schema.$_createError('array.sort.unsupported', value, {\n        type\n      }, state, prefs);\n    }\n\n    if (type === 'number') {\n      return (a - b) * order;\n    }\n\n    return a < b ? aFirst : bFirst;\n  };\n\n  try {\n    return {\n      value: value.slice().sort(sort)\n    };\n  } catch (err) {\n    return {\n      errors: err\n    };\n  }\n};\n\ninternals.compare = function (a, b, aFirst, bFirst) {\n  if (a === b) {\n    return 0;\n  }\n\n  if (a === undefined) {\n    return 1; // Always last regardless of sort order\n  }\n\n  if (b === undefined) {\n    return -1; // Always last regardless of sort order\n  }\n\n  if (a === null) {\n    return bFirst;\n  }\n\n  if (b === null) {\n    return aFirst;\n  }\n\n  return null;\n};","map":{"version":3,"sources":["C:/scripting/jobs assignments/whist/backend/node_modules/joi/lib/types/array.js"],"names":["Assert","require","DeepEqual","Reach","Any","Common","Compile","internals","module","exports","extend","type","flags","single","default","sparse","terms","items","init","manifest","ordered","_exclusions","_inclusions","_requireds","coerce","from","method","value","schema","state","prefs","Array","isArray","sort","$_getRule","args","options","validate","error","_flags","symbols","arraySingle","errors","$_terms","externals","slice","rules","has","$_compile","appendPath","obj","$_addRule","name","$_mutateRegister","ancestors","i","length","localState","localize","path","$_match","patternLabel","label","multi","schemas","verifyFlat","tryWithPath","append","push","$_mutateRebuild","errorsArray","requireds","ordereds","inclusions","wasArray","il","item","errored","isValid","key","Number","undefined","pos","abortEarly","shift","exclusion","presence","res","$_validate","result","fastSplice","limit","requiredChecks","jl","j","snapshot","restore","stripUnknown","arrays","inclusion","previousCheck","indexOf","fillMissedErrors","fillOrderedErrors","fillDefault","priority","operator","helpers","compare","ref","assert","message","max","min","validateSingle","enabled","_arrayItems","$_setFlag","assertOptions","settings","order","by","ancestor","sorted","convert","clone","unique","comparator","rule","separator","split","raw","found","string","Object","create","number","boolean","object","Map","function","custom","ignoreUndefined","records","entries","current","next","done","context","dupePos","dupeValue","set","cast","to","Set","rebuild","build","desc","messages","knownMisses","unknownMisses","required","$_createError","requiredOrdereds","overrides","trailingUndefined","override","unshift","arr","aFirst","bFirst","a","b","resolve","err"],"mappings":"AAAA;;AAEA,MAAMA,MAAM,GAAGC,OAAO,CAAC,uBAAD,CAAtB;;AACA,MAAMC,SAAS,GAAGD,OAAO,CAAC,0BAAD,CAAzB;;AACA,MAAME,KAAK,GAAGF,OAAO,CAAC,sBAAD,CAArB;;AAEA,MAAMG,GAAG,GAAGH,OAAO,CAAC,OAAD,CAAnB;;AACA,MAAMI,MAAM,GAAGJ,OAAO,CAAC,WAAD,CAAtB;;AACA,MAAMK,OAAO,GAAGL,OAAO,CAAC,YAAD,CAAvB;;AAGA,MAAMM,SAAS,GAAG,EAAlB;AAGAC,MAAM,CAACC,OAAP,GAAiBL,GAAG,CAACM,MAAJ,CAAW;AAExBC,EAAAA,IAAI,EAAE,OAFkB;AAIxBC,EAAAA,KAAK,EAAE;AAEHC,IAAAA,MAAM,EAAE;AAAEC,MAAAA,OAAO,EAAE;AAAX,KAFL;AAGHC,IAAAA,MAAM,EAAE;AAAED,MAAAA,OAAO,EAAE;AAAX;AAHL,GAJiB;AAUxBE,EAAAA,KAAK,EAAE;AAEHC,IAAAA,KAAK,EAAE;AAAEC,MAAAA,IAAI,EAAE,EAAR;AAAYC,MAAAA,QAAQ,EAAE;AAAtB,KAFJ;AAGHC,IAAAA,OAAO,EAAE;AAAEF,MAAAA,IAAI,EAAE,EAAR;AAAYC,MAAAA,QAAQ,EAAE;AAAtB,KAHN;AAKHE,IAAAA,WAAW,EAAE;AAAEH,MAAAA,IAAI,EAAE;AAAR,KALV;AAMHI,IAAAA,WAAW,EAAE;AAAEJ,MAAAA,IAAI,EAAE;AAAR,KANV;AAOHK,IAAAA,UAAU,EAAE;AAAEL,MAAAA,IAAI,EAAE;AAAR;AAPT,GAViB;AAoBxBM,EAAAA,MAAM,EAAE;AACJC,IAAAA,IAAI,EAAE,QADF;;AAEJC,IAAAA,MAAM,CAACC,KAAD,EAAQ;AAAEC,MAAAA,MAAF;AAAUC,MAAAA,KAAV;AAAiBC,MAAAA;AAAjB,KAAR,EAAkC;AAEpC,UAAI,CAACC,KAAK,CAACC,OAAN,CAAcL,KAAd,CAAL,EAA2B;AACvB;AACH;;AAED,YAAMM,IAAI,GAAGL,MAAM,CAACM,SAAP,CAAiB,MAAjB,CAAb;;AACA,UAAI,CAACD,IAAL,EAAW;AACP;AACH;;AAED,aAAO1B,SAAS,CAAC0B,IAAV,CAAeL,MAAf,EAAuBD,KAAvB,EAA8BM,IAAI,CAACE,IAAL,CAAUC,OAAxC,EAAiDP,KAAjD,EAAwDC,KAAxD,CAAP;AACH;;AAdG,GApBgB;;AAqCxBO,EAAAA,QAAQ,CAACV,KAAD,EAAQ;AAAEC,IAAAA,MAAF;AAAUU,IAAAA;AAAV,GAAR,EAA2B;AAE/B,QAAI,CAACP,KAAK,CAACC,OAAN,CAAcL,KAAd,CAAL,EAA2B;AACvB,UAAIC,MAAM,CAACW,MAAP,CAAc1B,MAAlB,EAA0B;AACtB,cAAMA,MAAM,GAAG,CAACc,KAAD,CAAf;AACAd,QAAAA,MAAM,CAACR,MAAM,CAACmC,OAAP,CAAeC,WAAhB,CAAN,GAAqC,IAArC;AACA,eAAO;AAAEd,UAAAA,KAAK,EAAEd;AAAT,SAAP;AACH;;AAED,aAAO;AAAE6B,QAAAA,MAAM,EAAEJ,KAAK,CAAC,YAAD;AAAf,OAAP;AACH;;AAED,QAAI,CAACV,MAAM,CAACM,SAAP,CAAiB,OAAjB,CAAD,IACA,CAACN,MAAM,CAACe,OAAP,CAAeC,SADpB,EAC+B;AAE3B;AACH;;AAED,WAAO;AAAEjB,MAAAA,KAAK,EAAEA,KAAK,CAACkB,KAAN;AAAT,KAAP,CAlB+B,CAkBS;AAC3C,GAxDuB;;AA0DxBC,EAAAA,KAAK,EAAE;AAEHC,IAAAA,GAAG,EAAE;AACDrB,MAAAA,MAAM,CAACE,MAAD,EAAS;AAEXA,QAAAA,MAAM,GAAG,KAAKoB,SAAL,CAAepB,MAAf,EAAuB;AAAEqB,UAAAA,UAAU,EAAE;AAAd,SAAvB,CAAT;AACA,cAAMC,GAAG,GAAG,KAAKC,SAAL,CAAe;AAAEC,UAAAA,IAAI,EAAE,KAAR;AAAejB,UAAAA,IAAI,EAAE;AAAEP,YAAAA;AAAF;AAArB,SAAf,CAAZ;AACAsB,QAAAA,GAAG,CAACG,gBAAJ,CAAqBzB,MAArB;AACA,eAAOsB,GAAP;AACH,OAPA;;AAQDb,MAAAA,QAAQ,CAACV,KAAD,EAAQ;AAAEE,QAAAA,KAAF;AAASC,QAAAA,KAAT;AAAgBQ,QAAAA;AAAhB,OAAR,EAAiC;AAAEV,QAAAA,MAAM,EAAEmB;AAAV,OAAjC,EAAkD;AAEtD,cAAMO,SAAS,GAAG,CAAC3B,KAAD,EAAQ,GAAGE,KAAK,CAACyB,SAAjB,CAAlB;;AACA,aAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG5B,KAAK,CAAC6B,MAA1B,EAAkC,EAAED,CAApC,EAAuC;AACnC,gBAAME,UAAU,GAAG5B,KAAK,CAAC6B,QAAN,CAAe,CAAC,GAAG7B,KAAK,CAAC8B,IAAV,EAAgBJ,CAAhB,CAAf,EAAmCD,SAAnC,EAA8CP,GAA9C,CAAnB;;AACA,cAAIA,GAAG,CAACa,OAAJ,CAAYjC,KAAK,CAAC4B,CAAD,CAAjB,EAAsBE,UAAtB,EAAkC3B,KAAlC,CAAJ,EAA8C;AAC1C,mBAAOH,KAAP;AACH;AACJ;;AAED,cAAMkC,YAAY,GAAGd,GAAG,CAACR,MAAJ,CAAWuB,KAAhC;;AACA,YAAID,YAAJ,EAAkB;AACd,iBAAOvB,KAAK,CAAC,gBAAD,EAAmB;AAAEuB,YAAAA;AAAF,WAAnB,CAAZ;AACH;;AAED,eAAOvB,KAAK,CAAC,kBAAD,EAAqB,IAArB,CAAZ;AACH,OAxBA;;AAyBDyB,MAAAA,KAAK,EAAE;AAzBN,KAFF;AA8BH9C,IAAAA,KAAK,EAAE;AACHS,MAAAA,MAAM,CAAC,GAAGsC,OAAJ,EAAa;AAEf3D,QAAAA,MAAM,CAAC4D,UAAP,CAAkBD,OAAlB,EAA2B,OAA3B;AAEA,cAAMd,GAAG,GAAG,KAAKC,SAAL,CAAe,OAAf,CAAZ;;AAEA,aAAK,IAAII,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGS,OAAO,CAACR,MAA5B,EAAoC,EAAED,CAAtC,EAAyC;AACrC,gBAAM5C,IAAI,GAAGN,MAAM,CAAC6D,WAAP,CAAmB,MAAM,KAAKlB,SAAL,CAAegB,OAAO,CAACT,CAAD,CAAtB,CAAzB,EAAqDA,CAArD,EAAwD;AAAEY,YAAAA,MAAM,EAAE;AAAV,WAAxD,CAAb;AACAjB,UAAAA,GAAG,CAACP,OAAJ,CAAY1B,KAAZ,CAAkBmD,IAAlB,CAAuBzD,IAAvB;AACH;;AAED,eAAOuC,GAAG,CAACmB,eAAJ,EAAP;AACH,OAbE;;AAcHhC,MAAAA,QAAQ,CAACV,KAAD,EAAQ;AAAEC,QAAAA,MAAF;AAAUU,QAAAA,KAAV;AAAiBT,QAAAA,KAAjB;AAAwBC,QAAAA,KAAxB;AAA+BwC,QAAAA;AAA/B,OAAR,EAAsD;AAE1D,cAAMC,SAAS,GAAG3C,MAAM,CAACe,OAAP,CAAepB,UAAf,CAA0BsB,KAA1B,EAAlB;;AACA,cAAM2B,QAAQ,GAAG5C,MAAM,CAACe,OAAP,CAAevB,OAAf,CAAuByB,KAAvB,EAAjB;AACA,cAAM4B,UAAU,GAAG,CAAC,GAAG7C,MAAM,CAACe,OAAP,CAAerB,WAAnB,EAAgC,GAAGiD,SAAnC,CAAnB;AAEA,cAAMG,QAAQ,GAAG,CAAC/C,KAAK,CAACtB,MAAM,CAACmC,OAAP,CAAeC,WAAhB,CAAvB;AACA,eAAOd,KAAK,CAACtB,MAAM,CAACmC,OAAP,CAAeC,WAAhB,CAAZ;AAEA,cAAMC,MAAM,GAAG4B,WAAW,EAA1B;AAEA,YAAIK,EAAE,GAAGhD,KAAK,CAAC6B,MAAf;;AACA,aAAK,IAAID,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGoB,EAApB,EAAwB,EAAEpB,CAA1B,EAA6B;AACzB,gBAAMqB,IAAI,GAAGjD,KAAK,CAAC4B,CAAD,CAAlB;AAEA,cAAIsB,OAAO,GAAG,KAAd;AACA,cAAIC,OAAO,GAAG,KAAd;AAEA,gBAAMC,GAAG,GAAGL,QAAQ,GAAGnB,CAAH,GAAO,IAAIyB,MAAJ,CAAWzB,CAAX,CAA3B,CANyB,CAMuB;;AAChD,gBAAMI,IAAI,GAAG,CAAC,GAAG9B,KAAK,CAAC8B,IAAV,EAAgBoB,GAAhB,CAAb,CAPyB,CASzB;;AAEA,cAAI,CAACnD,MAAM,CAACW,MAAP,CAAcxB,MAAf,IACA6D,IAAI,KAAKK,SADb,EACwB;AAEpBvC,YAAAA,MAAM,CAAC0B,IAAP,CAAY9B,KAAK,CAAC,cAAD,EAAiB;AAAEyC,cAAAA,GAAF;AAAOpB,cAAAA,IAAP;AAAauB,cAAAA,GAAG,EAAE3B,CAAlB;AAAqB5B,cAAAA,KAAK,EAAEsD;AAA5B,aAAjB,EAA0DpD,KAAK,CAAC6B,QAAN,CAAeC,IAAf,CAA1D,CAAjB;;AACA,gBAAI7B,KAAK,CAACqD,UAAV,EAAsB;AAClB,qBAAOzC,MAAP;AACH;;AAED8B,YAAAA,QAAQ,CAACY,KAAT;AACA;AACH,WArBwB,CAuBzB;;;AAEA,gBAAM9B,SAAS,GAAG,CAAC3B,KAAD,EAAQ,GAAGE,KAAK,CAACyB,SAAjB,CAAlB;;AAEA,eAAK,MAAM+B,SAAX,IAAwBzD,MAAM,CAACe,OAAP,CAAetB,WAAvC,EAAoD;AAChD,gBAAI,CAACgE,SAAS,CAACzB,OAAV,CAAkBgB,IAAlB,EAAwB/C,KAAK,CAAC6B,QAAN,CAAeC,IAAf,EAAqBL,SAArB,EAAgC+B,SAAhC,CAAxB,EAAoEvD,KAApE,EAA2E;AAAEwD,cAAAA,QAAQ,EAAE;AAAZ,aAA3E,CAAL,EAAyG;AACrG;AACH;;AAED5C,YAAAA,MAAM,CAAC0B,IAAP,CAAY9B,KAAK,CAAC,gBAAD,EAAmB;AAAE4C,cAAAA,GAAG,EAAE3B,CAAP;AAAU5B,cAAAA,KAAK,EAAEiD;AAAjB,aAAnB,EAA4C/C,KAAK,CAAC6B,QAAN,CAAeC,IAAf,CAA5C,CAAjB;;AACA,gBAAI7B,KAAK,CAACqD,UAAV,EAAsB;AAClB,qBAAOzC,MAAP;AACH;;AAEDmC,YAAAA,OAAO,GAAG,IAAV;AACAL,YAAAA,QAAQ,CAACY,KAAT;AACA;AACH;;AAED,cAAIP,OAAJ,EAAa;AACT;AACH,WA5CwB,CA8CzB;;;AAEA,cAAIjD,MAAM,CAACe,OAAP,CAAevB,OAAf,CAAuBoC,MAA3B,EAAmC;AAC/B,gBAAIgB,QAAQ,CAAChB,MAAb,EAAqB;AACjB,oBAAMpC,OAAO,GAAGoD,QAAQ,CAACY,KAAT,EAAhB;AACA,oBAAMG,GAAG,GAAGnE,OAAO,CAACoE,UAAR,CAAmBZ,IAAnB,EAAyB/C,KAAK,CAAC6B,QAAN,CAAeC,IAAf,EAAqBL,SAArB,EAAgClC,OAAhC,CAAzB,EAAmEU,KAAnE,CAAZ;;AACA,kBAAI,CAACyD,GAAG,CAAC7C,MAAT,EAAiB;AACb,oBAAItB,OAAO,CAACmB,MAAR,CAAekD,MAAf,KAA0B,OAA9B,EAAuC;AACnClF,kBAAAA,SAAS,CAACmF,UAAV,CAAqB/D,KAArB,EAA4B4B,CAA5B;AACA,oBAAEA,CAAF;AACA,oBAAEoB,EAAF;AACH,iBAJD,MAKK,IAAI,CAAC/C,MAAM,CAACW,MAAP,CAAcxB,MAAf,IAAyBwE,GAAG,CAAC5D,KAAJ,KAAcsD,SAA3C,EAAsD;AACvDvC,kBAAAA,MAAM,CAAC0B,IAAP,CAAY9B,KAAK,CAAC,cAAD,EAAiB;AAAEyC,oBAAAA,GAAF;AAAOpB,oBAAAA,IAAP;AAAauB,oBAAAA,GAAG,EAAE3B,CAAlB;AAAqB5B,oBAAAA,KAAK,EAAEsD;AAA5B,mBAAjB,EAA0DpD,KAAK,CAAC6B,QAAN,CAAeC,IAAf,CAA1D,CAAjB;;AACA,sBAAI7B,KAAK,CAACqD,UAAV,EAAsB;AAClB,2BAAOzC,MAAP;AACH;;AAED;AACH,iBAPI,MAQA;AACDf,kBAAAA,KAAK,CAAC4B,CAAD,CAAL,GAAWgC,GAAG,CAAC5D,KAAf;AACH;AACJ,eAjBD,MAkBK;AACDe,gBAAAA,MAAM,CAAC0B,IAAP,CAAY,GAAGmB,GAAG,CAAC7C,MAAnB;;AACA,oBAAIZ,KAAK,CAACqD,UAAV,EAAsB;AAClB,yBAAOzC,MAAP;AACH;AACJ;;AAED;AACH,aA7BD,MA8BK,IAAI,CAACd,MAAM,CAACe,OAAP,CAAe1B,KAAf,CAAqBuC,MAA1B,EAAkC;AACnCd,cAAAA,MAAM,CAAC0B,IAAP,CAAY9B,KAAK,CAAC,qBAAD,EAAwB;AAAE4C,gBAAAA,GAAG,EAAE3B,CAAP;AAAUoC,gBAAAA,KAAK,EAAE/D,MAAM,CAACe,OAAP,CAAevB,OAAf,CAAuBoC;AAAxC,eAAxB,CAAjB;;AACA,kBAAI1B,KAAK,CAACqD,UAAV,EAAsB;AAClB,uBAAOzC,MAAP;AACH;;AAED,oBANmC,CAMvB;AACf;AACJ,WAvFwB,CAyFzB;;;AAEA,gBAAMkD,cAAc,GAAG,EAAvB;AACA,cAAIC,EAAE,GAAGtB,SAAS,CAACf,MAAnB;;AACA,eAAK,IAAIsC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,EAApB,EAAwB,EAAEC,CAA1B,EAA6B;AACzB,kBAAMrC,UAAU,GAAG5B,KAAK,CAAC6B,QAAN,CAAeC,IAAf,EAAqBL,SAArB,EAAgCiB,SAAS,CAACuB,CAAD,CAAzC,CAAnB;AACArC,YAAAA,UAAU,CAACsC,QAAX;AAEA,kBAAMR,GAAG,GAAGhB,SAAS,CAACuB,CAAD,CAAT,CAAaN,UAAb,CAAwBZ,IAAxB,EAA8BnB,UAA9B,EAA0C3B,KAA1C,CAAZ;AACA8D,YAAAA,cAAc,CAACE,CAAD,CAAd,GAAoBP,GAApB;;AAEA,gBAAI,CAACA,GAAG,CAAC7C,MAAT,EAAiB;AACbf,cAAAA,KAAK,CAAC4B,CAAD,CAAL,GAAWgC,GAAG,CAAC5D,KAAf;AACAmD,cAAAA,OAAO,GAAG,IAAV;AACAvE,cAAAA,SAAS,CAACmF,UAAV,CAAqBnB,SAArB,EAAgCuB,CAAhC;AACA,gBAAEA,CAAF;AACA,gBAAED,EAAF;;AAEA,kBAAI,CAACjE,MAAM,CAACW,MAAP,CAAcxB,MAAf,IACAwE,GAAG,CAAC5D,KAAJ,KAAcsD,SADlB,EAC6B;AAEzBvC,gBAAAA,MAAM,CAAC0B,IAAP,CAAY9B,KAAK,CAAC,cAAD,EAAiB;AAAEyC,kBAAAA,GAAF;AAAOpB,kBAAAA,IAAP;AAAauB,kBAAAA,GAAG,EAAE3B,CAAlB;AAAqB5B,kBAAAA,KAAK,EAAEsD;AAA5B,iBAAjB,EAA0DpD,KAAK,CAAC6B,QAAN,CAAeC,IAAf,CAA1D,CAAjB;;AACA,oBAAI7B,KAAK,CAACqD,UAAV,EAAsB;AAClB,yBAAOzC,MAAP;AACH;AACJ;;AAED;AACH;;AAEDe,YAAAA,UAAU,CAACuC,OAAX;AACH;;AAED,cAAIlB,OAAJ,EAAa;AACT;AACH,WA5HwB,CA8HzB;;;AAEA,gBAAMmB,YAAY,GAAGnE,KAAK,CAACmE,YAAN,IAAsB,CAAC,CAACnE,KAAK,CAACmE,YAAN,CAAmBC,MAA3C,IAAqD,KAA1E;AAEAL,UAAAA,EAAE,GAAGpB,UAAU,CAACjB,MAAhB;;AACA,eAAK,MAAM2C,SAAX,IAAwB1B,UAAxB,EAAoC;AAEhC;AAEA,gBAAIc,GAAJ;AACA,kBAAMa,aAAa,GAAG7B,SAAS,CAAC8B,OAAV,CAAkBF,SAAlB,CAAtB;;AACA,gBAAIC,aAAa,KAAK,CAAC,CAAvB,EAA0B;AACtBb,cAAAA,GAAG,GAAGK,cAAc,CAACQ,aAAD,CAApB;AACH,aAFD,MAGK;AACD,oBAAM3C,UAAU,GAAG5B,KAAK,CAAC6B,QAAN,CAAeC,IAAf,EAAqBL,SAArB,EAAgC6C,SAAhC,CAAnB;AACA1C,cAAAA,UAAU,CAACsC,QAAX;AAEAR,cAAAA,GAAG,GAAGY,SAAS,CAACX,UAAV,CAAqBZ,IAArB,EAA2BnB,UAA3B,EAAuC3B,KAAvC,CAAN;;AACA,kBAAI,CAACyD,GAAG,CAAC7C,MAAT,EAAiB;AACb,oBAAIyD,SAAS,CAAC5D,MAAV,CAAiBkD,MAAjB,KAA4B,OAAhC,EAAyC;AACrClF,kBAAAA,SAAS,CAACmF,UAAV,CAAqB/D,KAArB,EAA4B4B,CAA5B;AACA,oBAAEA,CAAF;AACA,oBAAEoB,EAAF;AACH,iBAJD,MAKK,IAAI,CAAC/C,MAAM,CAACW,MAAP,CAAcxB,MAAf,IACLwE,GAAG,CAAC5D,KAAJ,KAAcsD,SADb,EACwB;AAEzBvC,kBAAAA,MAAM,CAAC0B,IAAP,CAAY9B,KAAK,CAAC,cAAD,EAAiB;AAAEyC,oBAAAA,GAAF;AAAOpB,oBAAAA,IAAP;AAAauB,oBAAAA,GAAG,EAAE3B,CAAlB;AAAqB5B,oBAAAA,KAAK,EAAEsD;AAA5B,mBAAjB,EAA0DpD,KAAK,CAAC6B,QAAN,CAAeC,IAAf,CAA1D,CAAjB;AACAkB,kBAAAA,OAAO,GAAG,IAAV;AACH,iBALI,MAMA;AACDlD,kBAAAA,KAAK,CAAC4B,CAAD,CAAL,GAAWgC,GAAG,CAAC5D,KAAf;AACH;;AAEDmD,gBAAAA,OAAO,GAAG,IAAV;AACA;AACH;;AAEDrB,cAAAA,UAAU,CAACuC,OAAX;AACH,aAnC+B,CAqChC;;;AAEA,gBAAIH,EAAE,KAAK,CAAX,EAAc;AACV,kBAAII,YAAJ,EAAkB;AACd1F,gBAAAA,SAAS,CAACmF,UAAV,CAAqB/D,KAArB,EAA4B4B,CAA5B;AACA,kBAAEA,CAAF;AACA,kBAAEoB,EAAF;AACAG,gBAAAA,OAAO,GAAG,IAAV;AACA;AACH;;AAEDpC,cAAAA,MAAM,CAAC0B,IAAP,CAAY,GAAGmB,GAAG,CAAC7C,MAAnB;;AACA,kBAAIZ,KAAK,CAACqD,UAAV,EAAsB;AAClB,uBAAOzC,MAAP;AACH;;AAEDmC,cAAAA,OAAO,GAAG,IAAV;AACA;AACH;AACJ;;AAED,cAAIA,OAAJ,EAAa;AACT;AACH;;AAED,cAAI,CAACjD,MAAM,CAACe,OAAP,CAAerB,WAAf,CAA2BkC,MAA3B,IAAqC5B,MAAM,CAACe,OAAP,CAAepB,UAAf,CAA0BiC,MAAhE,KACA,CAACsB,OADL,EACc;AAEV,gBAAImB,YAAJ,EAAkB;AACd1F,cAAAA,SAAS,CAACmF,UAAV,CAAqB/D,KAArB,EAA4B4B,CAA5B;AACA,gBAAEA,CAAF;AACA,gBAAEoB,EAAF;AACA;AACH;;AAEDjC,YAAAA,MAAM,CAAC0B,IAAP,CAAY9B,KAAK,CAAC,gBAAD,EAAmB;AAAE4C,cAAAA,GAAG,EAAE3B,CAAP;AAAU5B,cAAAA,KAAK,EAAEiD;AAAjB,aAAnB,EAA4C/C,KAAK,CAAC6B,QAAN,CAAeC,IAAf,CAA5C,CAAjB;;AACA,gBAAI7B,KAAK,CAACqD,UAAV,EAAsB;AAClB,qBAAOzC,MAAP;AACH;AACJ;AACJ;;AAED,YAAI6B,SAAS,CAACf,MAAd,EAAsB;AAClBjD,UAAAA,SAAS,CAAC+F,gBAAV,CAA2B1E,MAA3B,EAAmCc,MAAnC,EAA2C6B,SAA3C,EAAsD5C,KAAtD,EAA6DE,KAA7D,EAAoEC,KAApE;AACH;;AAED,YAAI0C,QAAQ,CAAChB,MAAb,EAAqB;AACjBjD,UAAAA,SAAS,CAACgG,iBAAV,CAA4B3E,MAA5B,EAAoCc,MAApC,EAA4C8B,QAA5C,EAAsD7C,KAAtD,EAA6DE,KAA7D,EAAoEC,KAApE;;AAEA,cAAI,CAACY,MAAM,CAACc,MAAZ,EAAoB;AAChBjD,YAAAA,SAAS,CAACiG,WAAV,CAAsBhC,QAAtB,EAAgC7C,KAAhC,EAAuCE,KAAvC,EAA8CC,KAA9C;AACH;AACJ;;AAED,eAAOY,MAAM,CAACc,MAAP,GAAgBd,MAAhB,GAAyBf,KAAhC;AACH,OAzPE;;AA2PH8E,MAAAA,QAAQ,EAAE,IA3PP;AA4PHtF,MAAAA,QAAQ,EAAE;AA5PP,KA9BJ;AA6RHqC,IAAAA,MAAM,EAAE;AACJ9B,MAAAA,MAAM,CAACiE,KAAD,EAAQ;AAEV,eAAO,KAAKxC,SAAL,CAAe;AAAEC,UAAAA,IAAI,EAAE,QAAR;AAAkBjB,UAAAA,IAAI,EAAE;AAAEwD,YAAAA;AAAF,WAAxB;AAAmCe,UAAAA,QAAQ,EAAE;AAA7C,SAAf,CAAP;AACH,OAJG;;AAKJrE,MAAAA,QAAQ,CAACV,KAAD,EAAQgF,OAAR,EAAiB;AAAEhB,QAAAA;AAAF,OAAjB,EAA4B;AAAEvC,QAAAA,IAAF;AAAQsD,QAAAA,QAAR;AAAkBvE,QAAAA;AAAlB,OAA5B,EAAsD;AAE1D,YAAI9B,MAAM,CAACuG,OAAP,CAAejF,KAAK,CAAC6B,MAArB,EAA6BmC,KAA7B,EAAoCe,QAApC,CAAJ,EAAmD;AAC/C,iBAAO/E,KAAP;AACH;;AAED,eAAOgF,OAAO,CAACrE,KAAR,CAAc,WAAWc,IAAzB,EAA+B;AAAEuC,UAAAA,KAAK,EAAExD,IAAI,CAACwD,KAAd;AAAqBhE,UAAAA;AAArB,SAA/B,CAAP;AACH,OAZG;;AAaJQ,MAAAA,IAAI,EAAE,CACF;AACIiB,QAAAA,IAAI,EAAE,OADV;AAEIyD,QAAAA,GAAG,EAAE,IAFT;AAGIC,QAAAA,MAAM,EAAEzG,MAAM,CAACsF,KAHnB;AAIIoB,QAAAA,OAAO,EAAE;AAJb,OADE;AAbF,KA7RL;AAoTHC,IAAAA,GAAG,EAAE;AACDtF,MAAAA,MAAM,CAACiE,KAAD,EAAQ;AAEV,eAAO,KAAKxC,SAAL,CAAe;AAAEC,UAAAA,IAAI,EAAE,KAAR;AAAe1B,UAAAA,MAAM,EAAE,QAAvB;AAAiCS,UAAAA,IAAI,EAAE;AAAEwD,YAAAA;AAAF,WAAvC;AAAkDe,UAAAA,QAAQ,EAAE;AAA5D,SAAf,CAAP;AACH;;AAJA,KApTF;AA2THO,IAAAA,GAAG,EAAE;AACDvF,MAAAA,MAAM,CAACiE,KAAD,EAAQ;AAEV,eAAO,KAAKxC,SAAL,CAAe;AAAEC,UAAAA,IAAI,EAAE,KAAR;AAAe1B,UAAAA,MAAM,EAAE,QAAvB;AAAiCS,UAAAA,IAAI,EAAE;AAAEwD,YAAAA;AAAF,WAAvC;AAAkDe,UAAAA,QAAQ,EAAE;AAA5D,SAAf,CAAP;AACH;;AAJA,KA3TF;AAkUHtF,IAAAA,OAAO,EAAE;AACLM,MAAAA,MAAM,CAAC,GAAGsC,OAAJ,EAAa;AAEf3D,QAAAA,MAAM,CAAC4D,UAAP,CAAkBD,OAAlB,EAA2B,SAA3B;AAEA,cAAMd,GAAG,GAAG,KAAKC,SAAL,CAAe,OAAf,CAAZ;;AAEA,aAAK,IAAII,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGS,OAAO,CAACR,MAA5B,EAAoC,EAAED,CAAtC,EAAyC;AACrC,gBAAM5C,IAAI,GAAGN,MAAM,CAAC6D,WAAP,CAAmB,MAAM,KAAKlB,SAAL,CAAegB,OAAO,CAACT,CAAD,CAAtB,CAAzB,EAAqDA,CAArD,EAAwD;AAAEY,YAAAA,MAAM,EAAE;AAAV,WAAxD,CAAb;AACA5D,UAAAA,SAAS,CAAC2G,cAAV,CAAyBvG,IAAzB,EAA+BuC,GAA/B;AAEAA,UAAAA,GAAG,CAACG,gBAAJ,CAAqB1C,IAArB;AACAuC,UAAAA,GAAG,CAACP,OAAJ,CAAYvB,OAAZ,CAAoBgD,IAApB,CAAyBzD,IAAzB;AACH;;AAED,eAAOuC,GAAG,CAACmB,eAAJ,EAAP;AACH;;AAhBI,KAlUN;AAqVHxD,IAAAA,MAAM,EAAE;AACJa,MAAAA,MAAM,CAACyF,OAAD,EAAU;AAEZ,cAAMxF,KAAK,GAAGwF,OAAO,KAAKlC,SAAZ,GAAwB,IAAxB,GAA+B,CAAC,CAACkC,OAA/C;AACAnH,QAAAA,MAAM,CAAC,CAAC2B,KAAD,IAAU,CAAC,KAAKY,MAAL,CAAY6E,WAAxB,EAAqC,uDAArC,CAAN;AAEA,eAAO,KAAKC,SAAL,CAAe,QAAf,EAAyB1F,KAAzB,CAAP;AACH;;AAPG,KArVL;AA+VHM,IAAAA,IAAI,EAAE;AACFP,MAAAA,MAAM,CAACU,OAAO,GAAG,EAAX,EAAe;AAEjB/B,QAAAA,MAAM,CAACiH,aAAP,CAAqBlF,OAArB,EAA8B,CAAC,IAAD,EAAO,OAAP,CAA9B;AAEA,cAAMmF,QAAQ,GAAG;AACbC,UAAAA,KAAK,EAAEpF,OAAO,CAACoF,KAAR,IAAiB;AADX,SAAjB;;AAIA,YAAIpF,OAAO,CAACqF,EAAZ,EAAgB;AACZF,UAAAA,QAAQ,CAACE,EAAT,GAAcnH,OAAO,CAACuG,GAAR,CAAYzE,OAAO,CAACqF,EAApB,EAAwB;AAAEC,YAAAA,QAAQ,EAAE;AAAZ,WAAxB,CAAd;AACA1H,UAAAA,MAAM,CAAC,CAACuH,QAAQ,CAACE,EAAT,CAAYC,QAAd,EAAwB,yBAAxB,CAAN;AACH;;AAED,eAAO,KAAKvE,SAAL,CAAe;AAAEC,UAAAA,IAAI,EAAE,MAAR;AAAgBjB,UAAAA,IAAI,EAAE;AAAEC,YAAAA,OAAO,EAAEmF;AAAX;AAAtB,SAAf,CAAP;AACH,OAfC;;AAgBFlF,MAAAA,QAAQ,CAACV,KAAD,EAAQ;AAAEW,QAAAA,KAAF;AAAST,QAAAA,KAAT;AAAgBC,QAAAA,KAAhB;AAAuBF,QAAAA;AAAvB,OAAR,EAAyC;AAAEQ,QAAAA;AAAF,OAAzC,EAAsD;AAE1D,cAAM;AAAET,UAAAA,KAAK,EAAEgG,MAAT;AAAiBjF,UAAAA;AAAjB,YAA4BnC,SAAS,CAAC0B,IAAV,CAAeL,MAAf,EAAuBD,KAAvB,EAA8BS,OAA9B,EAAuCP,KAAvC,EAA8CC,KAA9C,CAAlC;;AACA,YAAIY,MAAJ,EAAY;AACR,iBAAOA,MAAP;AACH;;AAED,aAAK,IAAIa,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG5B,KAAK,CAAC6B,MAA1B,EAAkC,EAAED,CAApC,EAAuC;AACnC,cAAI5B,KAAK,CAAC4B,CAAD,CAAL,KAAaoE,MAAM,CAACpE,CAAD,CAAvB,EAA4B;AACxB,mBAAOjB,KAAK,CAAC,YAAD,EAAe;AAAEkF,cAAAA,KAAK,EAAEpF,OAAO,CAACoF,KAAjB;AAAwBC,cAAAA,EAAE,EAAErF,OAAO,CAACqF,EAAR,GAAarF,OAAO,CAACqF,EAAR,CAAW1C,GAAxB,GAA8B;AAA1D,aAAf,CAAZ;AACH;AACJ;;AAED,eAAOpD,KAAP;AACH,OA9BC;;AA+BFiG,MAAAA,OAAO,EAAE;AA/BP,KA/VH;AAiYH7G,IAAAA,MAAM,EAAE;AACJW,MAAAA,MAAM,CAACyF,OAAD,EAAU;AAEZ,cAAMxF,KAAK,GAAGwF,OAAO,KAAKlC,SAAZ,GAAwB,IAAxB,GAA+B,CAAC,CAACkC,OAA/C;;AAEA,YAAI,KAAK5E,MAAL,CAAYxB,MAAZ,KAAuBY,KAA3B,EAAkC;AAC9B,iBAAO,IAAP;AACH;;AAED,cAAMuB,GAAG,GAAGvB,KAAK,GAAG,KAAKkG,KAAL,EAAH,GAAkB,KAAK1E,SAAL,CAAe,OAAf,CAAnC;AACA,eAAOD,GAAG,CAACmE,SAAJ,CAAc,QAAd,EAAwB1F,KAAxB,EAA+B;AAAEkG,UAAAA,KAAK,EAAE;AAAT,SAA/B,CAAP;AACH;;AAXG,KAjYL;AA+YHC,IAAAA,MAAM,EAAE;AACJpG,MAAAA,MAAM,CAACqG,UAAD,EAAa3F,OAAO,GAAG,EAAvB,EAA2B;AAE7BpC,QAAAA,MAAM,CAAC,CAAC+H,UAAD,IAAe,OAAOA,UAAP,KAAsB,UAArC,IAAmD,OAAOA,UAAP,KAAsB,QAA1E,EAAoF,2CAApF,CAAN;AACA1H,QAAAA,MAAM,CAACiH,aAAP,CAAqBlF,OAArB,EAA8B,CAAC,iBAAD,EAAoB,WAApB,CAA9B;AAEA,cAAM4F,IAAI,GAAG;AAAE5E,UAAAA,IAAI,EAAE,QAAR;AAAkBjB,UAAAA,IAAI,EAAE;AAAEC,YAAAA,OAAF;AAAW2F,YAAAA;AAAX;AAAxB,SAAb;;AAEA,YAAIA,UAAJ,EAAgB;AACZ,cAAI,OAAOA,UAAP,KAAsB,QAA1B,EAAoC;AAChC,kBAAME,SAAS,GAAG5H,MAAM,CAACS,OAAP,CAAesB,OAAO,CAAC6F,SAAvB,EAAkC,GAAlC,CAAlB;AACAD,YAAAA,IAAI,CAACrE,IAAL,GAAYsE,SAAS,GAAGF,UAAU,CAACG,KAAX,CAAiBD,SAAjB,CAAH,GAAiC,CAACF,UAAD,CAAtD;AACH,WAHD,MAIK;AACDC,YAAAA,IAAI,CAACD,UAAL,GAAkBA,UAAlB;AACH;AACJ;;AAED,eAAO,KAAK5E,SAAL,CAAe6E,IAAf,CAAP;AACH,OAnBG;;AAoBJ3F,MAAAA,QAAQ,CAACV,KAAD,EAAQ;AAAEE,QAAAA,KAAF;AAASS,QAAAA,KAAT;AAAgBV,QAAAA;AAAhB,OAAR,EAAkC;AAAEmG,QAAAA,UAAU,EAAEI,GAAd;AAAmB/F,QAAAA;AAAnB,OAAlC,EAAgE;AAAE2F,QAAAA,UAAF;AAAcpE,QAAAA;AAAd,OAAhE,EAAsF;AAE1F,cAAMyE,KAAK,GAAG;AACVC,UAAAA,MAAM,EAAEC,MAAM,CAACC,MAAP,CAAc,IAAd,CADE;AAEVC,UAAAA,MAAM,EAAEF,MAAM,CAACC,MAAP,CAAc,IAAd,CAFE;AAGVtD,UAAAA,SAAS,EAAEqD,MAAM,CAACC,MAAP,CAAc,IAAd,CAHD;AAIVE,UAAAA,OAAO,EAAEH,MAAM,CAACC,MAAP,CAAc,IAAd,CAJC;AAKVG,UAAAA,MAAM,EAAE,IAAIC,GAAJ,EALE;AAMVC,UAAAA,QAAQ,EAAE,IAAID,GAAJ,EANA;AAOVE,UAAAA,MAAM,EAAE,IAAIF,GAAJ;AAPE,SAAd;AAUA,cAAM/B,OAAO,GAAGmB,UAAU,IAAI7H,SAA9B;AACA,cAAM4I,eAAe,GAAG1G,OAAO,CAAC0G,eAAhC;;AAEA,aAAK,IAAIvF,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG5B,KAAK,CAAC6B,MAA1B,EAAkC,EAAED,CAApC,EAAuC;AACnC,gBAAMqB,IAAI,GAAGjB,IAAI,GAAGxD,KAAK,CAACwB,KAAK,CAAC4B,CAAD,CAAN,EAAWI,IAAX,CAAR,GAA2BhC,KAAK,CAAC4B,CAAD,CAAjD;AACA,gBAAMwF,OAAO,GAAGhB,UAAU,GAAGK,KAAK,CAACS,MAAT,GAAkBT,KAAK,CAAC,OAAOxD,IAAR,CAAjD;AACA5E,UAAAA,MAAM,CAAC+I,OAAD,EAAU,8CAAV,EAA0D,OAAOnE,IAAjE,CAAN;;AAEA,cAAImE,OAAO,YAAYJ,GAAvB,EAA4B;AACxB,kBAAMK,OAAO,GAAGD,OAAO,CAACC,OAAR,EAAhB;AACA,gBAAIC,OAAJ;;AACA,mBAAO,CAAC,CAACA,OAAO,GAAGD,OAAO,CAACE,IAAR,EAAX,EAA2BC,IAAnC,EAAyC;AACrC,kBAAIvC,OAAO,CAACqC,OAAO,CAACtH,KAAR,CAAc,CAAd,CAAD,EAAmBiD,IAAnB,CAAX,EAAqC;AACjC,sBAAMnB,UAAU,GAAG5B,KAAK,CAAC6B,QAAN,CAAe,CAAC,GAAG7B,KAAK,CAAC8B,IAAV,EAAgBJ,CAAhB,CAAf,EAAmC,CAAC5B,KAAD,EAAQ,GAAGE,KAAK,CAACyB,SAAjB,CAAnC,CAAnB;AACA,sBAAM8F,OAAO,GAAG;AACZlE,kBAAAA,GAAG,EAAE3B,CADO;AAEZ5B,kBAAAA,KAAK,EAAEA,KAAK,CAAC4B,CAAD,CAFA;AAGZ8F,kBAAAA,OAAO,EAAEJ,OAAO,CAACtH,KAAR,CAAc,CAAd,CAHG;AAIZ2H,kBAAAA,SAAS,EAAE3H,KAAK,CAACsH,OAAO,CAACtH,KAAR,CAAc,CAAd,CAAD;AAJJ,iBAAhB;;AAOA,oBAAIgC,IAAJ,EAAU;AACNyF,kBAAAA,OAAO,CAACzF,IAAR,GAAewE,GAAf;AACH;;AAED,uBAAO7F,KAAK,CAAC,cAAD,EAAiB8G,OAAjB,EAA0B3F,UAA1B,CAAZ;AACH;AACJ;;AAEDsF,YAAAA,OAAO,CAACQ,GAAR,CAAY3E,IAAZ,EAAkBrB,CAAlB;AACH,WAtBD,MAuBK;AACD,gBAAI,CAAC,CAACuF,eAAD,IAAoBlE,IAAI,KAAKK,SAA9B,KACA8D,OAAO,CAACnE,IAAD,CAAP,KAAkBK,SADtB,EACiC;AAE7B,oBAAMmE,OAAO,GAAG;AACZlE,gBAAAA,GAAG,EAAE3B,CADO;AAEZ5B,gBAAAA,KAAK,EAAEA,KAAK,CAAC4B,CAAD,CAFA;AAGZ8F,gBAAAA,OAAO,EAAEN,OAAO,CAACnE,IAAD,CAHJ;AAIZ0E,gBAAAA,SAAS,EAAE3H,KAAK,CAACoH,OAAO,CAACnE,IAAD,CAAR;AAJJ,eAAhB;;AAOA,kBAAIjB,IAAJ,EAAU;AACNyF,gBAAAA,OAAO,CAACzF,IAAR,GAAewE,GAAf;AACH;;AAED,oBAAM1E,UAAU,GAAG5B,KAAK,CAAC6B,QAAN,CAAe,CAAC,GAAG7B,KAAK,CAAC8B,IAAV,EAAgBJ,CAAhB,CAAf,EAAmC,CAAC5B,KAAD,EAAQ,GAAGE,KAAK,CAACyB,SAAjB,CAAnC,CAAnB;AACA,qBAAOhB,KAAK,CAAC,cAAD,EAAiB8G,OAAjB,EAA0B3F,UAA1B,CAAZ;AACH;;AAEDsF,YAAAA,OAAO,CAACnE,IAAD,CAAP,GAAgBrB,CAAhB;AACH;AACJ;;AAED,eAAO5B,KAAP;AACH,OAvFG;;AAwFJQ,MAAAA,IAAI,EAAE,CAAC,YAAD,EAAe,SAAf,CAxFF;AAyFJ4B,MAAAA,KAAK,EAAE;AAzFH;AA/YL,GA1DiB;AAsiBxByF,EAAAA,IAAI,EAAE;AACFD,IAAAA,GAAG,EAAE;AACD9H,MAAAA,IAAI,EAAEM,KAAK,CAACC,OADX;;AAEDyH,MAAAA,EAAE,CAAC9H,KAAD,EAAQgF,OAAR,EAAiB;AAEf,eAAO,IAAI+C,GAAJ,CAAQ/H,KAAR,CAAP;AACH;;AALA;AADH,GAtiBkB;;AAgjBxBgI,EAAAA,OAAO,CAAC/H,MAAD,EAAS;AAEZA,IAAAA,MAAM,CAACe,OAAP,CAAerB,WAAf,GAA6B,EAA7B;AACAM,IAAAA,MAAM,CAACe,OAAP,CAAetB,WAAf,GAA6B,EAA7B;AACAO,IAAAA,MAAM,CAACe,OAAP,CAAepB,UAAf,GAA4B,EAA5B;;AAEA,SAAK,MAAMZ,IAAX,IAAmBiB,MAAM,CAACe,OAAP,CAAe1B,KAAlC,EAAyC;AACrCV,MAAAA,SAAS,CAAC2G,cAAV,CAAyBvG,IAAzB,EAA+BiB,MAA/B;;AAEA,UAAIjB,IAAI,CAAC4B,MAAL,CAAY+C,QAAZ,KAAyB,UAA7B,EAAyC;AACrC1D,QAAAA,MAAM,CAACe,OAAP,CAAepB,UAAf,CAA0B6C,IAA1B,CAA+BzD,IAA/B;AACH,OAFD,MAGK,IAAIA,IAAI,CAAC4B,MAAL,CAAY+C,QAAZ,KAAyB,WAA7B,EAA0C;AAC3C1D,QAAAA,MAAM,CAACe,OAAP,CAAetB,WAAf,CAA2B+C,IAA3B,CAAgCzD,IAAhC;AACH,OAFI,MAGA;AACDiB,QAAAA,MAAM,CAACe,OAAP,CAAerB,WAAf,CAA2B8C,IAA3B,CAAgCzD,IAAhC;AACH;AACJ;;AAED,SAAK,MAAMA,IAAX,IAAmBiB,MAAM,CAACe,OAAP,CAAevB,OAAlC,EAA2C;AACvCb,MAAAA,SAAS,CAAC2G,cAAV,CAAyBvG,IAAzB,EAA+BiB,MAA/B;AACH;AACJ,GAvkBuB;;AAykBxBT,EAAAA,QAAQ,EAAE;AAENyI,IAAAA,KAAK,CAAC1G,GAAD,EAAM2G,IAAN,EAAY;AAEb,UAAIA,IAAI,CAAC5I,KAAT,EAAgB;AACZiC,QAAAA,GAAG,GAAGA,GAAG,CAACjC,KAAJ,CAAU,GAAG4I,IAAI,CAAC5I,KAAlB,CAAN;AACH;;AAED,UAAI4I,IAAI,CAACzI,OAAT,EAAkB;AACd8B,QAAAA,GAAG,GAAGA,GAAG,CAAC9B,OAAJ,CAAY,GAAGyI,IAAI,CAACzI,OAApB,CAAN;AACH;;AAED,aAAO8B,GAAP;AACH;;AAbK,GAzkBc;AAylBxB4G,EAAAA,QAAQ,EAAE;AACN,kBAAc,6BADR;AAEN,sBAAkB,uCAFZ;AAGN,sBAAkB,mFAHZ;AAIN,wBAAoB,yDAJd;AAKN,sBAAkB,oDALZ;AAMN,kCAA8B,6FANxB;AAON,oCAAgC,8CAP1B;AAQN,sCAAkC,kEAR5B;AASN,oBAAgB,0CATV;AAUN,iBAAa,gEAVP;AAWN,iBAAa,mDAXP;AAYN,2BAAuB,kDAZjB;AAaN,kBAAc,wDAbR;AAcN,8BAA0B,sDAdpB;AAeN,8BAA0B,6DAfpB;AAgBN,oBAAgB,4CAhBV;AAiBN,oBAAgB;AAjBV;AAzlBc,CAAX,CAAjB,C,CA+mBA;;AAEAvJ,SAAS,CAAC+F,gBAAV,GAA6B,UAAU1E,MAAV,EAAkBc,MAAlB,EAA0B6B,SAA1B,EAAqC5C,KAArC,EAA4CE,KAA5C,EAAmDC,KAAnD,EAA0D;AAEnF,QAAMiI,WAAW,GAAG,EAApB;AACA,MAAIC,aAAa,GAAG,CAApB;;AACA,OAAK,MAAMC,QAAX,IAAuB1F,SAAvB,EAAkC;AAC9B,UAAMT,KAAK,GAAGmG,QAAQ,CAAC1H,MAAT,CAAgBuB,KAA9B;;AACA,QAAIA,KAAJ,EAAW;AACPiG,MAAAA,WAAW,CAAC3F,IAAZ,CAAiBN,KAAjB;AACH,KAFD,MAGK;AACD,QAAEkG,aAAF;AACH;AACJ;;AAED,MAAID,WAAW,CAACvG,MAAhB,EAAwB;AACpB,QAAIwG,aAAJ,EAAmB;AACftH,MAAAA,MAAM,CAAC0B,IAAP,CAAYxC,MAAM,CAACsI,aAAP,CAAqB,4BAArB,EAAmDvI,KAAnD,EAA0D;AAAEoI,QAAAA,WAAF;AAAeC,QAAAA;AAAf,OAA1D,EAA0FnI,KAA1F,EAAiGC,KAAjG,CAAZ;AACH,KAFD,MAGK;AACDY,MAAAA,MAAM,CAAC0B,IAAP,CAAYxC,MAAM,CAACsI,aAAP,CAAqB,8BAArB,EAAqDvI,KAArD,EAA4D;AAAEoI,QAAAA;AAAF,OAA5D,EAA6ElI,KAA7E,EAAoFC,KAApF,CAAZ;AACH;AACJ,GAPD,MAQK;AACDY,IAAAA,MAAM,CAAC0B,IAAP,CAAYxC,MAAM,CAACsI,aAAP,CAAqB,gCAArB,EAAuDvI,KAAvD,EAA8D;AAAEqI,MAAAA;AAAF,KAA9D,EAAiFnI,KAAjF,EAAwFC,KAAxF,CAAZ;AACH;AACJ,CAzBD;;AA4BAvB,SAAS,CAACgG,iBAAV,GAA8B,UAAU3E,MAAV,EAAkBc,MAAlB,EAA0B8B,QAA1B,EAAoC7C,KAApC,EAA2CE,KAA3C,EAAkDC,KAAlD,EAAyD;AAEnF,QAAMqI,gBAAgB,GAAG,EAAzB;;AAEA,OAAK,MAAM/I,OAAX,IAAsBoD,QAAtB,EAAgC;AAC5B,QAAIpD,OAAO,CAACmB,MAAR,CAAe+C,QAAf,KAA4B,UAAhC,EAA4C;AACxC6E,MAAAA,gBAAgB,CAAC/F,IAAjB,CAAsBhD,OAAtB;AACH;AACJ;;AAED,MAAI+I,gBAAgB,CAAC3G,MAArB,EAA6B;AACzBjD,IAAAA,SAAS,CAAC+F,gBAAV,CAA2B1E,MAA3B,EAAmCc,MAAnC,EAA2CyH,gBAA3C,EAA6DxI,KAA7D,EAAoEE,KAApE,EAA2EC,KAA3E;AACH;AACJ,CAbD;;AAgBAvB,SAAS,CAACiG,WAAV,GAAwB,UAAUhC,QAAV,EAAoB7C,KAApB,EAA2BE,KAA3B,EAAkCC,KAAlC,EAAyC;AAE7D,QAAMsI,SAAS,GAAG,EAAlB;AACA,MAAIC,iBAAiB,GAAG,IAAxB;;AAEA,OAAK,IAAI9G,CAAC,GAAGiB,QAAQ,CAAChB,MAAT,GAAkB,CAA/B,EAAkCD,CAAC,IAAI,CAAvC,EAA0C,EAAEA,CAA5C,EAA+C;AAC3C,UAAMnC,OAAO,GAAGoD,QAAQ,CAACjB,CAAD,CAAxB;AACA,UAAMD,SAAS,GAAG,CAAC3B,KAAD,EAAQ,GAAGE,KAAK,CAACyB,SAAjB,CAAlB;AACA,UAAMgH,QAAQ,GAAGlJ,OAAO,CAACoE,UAAR,CAAmBP,SAAnB,EAA8BpD,KAAK,CAAC6B,QAAN,CAAe7B,KAAK,CAAC8B,IAArB,EAA2BL,SAA3B,EAAsClC,OAAtC,CAA9B,EAA8EU,KAA9E,EAAqFH,KAAtG;;AAEA,QAAI0I,iBAAJ,EAAuB;AACnB,UAAIC,QAAQ,KAAKrF,SAAjB,EAA4B;AACxB;AACH;;AAEDoF,MAAAA,iBAAiB,GAAG,KAApB;AACH;;AAEDD,IAAAA,SAAS,CAACG,OAAV,CAAkBD,QAAlB;AACH;;AAED,MAAIF,SAAS,CAAC5G,MAAd,EAAsB;AAClB7B,IAAAA,KAAK,CAACyC,IAAN,CAAW,GAAGgG,SAAd;AACH;AACJ,CAxBD;;AA2BA7J,SAAS,CAACmF,UAAV,GAAuB,UAAU8E,GAAV,EAAejH,CAAf,EAAkB;AAErC,MAAI2B,GAAG,GAAG3B,CAAV;;AACA,SAAO2B,GAAG,GAAGsF,GAAG,CAAChH,MAAjB,EAAyB;AACrBgH,IAAAA,GAAG,CAACtF,GAAG,EAAJ,CAAH,GAAasF,GAAG,CAACtF,GAAD,CAAhB;AACH;;AAED,IAAEsF,GAAG,CAAChH,MAAN;AACH,CARD;;AAWAjD,SAAS,CAAC2G,cAAV,GAA2B,UAAUvG,IAAV,EAAgBuC,GAAhB,EAAqB;AAE5C,MAAIvC,IAAI,CAACA,IAAL,KAAc,OAAd,IACAA,IAAI,CAAC4B,MAAL,CAAY6E,WADhB,EAC6B;AAEzBpH,IAAAA,MAAM,CAAC,CAACkD,GAAG,CAACX,MAAJ,CAAW1B,MAAb,EAAqB,oDAArB,CAAN;AACAqC,IAAAA,GAAG,CAACmE,SAAJ,CAAc,aAAd,EAA6B,IAA7B,EAAmC;AAAEQ,MAAAA,KAAK,EAAE;AAAT,KAAnC;AACH;AACJ,CARD;;AAWAtH,SAAS,CAAC0B,IAAV,GAAiB,UAAUL,MAAV,EAAkBD,KAAlB,EAAyB4F,QAAzB,EAAmC1F,KAAnC,EAA0CC,KAA1C,EAAiD;AAE9D,QAAM0F,KAAK,GAAGD,QAAQ,CAACC,KAAT,KAAmB,WAAnB,GAAiC,CAAjC,GAAqC,CAAC,CAApD;AACA,QAAMiD,MAAM,GAAG,CAAC,CAAD,GAAKjD,KAApB;AACA,QAAMkD,MAAM,GAAGlD,KAAf;;AAEA,QAAMvF,IAAI,GAAG,CAAC0I,CAAD,EAAIC,CAAJ,KAAU;AAEnB,QAAIhE,OAAO,GAAGrG,SAAS,CAACqG,OAAV,CAAkB+D,CAAlB,EAAqBC,CAArB,EAAwBH,MAAxB,EAAgCC,MAAhC,CAAd;;AACA,QAAI9D,OAAO,KAAK,IAAhB,EAAsB;AAClB,aAAOA,OAAP;AACH;;AAED,QAAIW,QAAQ,CAACE,EAAb,EAAiB;AACbkD,MAAAA,CAAC,GAAGpD,QAAQ,CAACE,EAAT,CAAYoD,OAAZ,CAAoBF,CAApB,EAAuB9I,KAAvB,EAA8BC,KAA9B,CAAJ;AACA8I,MAAAA,CAAC,GAAGrD,QAAQ,CAACE,EAAT,CAAYoD,OAAZ,CAAoBD,CAApB,EAAuB/I,KAAvB,EAA8BC,KAA9B,CAAJ;AACH;;AAED8E,IAAAA,OAAO,GAAGrG,SAAS,CAACqG,OAAV,CAAkB+D,CAAlB,EAAqBC,CAArB,EAAwBH,MAAxB,EAAgCC,MAAhC,CAAV;;AACA,QAAI9D,OAAO,KAAK,IAAhB,EAAsB;AAClB,aAAOA,OAAP;AACH;;AAED,UAAMjG,IAAI,GAAG,OAAOgK,CAApB;;AACA,QAAIhK,IAAI,KAAK,OAAOiK,CAApB,EAAuB;AACnB,YAAMhJ,MAAM,CAACsI,aAAP,CAAqB,wBAArB,EAA+CvI,KAA/C,EAAsD,IAAtD,EAA4DE,KAA5D,EAAmEC,KAAnE,CAAN;AACH;;AAED,QAAInB,IAAI,KAAK,QAAT,IACAA,IAAI,KAAK,QADb,EACuB;AAEnB,YAAMiB,MAAM,CAACsI,aAAP,CAAqB,wBAArB,EAA+CvI,KAA/C,EAAsD;AAAEhB,QAAAA;AAAF,OAAtD,EAAgEkB,KAAhE,EAAuEC,KAAvE,CAAN;AACH;;AAED,QAAInB,IAAI,KAAK,QAAb,EAAuB;AACnB,aAAO,CAACgK,CAAC,GAAGC,CAAL,IAAUpD,KAAjB;AACH;;AAED,WAAOmD,CAAC,GAAGC,CAAJ,GAAQH,MAAR,GAAiBC,MAAxB;AACH,GAjCD;;AAmCA,MAAI;AACA,WAAO;AAAE/I,MAAAA,KAAK,EAAEA,KAAK,CAACkB,KAAN,GAAcZ,IAAd,CAAmBA,IAAnB;AAAT,KAAP;AACH,GAFD,CAGA,OAAO6I,GAAP,EAAY;AACR,WAAO;AAAEpI,MAAAA,MAAM,EAAEoI;AAAV,KAAP;AACH;AACJ,CA/CD;;AAkDAvK,SAAS,CAACqG,OAAV,GAAoB,UAAU+D,CAAV,EAAaC,CAAb,EAAgBH,MAAhB,EAAwBC,MAAxB,EAAgC;AAEhD,MAAIC,CAAC,KAAKC,CAAV,EAAa;AACT,WAAO,CAAP;AACH;;AAED,MAAID,CAAC,KAAK1F,SAAV,EAAqB;AACjB,WAAO,CAAP,CADiB,CACG;AACvB;;AAED,MAAI2F,CAAC,KAAK3F,SAAV,EAAqB;AACjB,WAAO,CAAC,CAAR,CADiB,CACI;AACxB;;AAED,MAAI0F,CAAC,KAAK,IAAV,EAAgB;AACZ,WAAOD,MAAP;AACH;;AAED,MAAIE,CAAC,KAAK,IAAV,EAAgB;AACZ,WAAOH,MAAP;AACH;;AAED,SAAO,IAAP;AACH,CAvBD","sourcesContent":["'use strict';\n\nconst Assert = require('@hapi/hoek/lib/assert');\nconst DeepEqual = require('@hapi/hoek/lib/deepEqual');\nconst Reach = require('@hapi/hoek/lib/reach');\n\nconst Any = require('./any');\nconst Common = require('../common');\nconst Compile = require('../compile');\n\n\nconst internals = {};\n\n\nmodule.exports = Any.extend({\n\n    type: 'array',\n\n    flags: {\n\n        single: { default: false },\n        sparse: { default: false }\n    },\n\n    terms: {\n\n        items: { init: [], manifest: 'schema' },\n        ordered: { init: [], manifest: 'schema' },\n\n        _exclusions: { init: [] },\n        _inclusions: { init: [] },\n        _requireds: { init: [] }\n    },\n\n    coerce: {\n        from: 'object',\n        method(value, { schema, state, prefs }) {\n\n            if (!Array.isArray(value)) {\n                return;\n            }\n\n            const sort = schema.$_getRule('sort');\n            if (!sort) {\n                return;\n            }\n\n            return internals.sort(schema, value, sort.args.options, state, prefs);\n        }\n    },\n\n    validate(value, { schema, error }) {\n\n        if (!Array.isArray(value)) {\n            if (schema._flags.single) {\n                const single = [value];\n                single[Common.symbols.arraySingle] = true;\n                return { value: single };\n            }\n\n            return { errors: error('array.base') };\n        }\n\n        if (!schema.$_getRule('items') &&\n            !schema.$_terms.externals) {\n\n            return;\n        }\n\n        return { value: value.slice() };        // Clone the array so that we don't modify the original\n    },\n\n    rules: {\n\n        has: {\n            method(schema) {\n\n                schema = this.$_compile(schema, { appendPath: true });\n                const obj = this.$_addRule({ name: 'has', args: { schema } });\n                obj.$_mutateRegister(schema);\n                return obj;\n            },\n            validate(value, { state, prefs, error }, { schema: has }) {\n\n                const ancestors = [value, ...state.ancestors];\n                for (let i = 0; i < value.length; ++i) {\n                    const localState = state.localize([...state.path, i], ancestors, has);\n                    if (has.$_match(value[i], localState, prefs)) {\n                        return value;\n                    }\n                }\n\n                const patternLabel = has._flags.label;\n                if (patternLabel) {\n                    return error('array.hasKnown', { patternLabel });\n                }\n\n                return error('array.hasUnknown', null);\n            },\n            multi: true\n        },\n\n        items: {\n            method(...schemas) {\n\n                Common.verifyFlat(schemas, 'items');\n\n                const obj = this.$_addRule('items');\n\n                for (let i = 0; i < schemas.length; ++i) {\n                    const type = Common.tryWithPath(() => this.$_compile(schemas[i]), i, { append: true });\n                    obj.$_terms.items.push(type);\n                }\n\n                return obj.$_mutateRebuild();\n            },\n            validate(value, { schema, error, state, prefs, errorsArray }) {\n\n                const requireds = schema.$_terms._requireds.slice();\n                const ordereds = schema.$_terms.ordered.slice();\n                const inclusions = [...schema.$_terms._inclusions, ...requireds];\n\n                const wasArray = !value[Common.symbols.arraySingle];\n                delete value[Common.symbols.arraySingle];\n\n                const errors = errorsArray();\n\n                let il = value.length;\n                for (let i = 0; i < il; ++i) {\n                    const item = value[i];\n\n                    let errored = false;\n                    let isValid = false;\n\n                    const key = wasArray ? i : new Number(i);       // eslint-disable-line no-new-wrappers\n                    const path = [...state.path, key];\n\n                    // Sparse\n\n                    if (!schema._flags.sparse &&\n                        item === undefined) {\n\n                        errors.push(error('array.sparse', { key, path, pos: i, value: undefined }, state.localize(path)));\n                        if (prefs.abortEarly) {\n                            return errors;\n                        }\n\n                        ordereds.shift();\n                        continue;\n                    }\n\n                    // Exclusions\n\n                    const ancestors = [value, ...state.ancestors];\n\n                    for (const exclusion of schema.$_terms._exclusions) {\n                        if (!exclusion.$_match(item, state.localize(path, ancestors, exclusion), prefs, { presence: 'ignore' })) {\n                            continue;\n                        }\n\n                        errors.push(error('array.excludes', { pos: i, value: item }, state.localize(path)));\n                        if (prefs.abortEarly) {\n                            return errors;\n                        }\n\n                        errored = true;\n                        ordereds.shift();\n                        break;\n                    }\n\n                    if (errored) {\n                        continue;\n                    }\n\n                    // Ordered\n\n                    if (schema.$_terms.ordered.length) {\n                        if (ordereds.length) {\n                            const ordered = ordereds.shift();\n                            const res = ordered.$_validate(item, state.localize(path, ancestors, ordered), prefs);\n                            if (!res.errors) {\n                                if (ordered._flags.result === 'strip') {\n                                    internals.fastSplice(value, i);\n                                    --i;\n                                    --il;\n                                }\n                                else if (!schema._flags.sparse && res.value === undefined) {\n                                    errors.push(error('array.sparse', { key, path, pos: i, value: undefined }, state.localize(path)));\n                                    if (prefs.abortEarly) {\n                                        return errors;\n                                    }\n\n                                    continue;\n                                }\n                                else {\n                                    value[i] = res.value;\n                                }\n                            }\n                            else {\n                                errors.push(...res.errors);\n                                if (prefs.abortEarly) {\n                                    return errors;\n                                }\n                            }\n\n                            continue;\n                        }\n                        else if (!schema.$_terms.items.length) {\n                            errors.push(error('array.orderedLength', { pos: i, limit: schema.$_terms.ordered.length }));\n                            if (prefs.abortEarly) {\n                                return errors;\n                            }\n\n                            break;      // No reason to continue since there are no other rules to validate other than array.orderedLength\n                        }\n                    }\n\n                    // Requireds\n\n                    const requiredChecks = [];\n                    let jl = requireds.length;\n                    for (let j = 0; j < jl; ++j) {\n                        const localState = state.localize(path, ancestors, requireds[j]);\n                        localState.snapshot();\n\n                        const res = requireds[j].$_validate(item, localState, prefs);\n                        requiredChecks[j] = res;\n\n                        if (!res.errors) {\n                            value[i] = res.value;\n                            isValid = true;\n                            internals.fastSplice(requireds, j);\n                            --j;\n                            --jl;\n\n                            if (!schema._flags.sparse &&\n                                res.value === undefined) {\n\n                                errors.push(error('array.sparse', { key, path, pos: i, value: undefined }, state.localize(path)));\n                                if (prefs.abortEarly) {\n                                    return errors;\n                                }\n                            }\n\n                            break;\n                        }\n\n                        localState.restore();\n                    }\n\n                    if (isValid) {\n                        continue;\n                    }\n\n                    // Inclusions\n\n                    const stripUnknown = prefs.stripUnknown && !!prefs.stripUnknown.arrays || false;\n\n                    jl = inclusions.length;\n                    for (const inclusion of inclusions) {\n\n                        // Avoid re-running requireds that already didn't match in the previous loop\n\n                        let res;\n                        const previousCheck = requireds.indexOf(inclusion);\n                        if (previousCheck !== -1) {\n                            res = requiredChecks[previousCheck];\n                        }\n                        else {\n                            const localState = state.localize(path, ancestors, inclusion);\n                            localState.snapshot();\n\n                            res = inclusion.$_validate(item, localState, prefs);\n                            if (!res.errors) {\n                                if (inclusion._flags.result === 'strip') {\n                                    internals.fastSplice(value, i);\n                                    --i;\n                                    --il;\n                                }\n                                else if (!schema._flags.sparse &&\n                                    res.value === undefined) {\n\n                                    errors.push(error('array.sparse', { key, path, pos: i, value: undefined }, state.localize(path)));\n                                    errored = true;\n                                }\n                                else {\n                                    value[i] = res.value;\n                                }\n\n                                isValid = true;\n                                break;\n                            }\n\n                            localState.restore();\n                        }\n\n                        // Return the actual error if only one inclusion defined\n\n                        if (jl === 1) {\n                            if (stripUnknown) {\n                                internals.fastSplice(value, i);\n                                --i;\n                                --il;\n                                isValid = true;\n                                break;\n                            }\n\n                            errors.push(...res.errors);\n                            if (prefs.abortEarly) {\n                                return errors;\n                            }\n\n                            errored = true;\n                            break;\n                        }\n                    }\n\n                    if (errored) {\n                        continue;\n                    }\n\n                    if ((schema.$_terms._inclusions.length || schema.$_terms._requireds.length) &&\n                        !isValid) {\n\n                        if (stripUnknown) {\n                            internals.fastSplice(value, i);\n                            --i;\n                            --il;\n                            continue;\n                        }\n\n                        errors.push(error('array.includes', { pos: i, value: item }, state.localize(path)));\n                        if (prefs.abortEarly) {\n                            return errors;\n                        }\n                    }\n                }\n\n                if (requireds.length) {\n                    internals.fillMissedErrors(schema, errors, requireds, value, state, prefs);\n                }\n\n                if (ordereds.length) {\n                    internals.fillOrderedErrors(schema, errors, ordereds, value, state, prefs);\n\n                    if (!errors.length) {\n                        internals.fillDefault(ordereds, value, state, prefs);\n                    }\n                }\n\n                return errors.length ? errors : value;\n            },\n\n            priority: true,\n            manifest: false\n        },\n\n        length: {\n            method(limit) {\n\n                return this.$_addRule({ name: 'length', args: { limit }, operator: '=' });\n            },\n            validate(value, helpers, { limit }, { name, operator, args }) {\n\n                if (Common.compare(value.length, limit, operator)) {\n                    return value;\n                }\n\n                return helpers.error('array.' + name, { limit: args.limit, value });\n            },\n            args: [\n                {\n                    name: 'limit',\n                    ref: true,\n                    assert: Common.limit,\n                    message: 'must be a positive integer'\n                }\n            ]\n        },\n\n        max: {\n            method(limit) {\n\n                return this.$_addRule({ name: 'max', method: 'length', args: { limit }, operator: '<=' });\n            }\n        },\n\n        min: {\n            method(limit) {\n\n                return this.$_addRule({ name: 'min', method: 'length', args: { limit }, operator: '>=' });\n            }\n        },\n\n        ordered: {\n            method(...schemas) {\n\n                Common.verifyFlat(schemas, 'ordered');\n\n                const obj = this.$_addRule('items');\n\n                for (let i = 0; i < schemas.length; ++i) {\n                    const type = Common.tryWithPath(() => this.$_compile(schemas[i]), i, { append: true });\n                    internals.validateSingle(type, obj);\n\n                    obj.$_mutateRegister(type);\n                    obj.$_terms.ordered.push(type);\n                }\n\n                return obj.$_mutateRebuild();\n            }\n        },\n\n        single: {\n            method(enabled) {\n\n                const value = enabled === undefined ? true : !!enabled;\n                Assert(!value || !this._flags._arrayItems, 'Cannot specify single rule when array has array items');\n\n                return this.$_setFlag('single', value);\n            }\n        },\n\n        sort: {\n            method(options = {}) {\n\n                Common.assertOptions(options, ['by', 'order']);\n\n                const settings = {\n                    order: options.order || 'ascending'\n                };\n\n                if (options.by) {\n                    settings.by = Compile.ref(options.by, { ancestor: 0 });\n                    Assert(!settings.by.ancestor, 'Cannot sort by ancestor');\n                }\n\n                return this.$_addRule({ name: 'sort', args: { options: settings } });\n            },\n            validate(value, { error, state, prefs, schema }, { options }) {\n\n                const { value: sorted, errors } = internals.sort(schema, value, options, state, prefs);\n                if (errors) {\n                    return errors;\n                }\n\n                for (let i = 0; i < value.length; ++i) {\n                    if (value[i] !== sorted[i]) {\n                        return error('array.sort', { order: options.order, by: options.by ? options.by.key : 'value' });\n                    }\n                }\n\n                return value;\n            },\n            convert: true\n        },\n\n        sparse: {\n            method(enabled) {\n\n                const value = enabled === undefined ? true : !!enabled;\n\n                if (this._flags.sparse === value) {\n                    return this;\n                }\n\n                const obj = value ? this.clone() : this.$_addRule('items');\n                return obj.$_setFlag('sparse', value, { clone: false });\n            }\n        },\n\n        unique: {\n            method(comparator, options = {}) {\n\n                Assert(!comparator || typeof comparator === 'function' || typeof comparator === 'string', 'comparator must be a function or a string');\n                Common.assertOptions(options, ['ignoreUndefined', 'separator']);\n\n                const rule = { name: 'unique', args: { options, comparator } };\n\n                if (comparator) {\n                    if (typeof comparator === 'string') {\n                        const separator = Common.default(options.separator, '.');\n                        rule.path = separator ? comparator.split(separator) : [comparator];\n                    }\n                    else {\n                        rule.comparator = comparator;\n                    }\n                }\n\n                return this.$_addRule(rule);\n            },\n            validate(value, { state, error, schema }, { comparator: raw, options }, { comparator, path }) {\n\n                const found = {\n                    string: Object.create(null),\n                    number: Object.create(null),\n                    undefined: Object.create(null),\n                    boolean: Object.create(null),\n                    object: new Map(),\n                    function: new Map(),\n                    custom: new Map()\n                };\n\n                const compare = comparator || DeepEqual;\n                const ignoreUndefined = options.ignoreUndefined;\n\n                for (let i = 0; i < value.length; ++i) {\n                    const item = path ? Reach(value[i], path) : value[i];\n                    const records = comparator ? found.custom : found[typeof item];\n                    Assert(records, 'Failed to find unique map container for type', typeof item);\n\n                    if (records instanceof Map) {\n                        const entries = records.entries();\n                        let current;\n                        while (!(current = entries.next()).done) {\n                            if (compare(current.value[0], item)) {\n                                const localState = state.localize([...state.path, i], [value, ...state.ancestors]);\n                                const context = {\n                                    pos: i,\n                                    value: value[i],\n                                    dupePos: current.value[1],\n                                    dupeValue: value[current.value[1]]\n                                };\n\n                                if (path) {\n                                    context.path = raw;\n                                }\n\n                                return error('array.unique', context, localState);\n                            }\n                        }\n\n                        records.set(item, i);\n                    }\n                    else {\n                        if ((!ignoreUndefined || item !== undefined) &&\n                            records[item] !== undefined) {\n\n                            const context = {\n                                pos: i,\n                                value: value[i],\n                                dupePos: records[item],\n                                dupeValue: value[records[item]]\n                            };\n\n                            if (path) {\n                                context.path = raw;\n                            }\n\n                            const localState = state.localize([...state.path, i], [value, ...state.ancestors]);\n                            return error('array.unique', context, localState);\n                        }\n\n                        records[item] = i;\n                    }\n                }\n\n                return value;\n            },\n            args: ['comparator', 'options'],\n            multi: true\n        }\n    },\n\n    cast: {\n        set: {\n            from: Array.isArray,\n            to(value, helpers) {\n\n                return new Set(value);\n            }\n        }\n    },\n\n    rebuild(schema) {\n\n        schema.$_terms._inclusions = [];\n        schema.$_terms._exclusions = [];\n        schema.$_terms._requireds = [];\n\n        for (const type of schema.$_terms.items) {\n            internals.validateSingle(type, schema);\n\n            if (type._flags.presence === 'required') {\n                schema.$_terms._requireds.push(type);\n            }\n            else if (type._flags.presence === 'forbidden') {\n                schema.$_terms._exclusions.push(type);\n            }\n            else {\n                schema.$_terms._inclusions.push(type);\n            }\n        }\n\n        for (const type of schema.$_terms.ordered) {\n            internals.validateSingle(type, schema);\n        }\n    },\n\n    manifest: {\n\n        build(obj, desc) {\n\n            if (desc.items) {\n                obj = obj.items(...desc.items);\n            }\n\n            if (desc.ordered) {\n                obj = obj.ordered(...desc.ordered);\n            }\n\n            return obj;\n        }\n    },\n\n    messages: {\n        'array.base': '{{#label}} must be an array',\n        'array.excludes': '{{#label}} contains an excluded value',\n        'array.hasKnown': '{{#label}} does not contain at least one required match for type {:#patternLabel}',\n        'array.hasUnknown': '{{#label}} does not contain at least one required match',\n        'array.includes': '{{#label}} does not match any of the allowed types',\n        'array.includesRequiredBoth': '{{#label}} does not contain {{#knownMisses}} and {{#unknownMisses}} other required value(s)',\n        'array.includesRequiredKnowns': '{{#label}} does not contain {{#knownMisses}}',\n        'array.includesRequiredUnknowns': '{{#label}} does not contain {{#unknownMisses}} required value(s)',\n        'array.length': '{{#label}} must contain {{#limit}} items',\n        'array.max': '{{#label}} must contain less than or equal to {{#limit}} items',\n        'array.min': '{{#label}} must contain at least {{#limit}} items',\n        'array.orderedLength': '{{#label}} must contain at most {{#limit}} items',\n        'array.sort': '{{#label}} must be sorted in {#order} order by {{#by}}',\n        'array.sort.mismatching': '{{#label}} cannot be sorted due to mismatching types',\n        'array.sort.unsupported': '{{#label}} cannot be sorted due to unsupported type {#type}',\n        'array.sparse': '{{#label}} must not be a sparse array item',\n        'array.unique': '{{#label}} contains a duplicate value'\n    }\n});\n\n\n// Helpers\n\ninternals.fillMissedErrors = function (schema, errors, requireds, value, state, prefs) {\n\n    const knownMisses = [];\n    let unknownMisses = 0;\n    for (const required of requireds) {\n        const label = required._flags.label;\n        if (label) {\n            knownMisses.push(label);\n        }\n        else {\n            ++unknownMisses;\n        }\n    }\n\n    if (knownMisses.length) {\n        if (unknownMisses) {\n            errors.push(schema.$_createError('array.includesRequiredBoth', value, { knownMisses, unknownMisses }, state, prefs));\n        }\n        else {\n            errors.push(schema.$_createError('array.includesRequiredKnowns', value, { knownMisses }, state, prefs));\n        }\n    }\n    else {\n        errors.push(schema.$_createError('array.includesRequiredUnknowns', value, { unknownMisses }, state, prefs));\n    }\n};\n\n\ninternals.fillOrderedErrors = function (schema, errors, ordereds, value, state, prefs) {\n\n    const requiredOrdereds = [];\n\n    for (const ordered of ordereds) {\n        if (ordered._flags.presence === 'required') {\n            requiredOrdereds.push(ordered);\n        }\n    }\n\n    if (requiredOrdereds.length) {\n        internals.fillMissedErrors(schema, errors, requiredOrdereds, value, state, prefs);\n    }\n};\n\n\ninternals.fillDefault = function (ordereds, value, state, prefs) {\n\n    const overrides = [];\n    let trailingUndefined = true;\n\n    for (let i = ordereds.length - 1; i >= 0; --i) {\n        const ordered = ordereds[i];\n        const ancestors = [value, ...state.ancestors];\n        const override = ordered.$_validate(undefined, state.localize(state.path, ancestors, ordered), prefs).value;\n\n        if (trailingUndefined) {\n            if (override === undefined) {\n                continue;\n            }\n\n            trailingUndefined = false;\n        }\n\n        overrides.unshift(override);\n    }\n\n    if (overrides.length) {\n        value.push(...overrides);\n    }\n};\n\n\ninternals.fastSplice = function (arr, i) {\n\n    let pos = i;\n    while (pos < arr.length) {\n        arr[pos++] = arr[pos];\n    }\n\n    --arr.length;\n};\n\n\ninternals.validateSingle = function (type, obj) {\n\n    if (type.type === 'array' ||\n        type._flags._arrayItems) {\n\n        Assert(!obj._flags.single, 'Cannot specify array item with single rule enabled');\n        obj.$_setFlag('_arrayItems', true, { clone: false });\n    }\n};\n\n\ninternals.sort = function (schema, value, settings, state, prefs) {\n\n    const order = settings.order === 'ascending' ? 1 : -1;\n    const aFirst = -1 * order;\n    const bFirst = order;\n\n    const sort = (a, b) => {\n\n        let compare = internals.compare(a, b, aFirst, bFirst);\n        if (compare !== null) {\n            return compare;\n        }\n\n        if (settings.by) {\n            a = settings.by.resolve(a, state, prefs);\n            b = settings.by.resolve(b, state, prefs);\n        }\n\n        compare = internals.compare(a, b, aFirst, bFirst);\n        if (compare !== null) {\n            return compare;\n        }\n\n        const type = typeof a;\n        if (type !== typeof b) {\n            throw schema.$_createError('array.sort.mismatching', value, null, state, prefs);\n        }\n\n        if (type !== 'number' &&\n            type !== 'string') {\n\n            throw schema.$_createError('array.sort.unsupported', value, { type }, state, prefs);\n        }\n\n        if (type === 'number') {\n            return (a - b) * order;\n        }\n\n        return a < b ? aFirst : bFirst;\n    };\n\n    try {\n        return { value: value.slice().sort(sort) };\n    }\n    catch (err) {\n        return { errors: err };\n    }\n};\n\n\ninternals.compare = function (a, b, aFirst, bFirst) {\n\n    if (a === b) {\n        return 0;\n    }\n\n    if (a === undefined) {\n        return 1;           // Always last regardless of sort order\n    }\n\n    if (b === undefined) {\n        return -1;           // Always last regardless of sort order\n    }\n\n    if (a === null) {\n        return bFirst;\n    }\n\n    if (b === null) {\n        return aFirst;\n    }\n\n    return null;\n};\n"]},"metadata":{},"sourceType":"script"}