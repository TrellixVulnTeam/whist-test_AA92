{"ast":null,"code":"'use strict';\n\nconst Assert = require('@hapi/hoek/lib/assert');\n\nconst Clone = require('@hapi/hoek/lib/clone');\n\nconst EscapeHtml = require('@hapi/hoek/lib/escapeHtml');\n\nconst Formula = require('@sideway/formula');\n\nconst Common = require('./common');\n\nconst Errors = require('./errors');\n\nconst Ref = require('./ref');\n\nconst internals = {\n  symbol: Symbol('template'),\n  opens: new Array(1000).join('\\u0000'),\n  closes: new Array(1000).join('\\u0001'),\n  dateFormat: {\n    date: Date.prototype.toDateString,\n    iso: Date.prototype.toISOString,\n    string: Date.prototype.toString,\n    time: Date.prototype.toTimeString,\n    utc: Date.prototype.toUTCString\n  }\n};\nmodule.exports = exports = internals.Template = class {\n  constructor(source, options) {\n    Assert(typeof source === 'string', 'Template source must be a string');\n    Assert(!source.includes('\\u0000') && !source.includes('\\u0001'), 'Template source cannot contain reserved control characters');\n    this.source = source;\n    this.rendered = source;\n    this._template = null;\n    this._settings = Clone(options);\n\n    this._parse();\n  }\n\n  _parse() {\n    // 'text {raw} {{ref}} \\\\{{ignore}} {{ignore\\\\}} {{ignore {{ignore}'\n    if (!this.source.includes('{')) {\n      return;\n    } // Encode escaped \\\\{{{{{\n\n\n    const encoded = internals.encode(this.source); // Split on first { in each set\n\n    const parts = internals.split(encoded); // Process parts\n\n    let refs = false;\n    const processed = [];\n    const head = parts.shift();\n\n    if (head) {\n      processed.push(head);\n    }\n\n    for (const part of parts) {\n      const raw = part[0] !== '{';\n      const ender = raw ? '}' : '}}';\n      const end = part.indexOf(ender);\n\n      if (end === -1 || // Ignore non-matching closing\n      part[1] === '{') {\n        // Ignore more than two {\n        processed.push(`{${internals.decode(part)}`);\n        continue;\n      }\n\n      let variable = part.slice(raw ? 0 : 1, end);\n      const wrapped = variable[0] === ':';\n\n      if (wrapped) {\n        variable = variable.slice(1);\n      }\n\n      const dynamic = this._ref(internals.decode(variable), {\n        raw,\n        wrapped\n      });\n\n      processed.push(dynamic);\n\n      if (typeof dynamic !== 'string') {\n        refs = true;\n      }\n\n      const rest = part.slice(end + ender.length);\n\n      if (rest) {\n        processed.push(internals.decode(rest));\n      }\n    }\n\n    if (!refs) {\n      this.rendered = processed.join('');\n      return;\n    }\n\n    this._template = processed;\n  }\n\n  static date(date, prefs) {\n    return internals.dateFormat[prefs.dateFormat].call(date);\n  }\n\n  describe(options = {}) {\n    if (!this._settings && options.compact) {\n      return this.source;\n    }\n\n    const desc = {\n      template: this.source\n    };\n\n    if (this._settings) {\n      desc.options = this._settings;\n    }\n\n    return desc;\n  }\n\n  static build(desc) {\n    return new internals.Template(desc.template, desc.options);\n  }\n\n  isDynamic() {\n    return !!this._template;\n  }\n\n  static isTemplate(template) {\n    return template ? !!template[Common.symbols.template] : false;\n  }\n\n  refs() {\n    if (!this._template) {\n      return;\n    }\n\n    const refs = [];\n\n    for (const part of this._template) {\n      if (typeof part !== 'string') {\n        refs.push(...part.refs);\n      }\n    }\n\n    return refs;\n  }\n\n  resolve(value, state, prefs, local) {\n    if (this._template && this._template.length === 1) {\n      return this._part(this._template[0],\n      /* context -> [*/\n      value, state, prefs, local, {}\n      /*] */\n      );\n    }\n\n    return this.render(value, state, prefs, local);\n  }\n\n  _part(part, ...args) {\n    if (part.ref) {\n      return part.ref.resolve(...args);\n    }\n\n    return part.formula.evaluate(args);\n  }\n\n  render(value, state, prefs, local, options = {}) {\n    if (!this.isDynamic()) {\n      return this.rendered;\n    }\n\n    const parts = [];\n\n    for (const part of this._template) {\n      if (typeof part === 'string') {\n        parts.push(part);\n      } else {\n        const rendered = this._part(part,\n        /* context -> [*/\n        value, state, prefs, local, options\n        /*] */\n        );\n\n        const string = internals.stringify(rendered, value, state, prefs, local, options);\n\n        if (string !== undefined) {\n          const result = part.raw || (options.errors && options.errors.escapeHtml) === false ? string : EscapeHtml(string);\n          parts.push(internals.wrap(result, part.wrapped && prefs.errors.wrap.label));\n        }\n      }\n    }\n\n    return parts.join('');\n  }\n\n  _ref(content, {\n    raw,\n    wrapped\n  }) {\n    const refs = [];\n\n    const reference = variable => {\n      const ref = Ref.create(variable, this._settings);\n      refs.push(ref);\n      return context => ref.resolve(...context);\n    };\n\n    try {\n      var formula = new Formula.Parser(content, {\n        reference,\n        functions: internals.functions,\n        constants: internals.constants\n      });\n    } catch (err) {\n      err.message = `Invalid template variable \"${content}\" fails due to: ${err.message}`;\n      throw err;\n    }\n\n    if (formula.single) {\n      if (formula.single.type === 'reference') {\n        const ref = refs[0];\n        return {\n          ref,\n          raw,\n          refs,\n          wrapped: wrapped || ref.type === 'local' && ref.key === 'label'\n        };\n      }\n\n      return internals.stringify(formula.single.value);\n    }\n\n    return {\n      formula,\n      raw,\n      refs\n    };\n  }\n\n  toString() {\n    return this.source;\n  }\n\n};\ninternals.Template.prototype[Common.symbols.template] = true;\ninternals.Template.prototype.isImmutable = true; // Prevents Hoek from deep cloning schema objects\n\ninternals.encode = function (string) {\n  return string.replace(/\\\\(\\{+)/g, ($0, $1) => {\n    return internals.opens.slice(0, $1.length);\n  }).replace(/\\\\(\\}+)/g, ($0, $1) => {\n    return internals.closes.slice(0, $1.length);\n  });\n};\n\ninternals.decode = function (string) {\n  return string.replace(/\\u0000/g, '{').replace(/\\u0001/g, '}');\n};\n\ninternals.split = function (string) {\n  const parts = [];\n  let current = '';\n\n  for (let i = 0; i < string.length; ++i) {\n    const char = string[i];\n\n    if (char === '{') {\n      let next = '';\n\n      while (i + 1 < string.length && string[i + 1] === '{') {\n        next += '{';\n        ++i;\n      }\n\n      parts.push(current);\n      current = next;\n    } else {\n      current += char;\n    }\n  }\n\n  parts.push(current);\n  return parts;\n};\n\ninternals.wrap = function (value, ends) {\n  if (!ends) {\n    return value;\n  }\n\n  if (ends.length === 1) {\n    return `${ends}${value}${ends}`;\n  }\n\n  return `${ends[0]}${value}${ends[1]}`;\n};\n\ninternals.stringify = function (value, original, state, prefs, local, options) {\n  const type = typeof value;\n  let skipWrap = false;\n\n  if (Ref.isRef(value) && value.render) {\n    skipWrap = value.in;\n    value = value.resolve(original, state, prefs, local, {\n      in: value.in,\n      ...options\n    });\n  }\n\n  if (value === null) {\n    return 'null';\n  }\n\n  if (type === 'string') {\n    return value;\n  }\n\n  if (type === 'number' || type === 'function' || type === 'symbol') {\n    return value.toString();\n  }\n\n  if (type !== 'object') {\n    return JSON.stringify(value);\n  }\n\n  if (value instanceof Date) {\n    return internals.Template.date(value, prefs);\n  }\n\n  if (value instanceof Map) {\n    const pairs = [];\n\n    for (const [key, sym] of value.entries()) {\n      pairs.push(`${key.toString()} -> ${sym.toString()}`);\n    }\n\n    value = pairs;\n  }\n\n  if (!Array.isArray(value)) {\n    return value.toString();\n  }\n\n  let partial = '';\n\n  for (const item of value) {\n    partial = partial + (partial.length ? ', ' : '') + internals.stringify(item, original, state, prefs, local, options);\n  }\n\n  if (skipWrap) {\n    return partial;\n  }\n\n  return internals.wrap(partial, prefs.errors.wrap.array);\n};\n\ninternals.constants = {\n  true: true,\n  false: false,\n  null: null,\n  second: 1000,\n  minute: 60 * 1000,\n  hour: 60 * 60 * 1000,\n  day: 24 * 60 * 60 * 1000\n};\ninternals.functions = {\n  if(condition, then, otherwise) {\n    return condition ? then : otherwise;\n  },\n\n  msg(code) {\n    const [value, state, prefs, local, options] = this;\n    const messages = options.messages;\n\n    if (!messages) {\n      return '';\n    }\n\n    const template = Errors.template(value, messages[0], code, state, prefs) || Errors.template(value, messages[1], code, state, prefs);\n\n    if (!template) {\n      return '';\n    }\n\n    return template.render(value, state, prefs, local, options);\n  },\n\n  number(value) {\n    if (typeof value === 'number') {\n      return value;\n    }\n\n    if (typeof value === 'string') {\n      return parseFloat(value);\n    }\n\n    if (typeof value === 'boolean') {\n      return value ? 1 : 0;\n    }\n\n    if (value instanceof Date) {\n      return value.getTime();\n    }\n\n    return null;\n  }\n\n};","map":{"version":3,"sources":["C:/scripting/jobs assignments/whist/backend/node_modules/joi/lib/template.js"],"names":["Assert","require","Clone","EscapeHtml","Formula","Common","Errors","Ref","internals","symbol","Symbol","opens","Array","join","closes","dateFormat","date","Date","prototype","toDateString","iso","toISOString","string","toString","time","toTimeString","utc","toUTCString","module","exports","Template","constructor","source","options","includes","rendered","_template","_settings","_parse","encoded","encode","parts","split","refs","processed","head","shift","push","part","raw","ender","end","indexOf","decode","variable","slice","wrapped","dynamic","_ref","rest","length","prefs","call","describe","compact","desc","template","build","isDynamic","isTemplate","symbols","resolve","value","state","local","_part","render","args","ref","formula","evaluate","stringify","undefined","result","errors","escapeHtml","wrap","label","content","reference","create","context","Parser","functions","constants","err","message","single","type","key","isImmutable","replace","$0","$1","current","i","char","next","ends","original","skipWrap","isRef","in","JSON","Map","pairs","sym","entries","isArray","partial","item","array","true","false","null","second","minute","hour","day","if","condition","then","otherwise","msg","code","messages","number","parseFloat","getTime"],"mappings":"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","sourcesContent":["'use strict';\n\nconst Assert = require('@hapi/hoek/lib/assert');\nconst Clone = require('@hapi/hoek/lib/clone');\nconst EscapeHtml = require('@hapi/hoek/lib/escapeHtml');\nconst Formula = require('@sideway/formula');\n\nconst Common = require('./common');\nconst Errors = require('./errors');\nconst Ref = require('./ref');\n\n\nconst internals = {\n    symbol: Symbol('template'),\n\n    opens: new Array(1000).join('\\u0000'),\n    closes: new Array(1000).join('\\u0001'),\n\n    dateFormat: {\n        date: Date.prototype.toDateString,\n        iso: Date.prototype.toISOString,\n        string: Date.prototype.toString,\n        time: Date.prototype.toTimeString,\n        utc: Date.prototype.toUTCString\n    }\n};\n\n\nmodule.exports = exports = internals.Template = class {\n\n    constructor(source, options) {\n\n        Assert(typeof source === 'string', 'Template source must be a string');\n        Assert(!source.includes('\\u0000') && !source.includes('\\u0001'), 'Template source cannot contain reserved control characters');\n\n        this.source = source;\n        this.rendered = source;\n\n        this._template = null;\n        this._settings = Clone(options);\n\n        this._parse();\n    }\n\n    _parse() {\n\n        // 'text {raw} {{ref}} \\\\{{ignore}} {{ignore\\\\}} {{ignore {{ignore}'\n\n        if (!this.source.includes('{')) {\n            return;\n        }\n\n        // Encode escaped \\\\{{{{{\n\n        const encoded = internals.encode(this.source);\n\n        // Split on first { in each set\n\n        const parts = internals.split(encoded);\n\n        // Process parts\n\n        let refs = false;\n        const processed = [];\n        const head = parts.shift();\n        if (head) {\n            processed.push(head);\n        }\n\n        for (const part of parts) {\n            const raw = part[0] !== '{';\n            const ender = raw ? '}' : '}}';\n            const end = part.indexOf(ender);\n            if (end === -1 ||                               // Ignore non-matching closing\n                part[1] === '{') {                          // Ignore more than two {\n\n                processed.push(`{${internals.decode(part)}`);\n                continue;\n            }\n\n            let variable = part.slice(raw ? 0 : 1, end);\n            const wrapped = variable[0] === ':';\n            if (wrapped) {\n                variable = variable.slice(1);\n            }\n\n            const dynamic = this._ref(internals.decode(variable), { raw, wrapped });\n            processed.push(dynamic);\n            if (typeof dynamic !== 'string') {\n                refs = true;\n            }\n\n            const rest = part.slice(end + ender.length);\n            if (rest) {\n                processed.push(internals.decode(rest));\n            }\n        }\n\n        if (!refs) {\n            this.rendered = processed.join('');\n            return;\n        }\n\n        this._template = processed;\n    }\n\n    static date(date, prefs) {\n\n        return internals.dateFormat[prefs.dateFormat].call(date);\n    }\n\n    describe(options = {}) {\n\n        if (!this._settings &&\n            options.compact) {\n\n            return this.source;\n        }\n\n        const desc = { template: this.source };\n        if (this._settings) {\n            desc.options = this._settings;\n        }\n\n        return desc;\n    }\n\n    static build(desc) {\n\n        return new internals.Template(desc.template, desc.options);\n    }\n\n    isDynamic() {\n\n        return !!this._template;\n    }\n\n    static isTemplate(template) {\n\n        return template ? !!template[Common.symbols.template] : false;\n    }\n\n    refs() {\n\n        if (!this._template) {\n            return;\n        }\n\n        const refs = [];\n        for (const part of this._template) {\n            if (typeof part !== 'string') {\n                refs.push(...part.refs);\n            }\n        }\n\n        return refs;\n    }\n\n    resolve(value, state, prefs, local) {\n\n        if (this._template &&\n            this._template.length === 1) {\n\n            return this._part(this._template[0], /* context -> [*/ value, state, prefs, local, {} /*] */);\n        }\n\n        return this.render(value, state, prefs, local);\n    }\n\n    _part(part, ...args) {\n\n        if (part.ref) {\n            return part.ref.resolve(...args);\n        }\n\n        return part.formula.evaluate(args);\n    }\n\n    render(value, state, prefs, local, options = {}) {\n\n        if (!this.isDynamic()) {\n            return this.rendered;\n        }\n\n        const parts = [];\n        for (const part of this._template) {\n            if (typeof part === 'string') {\n                parts.push(part);\n            }\n            else {\n                const rendered = this._part(part, /* context -> [*/ value, state, prefs, local, options /*] */);\n                const string = internals.stringify(rendered, value, state, prefs, local, options);\n                if (string !== undefined) {\n                    const result = part.raw || (options.errors && options.errors.escapeHtml) === false ? string : EscapeHtml(string);\n                    parts.push(internals.wrap(result, part.wrapped && prefs.errors.wrap.label));\n                }\n            }\n        }\n\n        return parts.join('');\n    }\n\n    _ref(content, { raw, wrapped }) {\n\n        const refs = [];\n        const reference = (variable) => {\n\n            const ref = Ref.create(variable, this._settings);\n            refs.push(ref);\n            return (context) => ref.resolve(...context);\n        };\n\n        try {\n            var formula = new Formula.Parser(content, { reference, functions: internals.functions, constants: internals.constants });\n        }\n        catch (err) {\n            err.message = `Invalid template variable \"${content}\" fails due to: ${err.message}`;\n            throw err;\n        }\n\n        if (formula.single) {\n            if (formula.single.type === 'reference') {\n                const ref = refs[0];\n                return { ref, raw, refs, wrapped: wrapped || ref.type === 'local' && ref.key === 'label' };\n            }\n\n            return internals.stringify(formula.single.value);\n        }\n\n        return { formula, raw, refs };\n    }\n\n    toString() {\n\n        return this.source;\n    }\n};\n\n\ninternals.Template.prototype[Common.symbols.template] = true;\ninternals.Template.prototype.isImmutable = true;                // Prevents Hoek from deep cloning schema objects\n\n\ninternals.encode = function (string) {\n\n    return string\n        .replace(/\\\\(\\{+)/g, ($0, $1) => {\n\n            return internals.opens.slice(0, $1.length);\n        })\n        .replace(/\\\\(\\}+)/g, ($0, $1) => {\n\n            return internals.closes.slice(0, $1.length);\n        });\n};\n\n\ninternals.decode = function (string) {\n\n    return string\n        .replace(/\\u0000/g, '{')\n        .replace(/\\u0001/g, '}');\n};\n\n\ninternals.split = function (string) {\n\n    const parts = [];\n    let current = '';\n\n    for (let i = 0; i < string.length; ++i) {\n        const char = string[i];\n\n        if (char === '{') {\n            let next = '';\n            while (i + 1 < string.length &&\n                string[i + 1] === '{') {\n\n                next += '{';\n                ++i;\n            }\n\n            parts.push(current);\n            current = next;\n        }\n        else {\n            current += char;\n        }\n    }\n\n    parts.push(current);\n    return parts;\n};\n\n\ninternals.wrap = function (value, ends) {\n\n    if (!ends) {\n        return value;\n    }\n\n    if (ends.length === 1) {\n        return `${ends}${value}${ends}`;\n    }\n\n    return `${ends[0]}${value}${ends[1]}`;\n};\n\n\ninternals.stringify = function (value, original, state, prefs, local, options) {\n\n    const type = typeof value;\n\n    let skipWrap = false;\n    if (Ref.isRef(value) &&\n        value.render) {\n\n        skipWrap = value.in;\n        value = value.resolve(original, state, prefs, local, { in: value.in, ...options });\n    }\n\n    if (value === null) {\n        return 'null';\n    }\n\n    if (type === 'string') {\n        return value;\n    }\n\n    if (type === 'number' ||\n        type === 'function' ||\n        type === 'symbol') {\n\n        return value.toString();\n    }\n\n    if (type !== 'object') {\n        return JSON.stringify(value);\n    }\n\n    if (value instanceof Date) {\n        return internals.Template.date(value, prefs);\n    }\n\n    if (value instanceof Map) {\n        const pairs = [];\n        for (const [key, sym] of value.entries()) {\n            pairs.push(`${key.toString()} -> ${sym.toString()}`);\n        }\n\n        value = pairs;\n    }\n\n    if (!Array.isArray(value)) {\n        return value.toString();\n    }\n\n    let partial = '';\n    for (const item of value) {\n        partial = partial + (partial.length ? ', ' : '') + internals.stringify(item, original, state, prefs, local, options);\n    }\n\n    if (skipWrap) {\n        return partial;\n    }\n\n    return internals.wrap(partial, prefs.errors.wrap.array);\n};\n\n\ninternals.constants = {\n\n    true: true,\n    false: false,\n    null: null,\n\n    second: 1000,\n    minute: 60 * 1000,\n    hour: 60 * 60 * 1000,\n    day: 24 * 60 * 60 * 1000\n};\n\n\ninternals.functions = {\n\n    if(condition, then, otherwise) {\n\n        return condition ? then : otherwise;\n    },\n\n    msg(code) {\n\n        const [value, state, prefs, local, options] = this;\n        const messages = options.messages;\n        if (!messages) {\n            return '';\n        }\n\n        const template = Errors.template(value, messages[0], code, state, prefs) || Errors.template(value, messages[1], code, state, prefs);\n        if (!template) {\n            return '';\n        }\n\n        return template.render(value, state, prefs, local, options);\n    },\n\n    number(value) {\n\n        if (typeof value === 'number') {\n            return value;\n        }\n\n        if (typeof value === 'string') {\n            return parseFloat(value);\n        }\n\n        if (typeof value === 'boolean') {\n            return value ? 1 : 0;\n        }\n\n        if (value instanceof Date) {\n            return value.getTime();\n        }\n\n        return null;\n    }\n};\n"]},"metadata":{},"sourceType":"script"}