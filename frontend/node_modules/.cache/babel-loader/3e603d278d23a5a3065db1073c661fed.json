{"ast":null,"code":"'use strict';\n\nconst Assert = require('@hapi/hoek/lib/assert');\n\nconst Clone = require('@hapi/hoek/lib/clone');\n\nconst Common = require('./common');\n\nconst internals = {\n  max: 1000,\n  supported: new Set(['undefined', 'boolean', 'number', 'string'])\n};\nexports.provider = {\n  provision(options) {\n    return new internals.Cache(options);\n  }\n\n}; // Least Recently Used (LRU) Cache\n\ninternals.Cache = class {\n  constructor(options = {}) {\n    Common.assertOptions(options, ['max']);\n    Assert(options.max === undefined || options.max && options.max > 0 && isFinite(options.max), 'Invalid max cache size');\n    this._max = options.max || internals.max;\n    this._map = new Map(); // Map of nodes by key\n\n    this._list = new internals.List(); // List of nodes (most recently used in head)\n  }\n\n  get length() {\n    return this._map.size;\n  }\n\n  set(key, value) {\n    if (key !== null && !internals.supported.has(typeof key)) {\n      return;\n    }\n\n    let node = this._map.get(key);\n\n    if (node) {\n      node.value = value;\n\n      this._list.first(node);\n\n      return;\n    }\n\n    node = this._list.unshift({\n      key,\n      value\n    });\n\n    this._map.set(key, node);\n\n    this._compact();\n  }\n\n  get(key) {\n    const node = this._map.get(key);\n\n    if (node) {\n      this._list.first(node);\n\n      return Clone(node.value);\n    }\n  }\n\n  _compact() {\n    if (this._map.size > this._max) {\n      const node = this._list.pop();\n\n      this._map.delete(node.key);\n    }\n  }\n\n};\ninternals.List = class {\n  constructor() {\n    this.tail = null;\n    this.head = null;\n  }\n\n  unshift(node) {\n    node.next = null;\n    node.prev = this.head;\n\n    if (this.head) {\n      this.head.next = node;\n    }\n\n    this.head = node;\n\n    if (!this.tail) {\n      this.tail = node;\n    }\n\n    return node;\n  }\n\n  first(node) {\n    if (node === this.head) {\n      return;\n    }\n\n    this._remove(node);\n\n    this.unshift(node);\n  }\n\n  pop() {\n    return this._remove(this.tail);\n  }\n\n  _remove(node) {\n    const {\n      next,\n      prev\n    } = node;\n    next.prev = prev;\n\n    if (prev) {\n      prev.next = next;\n    }\n\n    if (node === this.tail) {\n      this.tail = next;\n    }\n\n    node.prev = null;\n    node.next = null;\n    return node;\n  }\n\n};","map":{"version":3,"sources":["C:/scripting/jobs assignments/whist/backend/node_modules/joi/lib/cache.js"],"names":["Assert","require","Clone","Common","internals","max","supported","Set","exports","provider","provision","options","Cache","constructor","assertOptions","undefined","isFinite","_max","_map","Map","_list","List","length","size","set","key","value","has","node","get","first","unshift","_compact","pop","delete","tail","head","next","prev","_remove"],"mappings":"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","sourcesContent":["'use strict';\n\nconst Assert = require('@hapi/hoek/lib/assert');\nconst Clone = require('@hapi/hoek/lib/clone');\n\nconst Common = require('./common');\n\n\nconst internals = {\n    max: 1000,\n    supported: new Set(['undefined', 'boolean', 'number', 'string'])\n};\n\n\nexports.provider = {\n\n    provision(options) {\n\n        return new internals.Cache(options);\n    }\n};\n\n\n// Least Recently Used (LRU) Cache\n\ninternals.Cache = class {\n\n    constructor(options = {}) {\n\n        Common.assertOptions(options, ['max']);\n        Assert(options.max === undefined || options.max && options.max > 0 && isFinite(options.max), 'Invalid max cache size');\n\n        this._max = options.max || internals.max;\n\n        this._map = new Map();                          // Map of nodes by key\n        this._list = new internals.List();              // List of nodes (most recently used in head)\n    }\n\n    get length() {\n\n        return this._map.size;\n    }\n\n    set(key, value) {\n\n        if (key !== null &&\n            !internals.supported.has(typeof key)) {\n\n            return;\n        }\n\n        let node = this._map.get(key);\n        if (node) {\n            node.value = value;\n            this._list.first(node);\n            return;\n        }\n\n        node = this._list.unshift({ key, value });\n        this._map.set(key, node);\n        this._compact();\n    }\n\n    get(key) {\n\n        const node = this._map.get(key);\n        if (node) {\n            this._list.first(node);\n            return Clone(node.value);\n        }\n    }\n\n    _compact() {\n\n        if (this._map.size > this._max) {\n            const node = this._list.pop();\n            this._map.delete(node.key);\n        }\n    }\n};\n\n\ninternals.List = class {\n\n    constructor() {\n\n        this.tail = null;\n        this.head = null;\n    }\n\n    unshift(node) {\n\n        node.next = null;\n        node.prev = this.head;\n\n        if (this.head) {\n            this.head.next = node;\n        }\n\n        this.head = node;\n\n        if (!this.tail) {\n            this.tail = node;\n        }\n\n        return node;\n    }\n\n    first(node) {\n\n        if (node === this.head) {\n            return;\n        }\n\n        this._remove(node);\n        this.unshift(node);\n    }\n\n    pop() {\n\n        return this._remove(this.tail);\n    }\n\n    _remove(node) {\n\n        const { next, prev } = node;\n\n        next.prev = prev;\n\n        if (prev) {\n            prev.next = next;\n        }\n\n        if (node === this.tail) {\n            this.tail = next;\n        }\n\n        node.prev = null;\n        node.next = null;\n\n        return node;\n    }\n};\n"]},"metadata":{},"sourceType":"script"}