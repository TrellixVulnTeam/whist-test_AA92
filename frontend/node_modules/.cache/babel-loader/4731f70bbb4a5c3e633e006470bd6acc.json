{"ast":null,"code":"'use strict';\n\nconst Assert = require('@hapi/hoek/lib/assert');\n\nconst Any = require('./any');\n\nconst Common = require('../common');\n\nconst Compile = require('../compile');\n\nconst Errors = require('../errors');\n\nconst internals = {};\nmodule.exports = Any.extend({\n  type: 'link',\n  properties: {\n    schemaChain: true\n  },\n  terms: {\n    link: {\n      init: null,\n      manifest: 'single',\n      register: false\n    }\n  },\n\n  args(schema, ref) {\n    return schema.ref(ref);\n  },\n\n  validate(value, {\n    schema,\n    state,\n    prefs\n  }) {\n    Assert(schema.$_terms.link, 'Uninitialized link schema');\n    const linked = internals.generate(schema, value, state, prefs);\n    const ref = schema.$_terms.link[0].ref;\n    return linked.$_validate(value, state.nest(linked, `link:${ref.display}:${linked.type}`), prefs);\n  },\n\n  generate(schema, value, state, prefs) {\n    return internals.generate(schema, value, state, prefs);\n  },\n\n  rules: {\n    ref: {\n      method(ref) {\n        Assert(!this.$_terms.link, 'Cannot reinitialize schema');\n        ref = Compile.ref(ref);\n        Assert(ref.type === 'value' || ref.type === 'local', 'Invalid reference type:', ref.type);\n        Assert(ref.type === 'local' || ref.ancestor === 'root' || ref.ancestor > 0, 'Link cannot reference itself');\n        const obj = this.clone();\n        obj.$_terms.link = [{\n          ref\n        }];\n        return obj;\n      }\n\n    },\n    relative: {\n      method(enabled = true) {\n        return this.$_setFlag('relative', enabled);\n      }\n\n    }\n  },\n  overrides: {\n    concat(source) {\n      Assert(this.$_terms.link, 'Uninitialized link schema');\n      Assert(Common.isSchema(source), 'Invalid schema object');\n      Assert(source.type !== 'link', 'Cannot merge type link with another link');\n      const obj = this.clone();\n\n      if (!obj.$_terms.whens) {\n        obj.$_terms.whens = [];\n      }\n\n      obj.$_terms.whens.push({\n        concat: source\n      });\n      return obj.$_mutateRebuild();\n    }\n\n  },\n  manifest: {\n    build(obj, desc) {\n      Assert(desc.link, 'Invalid link description missing link');\n      return obj.ref(desc.link);\n    }\n\n  }\n}); // Helpers\n\ninternals.generate = function (schema, value, state, prefs) {\n  let linked = state.mainstay.links.get(schema);\n\n  if (linked) {\n    return linked._generate(value, state, prefs).schema;\n  }\n\n  const ref = schema.$_terms.link[0].ref;\n  const {\n    perspective,\n    path\n  } = internals.perspective(ref, state);\n  internals.assert(perspective, 'which is outside of schema boundaries', ref, schema, state, prefs);\n\n  try {\n    linked = path.length ? perspective.$_reach(path) : perspective;\n  } catch (ignoreErr) {\n    internals.assert(false, 'to non-existing schema', ref, schema, state, prefs);\n  }\n\n  internals.assert(linked.type !== 'link', 'which is another link', ref, schema, state, prefs);\n\n  if (!schema._flags.relative) {\n    state.mainstay.links.set(schema, linked);\n  }\n\n  return linked._generate(value, state, prefs).schema;\n};\n\ninternals.perspective = function (ref, state) {\n  if (ref.type === 'local') {\n    for (const {\n      schema,\n      key\n    } of state.schemas) {\n      // From parent to root\n      const id = schema._flags.id || key;\n\n      if (id === ref.path[0]) {\n        return {\n          perspective: schema,\n          path: ref.path.slice(1)\n        };\n      }\n\n      if (schema.$_terms.shared) {\n        for (const shared of schema.$_terms.shared) {\n          if (shared._flags.id === ref.path[0]) {\n            return {\n              perspective: shared,\n              path: ref.path.slice(1)\n            };\n          }\n        }\n      }\n    }\n\n    return {\n      perspective: null,\n      path: null\n    };\n  }\n\n  if (ref.ancestor === 'root') {\n    return {\n      perspective: state.schemas[state.schemas.length - 1].schema,\n      path: ref.path\n    };\n  }\n\n  return {\n    perspective: state.schemas[ref.ancestor] && state.schemas[ref.ancestor].schema,\n    path: ref.path\n  };\n};\n\ninternals.assert = function (condition, message, ref, schema, state, prefs) {\n  if (condition) {\n    // Manual check to avoid generating error message on success\n    return;\n  }\n\n  Assert(false, `\"${Errors.label(schema._flags, state, prefs)}\" contains link reference \"${ref.display}\" ${message}`);\n};","map":{"version":3,"sources":["C:/scripting/jobs assignments/whist/backend/node_modules/joi/lib/types/link.js"],"names":["Assert","require","Any","Common","Compile","Errors","internals","module","exports","extend","type","properties","schemaChain","terms","link","init","manifest","register","args","schema","ref","validate","value","state","prefs","$_terms","linked","generate","$_validate","nest","display","rules","method","ancestor","obj","clone","relative","enabled","$_setFlag","overrides","concat","source","isSchema","whens","push","$_mutateRebuild","build","desc","mainstay","links","get","_generate","perspective","path","assert","length","$_reach","ignoreErr","_flags","set","key","schemas","id","slice","shared","condition","message","label"],"mappings":"AAAA;;AAEA,MAAMA,MAAM,GAAGC,OAAO,CAAC,uBAAD,CAAtB;;AAEA,MAAMC,GAAG,GAAGD,OAAO,CAAC,OAAD,CAAnB;;AACA,MAAME,MAAM,GAAGF,OAAO,CAAC,WAAD,CAAtB;;AACA,MAAMG,OAAO,GAAGH,OAAO,CAAC,YAAD,CAAvB;;AACA,MAAMI,MAAM,GAAGJ,OAAO,CAAC,WAAD,CAAtB;;AAGA,MAAMK,SAAS,GAAG,EAAlB;AAGAC,MAAM,CAACC,OAAP,GAAiBN,GAAG,CAACO,MAAJ,CAAW;AAExBC,EAAAA,IAAI,EAAE,MAFkB;AAIxBC,EAAAA,UAAU,EAAE;AACRC,IAAAA,WAAW,EAAE;AADL,GAJY;AAQxBC,EAAAA,KAAK,EAAE;AAEHC,IAAAA,IAAI,EAAE;AAAEC,MAAAA,IAAI,EAAE,IAAR;AAAcC,MAAAA,QAAQ,EAAE,QAAxB;AAAkCC,MAAAA,QAAQ,EAAE;AAA5C;AAFH,GARiB;;AAaxBC,EAAAA,IAAI,CAACC,MAAD,EAASC,GAAT,EAAc;AAEd,WAAOD,MAAM,CAACC,GAAP,CAAWA,GAAX,CAAP;AACH,GAhBuB;;AAkBxBC,EAAAA,QAAQ,CAACC,KAAD,EAAQ;AAAEH,IAAAA,MAAF;AAAUI,IAAAA,KAAV;AAAiBC,IAAAA;AAAjB,GAAR,EAAkC;AAEtCxB,IAAAA,MAAM,CAACmB,MAAM,CAACM,OAAP,CAAeX,IAAhB,EAAsB,2BAAtB,CAAN;AAEA,UAAMY,MAAM,GAAGpB,SAAS,CAACqB,QAAV,CAAmBR,MAAnB,EAA2BG,KAA3B,EAAkCC,KAAlC,EAAyCC,KAAzC,CAAf;AACA,UAAMJ,GAAG,GAAGD,MAAM,CAACM,OAAP,CAAeX,IAAf,CAAoB,CAApB,EAAuBM,GAAnC;AACA,WAAOM,MAAM,CAACE,UAAP,CAAkBN,KAAlB,EAAyBC,KAAK,CAACM,IAAN,CAAWH,MAAX,EAAoB,QAAON,GAAG,CAACU,OAAQ,IAAGJ,MAAM,CAAChB,IAAK,EAAtD,CAAzB,EAAmFc,KAAnF,CAAP;AACH,GAzBuB;;AA2BxBG,EAAAA,QAAQ,CAACR,MAAD,EAASG,KAAT,EAAgBC,KAAhB,EAAuBC,KAAvB,EAA8B;AAElC,WAAOlB,SAAS,CAACqB,QAAV,CAAmBR,MAAnB,EAA2BG,KAA3B,EAAkCC,KAAlC,EAAyCC,KAAzC,CAAP;AACH,GA9BuB;;AAgCxBO,EAAAA,KAAK,EAAE;AAEHX,IAAAA,GAAG,EAAE;AACDY,MAAAA,MAAM,CAACZ,GAAD,EAAM;AAERpB,QAAAA,MAAM,CAAC,CAAC,KAAKyB,OAAL,CAAaX,IAAf,EAAqB,4BAArB,CAAN;AAEAM,QAAAA,GAAG,GAAGhB,OAAO,CAACgB,GAAR,CAAYA,GAAZ,CAAN;AAEApB,QAAAA,MAAM,CAACoB,GAAG,CAACV,IAAJ,KAAa,OAAb,IAAwBU,GAAG,CAACV,IAAJ,KAAa,OAAtC,EAA+C,yBAA/C,EAA0EU,GAAG,CAACV,IAA9E,CAAN;AACAV,QAAAA,MAAM,CAACoB,GAAG,CAACV,IAAJ,KAAa,OAAb,IAAwBU,GAAG,CAACa,QAAJ,KAAiB,MAAzC,IAAmDb,GAAG,CAACa,QAAJ,GAAe,CAAnE,EAAsE,8BAAtE,CAAN;AAEA,cAAMC,GAAG,GAAG,KAAKC,KAAL,EAAZ;AACAD,QAAAA,GAAG,CAACT,OAAJ,CAAYX,IAAZ,GAAmB,CAAC;AAAEM,UAAAA;AAAF,SAAD,CAAnB;AACA,eAAOc,GAAP;AACH;;AAbA,KAFF;AAkBHE,IAAAA,QAAQ,EAAE;AACNJ,MAAAA,MAAM,CAACK,OAAO,GAAG,IAAX,EAAiB;AAEnB,eAAO,KAAKC,SAAL,CAAe,UAAf,EAA2BD,OAA3B,CAAP;AACH;;AAJK;AAlBP,GAhCiB;AA0DxBE,EAAAA,SAAS,EAAE;AAEPC,IAAAA,MAAM,CAACC,MAAD,EAAS;AAEXzC,MAAAA,MAAM,CAAC,KAAKyB,OAAL,CAAaX,IAAd,EAAoB,2BAApB,CAAN;AACAd,MAAAA,MAAM,CAACG,MAAM,CAACuC,QAAP,CAAgBD,MAAhB,CAAD,EAA0B,uBAA1B,CAAN;AACAzC,MAAAA,MAAM,CAACyC,MAAM,CAAC/B,IAAP,KAAgB,MAAjB,EAAyB,0CAAzB,CAAN;AAEA,YAAMwB,GAAG,GAAG,KAAKC,KAAL,EAAZ;;AAEA,UAAI,CAACD,GAAG,CAACT,OAAJ,CAAYkB,KAAjB,EAAwB;AACpBT,QAAAA,GAAG,CAACT,OAAJ,CAAYkB,KAAZ,GAAoB,EAApB;AACH;;AAEDT,MAAAA,GAAG,CAACT,OAAJ,CAAYkB,KAAZ,CAAkBC,IAAlB,CAAuB;AAAEJ,QAAAA,MAAM,EAAEC;AAAV,OAAvB;AACA,aAAOP,GAAG,CAACW,eAAJ,EAAP;AACH;;AAhBM,GA1Da;AA6ExB7B,EAAAA,QAAQ,EAAE;AAEN8B,IAAAA,KAAK,CAACZ,GAAD,EAAMa,IAAN,EAAY;AAEb/C,MAAAA,MAAM,CAAC+C,IAAI,CAACjC,IAAN,EAAY,uCAAZ,CAAN;AACA,aAAOoB,GAAG,CAACd,GAAJ,CAAQ2B,IAAI,CAACjC,IAAb,CAAP;AACH;;AANK;AA7Ec,CAAX,CAAjB,C,CAwFA;;AAEAR,SAAS,CAACqB,QAAV,GAAqB,UAAUR,MAAV,EAAkBG,KAAlB,EAAyBC,KAAzB,EAAgCC,KAAhC,EAAuC;AAExD,MAAIE,MAAM,GAAGH,KAAK,CAACyB,QAAN,CAAeC,KAAf,CAAqBC,GAArB,CAAyB/B,MAAzB,CAAb;;AACA,MAAIO,MAAJ,EAAY;AACR,WAAOA,MAAM,CAACyB,SAAP,CAAiB7B,KAAjB,EAAwBC,KAAxB,EAA+BC,KAA/B,EAAsCL,MAA7C;AACH;;AAED,QAAMC,GAAG,GAAGD,MAAM,CAACM,OAAP,CAAeX,IAAf,CAAoB,CAApB,EAAuBM,GAAnC;AACA,QAAM;AAAEgC,IAAAA,WAAF;AAAeC,IAAAA;AAAf,MAAwB/C,SAAS,CAAC8C,WAAV,CAAsBhC,GAAtB,EAA2BG,KAA3B,CAA9B;AACAjB,EAAAA,SAAS,CAACgD,MAAV,CAAiBF,WAAjB,EAA8B,uCAA9B,EAAuEhC,GAAvE,EAA4ED,MAA5E,EAAoFI,KAApF,EAA2FC,KAA3F;;AAEA,MAAI;AACAE,IAAAA,MAAM,GAAG2B,IAAI,CAACE,MAAL,GAAcH,WAAW,CAACI,OAAZ,CAAoBH,IAApB,CAAd,GAA0CD,WAAnD;AACH,GAFD,CAGA,OAAOK,SAAP,EAAkB;AACdnD,IAAAA,SAAS,CAACgD,MAAV,CAAiB,KAAjB,EAAwB,wBAAxB,EAAkDlC,GAAlD,EAAuDD,MAAvD,EAA+DI,KAA/D,EAAsEC,KAAtE;AACH;;AAEDlB,EAAAA,SAAS,CAACgD,MAAV,CAAiB5B,MAAM,CAAChB,IAAP,KAAgB,MAAjC,EAAyC,uBAAzC,EAAkEU,GAAlE,EAAuED,MAAvE,EAA+EI,KAA/E,EAAsFC,KAAtF;;AAEA,MAAI,CAACL,MAAM,CAACuC,MAAP,CAActB,QAAnB,EAA6B;AACzBb,IAAAA,KAAK,CAACyB,QAAN,CAAeC,KAAf,CAAqBU,GAArB,CAAyBxC,MAAzB,EAAiCO,MAAjC;AACH;;AAED,SAAOA,MAAM,CAACyB,SAAP,CAAiB7B,KAAjB,EAAwBC,KAAxB,EAA+BC,KAA/B,EAAsCL,MAA7C;AACH,CAzBD;;AA4BAb,SAAS,CAAC8C,WAAV,GAAwB,UAAUhC,GAAV,EAAeG,KAAf,EAAsB;AAE1C,MAAIH,GAAG,CAACV,IAAJ,KAAa,OAAjB,EAA0B;AACtB,SAAK,MAAM;AAAES,MAAAA,MAAF;AAAUyC,MAAAA;AAAV,KAAX,IAA8BrC,KAAK,CAACsC,OAApC,EAA6C;AAA+B;AACxE,YAAMC,EAAE,GAAG3C,MAAM,CAACuC,MAAP,CAAcI,EAAd,IAAoBF,GAA/B;;AACA,UAAIE,EAAE,KAAK1C,GAAG,CAACiC,IAAJ,CAAS,CAAT,CAAX,EAAwB;AACpB,eAAO;AAAED,UAAAA,WAAW,EAAEjC,MAAf;AAAuBkC,UAAAA,IAAI,EAAEjC,GAAG,CAACiC,IAAJ,CAASU,KAAT,CAAe,CAAf;AAA7B,SAAP;AACH;;AAED,UAAI5C,MAAM,CAACM,OAAP,CAAeuC,MAAnB,EAA2B;AACvB,aAAK,MAAMA,MAAX,IAAqB7C,MAAM,CAACM,OAAP,CAAeuC,MAApC,EAA4C;AACxC,cAAIA,MAAM,CAACN,MAAP,CAAcI,EAAd,KAAqB1C,GAAG,CAACiC,IAAJ,CAAS,CAAT,CAAzB,EAAsC;AAClC,mBAAO;AAAED,cAAAA,WAAW,EAAEY,MAAf;AAAuBX,cAAAA,IAAI,EAAEjC,GAAG,CAACiC,IAAJ,CAASU,KAAT,CAAe,CAAf;AAA7B,aAAP;AACH;AACJ;AACJ;AACJ;;AAED,WAAO;AAAEX,MAAAA,WAAW,EAAE,IAAf;AAAqBC,MAAAA,IAAI,EAAE;AAA3B,KAAP;AACH;;AAED,MAAIjC,GAAG,CAACa,QAAJ,KAAiB,MAArB,EAA6B;AACzB,WAAO;AAAEmB,MAAAA,WAAW,EAAE7B,KAAK,CAACsC,OAAN,CAActC,KAAK,CAACsC,OAAN,CAAcN,MAAd,GAAuB,CAArC,EAAwCpC,MAAvD;AAA+DkC,MAAAA,IAAI,EAAEjC,GAAG,CAACiC;AAAzE,KAAP;AACH;;AAED,SAAO;AAAED,IAAAA,WAAW,EAAE7B,KAAK,CAACsC,OAAN,CAAczC,GAAG,CAACa,QAAlB,KAA+BV,KAAK,CAACsC,OAAN,CAAczC,GAAG,CAACa,QAAlB,EAA4Bd,MAA1E;AAAkFkC,IAAAA,IAAI,EAAEjC,GAAG,CAACiC;AAA5F,GAAP;AACH,CA1BD;;AA6BA/C,SAAS,CAACgD,MAAV,GAAmB,UAAUW,SAAV,EAAqBC,OAArB,EAA8B9C,GAA9B,EAAmCD,MAAnC,EAA2CI,KAA3C,EAAkDC,KAAlD,EAAyD;AAExE,MAAIyC,SAAJ,EAAe;AAAiB;AAC5B;AACH;;AAEDjE,EAAAA,MAAM,CAAC,KAAD,EAAS,IAAGK,MAAM,CAAC8D,KAAP,CAAahD,MAAM,CAACuC,MAApB,EAA4BnC,KAA5B,EAAmCC,KAAnC,CAA0C,8BAA6BJ,GAAG,CAACU,OAAQ,KAAIoC,OAAQ,EAA3G,CAAN;AACH,CAPD","sourcesContent":["'use strict';\n\nconst Assert = require('@hapi/hoek/lib/assert');\n\nconst Any = require('./any');\nconst Common = require('../common');\nconst Compile = require('../compile');\nconst Errors = require('../errors');\n\n\nconst internals = {};\n\n\nmodule.exports = Any.extend({\n\n    type: 'link',\n\n    properties: {\n        schemaChain: true\n    },\n\n    terms: {\n\n        link: { init: null, manifest: 'single', register: false }\n    },\n\n    args(schema, ref) {\n\n        return schema.ref(ref);\n    },\n\n    validate(value, { schema, state, prefs }) {\n\n        Assert(schema.$_terms.link, 'Uninitialized link schema');\n\n        const linked = internals.generate(schema, value, state, prefs);\n        const ref = schema.$_terms.link[0].ref;\n        return linked.$_validate(value, state.nest(linked, `link:${ref.display}:${linked.type}`), prefs);\n    },\n\n    generate(schema, value, state, prefs) {\n\n        return internals.generate(schema, value, state, prefs);\n    },\n\n    rules: {\n\n        ref: {\n            method(ref) {\n\n                Assert(!this.$_terms.link, 'Cannot reinitialize schema');\n\n                ref = Compile.ref(ref);\n\n                Assert(ref.type === 'value' || ref.type === 'local', 'Invalid reference type:', ref.type);\n                Assert(ref.type === 'local' || ref.ancestor === 'root' || ref.ancestor > 0, 'Link cannot reference itself');\n\n                const obj = this.clone();\n                obj.$_terms.link = [{ ref }];\n                return obj;\n            }\n        },\n\n        relative: {\n            method(enabled = true) {\n\n                return this.$_setFlag('relative', enabled);\n            }\n        }\n    },\n\n    overrides: {\n\n        concat(source) {\n\n            Assert(this.$_terms.link, 'Uninitialized link schema');\n            Assert(Common.isSchema(source), 'Invalid schema object');\n            Assert(source.type !== 'link', 'Cannot merge type link with another link');\n\n            const obj = this.clone();\n\n            if (!obj.$_terms.whens) {\n                obj.$_terms.whens = [];\n            }\n\n            obj.$_terms.whens.push({ concat: source });\n            return obj.$_mutateRebuild();\n        }\n    },\n\n    manifest: {\n\n        build(obj, desc) {\n\n            Assert(desc.link, 'Invalid link description missing link');\n            return obj.ref(desc.link);\n        }\n    }\n});\n\n\n// Helpers\n\ninternals.generate = function (schema, value, state, prefs) {\n\n    let linked = state.mainstay.links.get(schema);\n    if (linked) {\n        return linked._generate(value, state, prefs).schema;\n    }\n\n    const ref = schema.$_terms.link[0].ref;\n    const { perspective, path } = internals.perspective(ref, state);\n    internals.assert(perspective, 'which is outside of schema boundaries', ref, schema, state, prefs);\n\n    try {\n        linked = path.length ? perspective.$_reach(path) : perspective;\n    }\n    catch (ignoreErr) {\n        internals.assert(false, 'to non-existing schema', ref, schema, state, prefs);\n    }\n\n    internals.assert(linked.type !== 'link', 'which is another link', ref, schema, state, prefs);\n\n    if (!schema._flags.relative) {\n        state.mainstay.links.set(schema, linked);\n    }\n\n    return linked._generate(value, state, prefs).schema;\n};\n\n\ninternals.perspective = function (ref, state) {\n\n    if (ref.type === 'local') {\n        for (const { schema, key } of state.schemas) {                              // From parent to root\n            const id = schema._flags.id || key;\n            if (id === ref.path[0]) {\n                return { perspective: schema, path: ref.path.slice(1) };\n            }\n\n            if (schema.$_terms.shared) {\n                for (const shared of schema.$_terms.shared) {\n                    if (shared._flags.id === ref.path[0]) {\n                        return { perspective: shared, path: ref.path.slice(1) };\n                    }\n                }\n            }\n        }\n\n        return { perspective: null, path: null };\n    }\n\n    if (ref.ancestor === 'root') {\n        return { perspective: state.schemas[state.schemas.length - 1].schema, path: ref.path };\n    }\n\n    return { perspective: state.schemas[ref.ancestor] && state.schemas[ref.ancestor].schema, path: ref.path };\n};\n\n\ninternals.assert = function (condition, message, ref, schema, state, prefs) {\n\n    if (condition) {                // Manual check to avoid generating error message on success\n        return;\n    }\n\n    Assert(false, `\"${Errors.label(schema._flags, state, prefs)}\" contains link reference \"${ref.display}\" ${message}`);\n};\n"]},"metadata":{},"sourceType":"script"}