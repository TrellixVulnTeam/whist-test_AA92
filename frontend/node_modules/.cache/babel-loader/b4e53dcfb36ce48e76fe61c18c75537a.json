{"ast":null,"code":"'use strict';\n\nconst Assert = require('@hapi/hoek/lib/assert');\n\nconst Clone = require('@hapi/hoek/lib/clone');\n\nconst Cache = require('./cache');\n\nconst Common = require('./common');\n\nconst Compile = require('./compile');\n\nconst Errors = require('./errors');\n\nconst Extend = require('./extend');\n\nconst Manifest = require('./manifest');\n\nconst Ref = require('./ref');\n\nconst Template = require('./template');\n\nconst Trace = require('./trace');\n\nlet Schemas;\nconst internals = {\n  types: {\n    alternatives: require('./types/alternatives'),\n    any: require('./types/any'),\n    array: require('./types/array'),\n    boolean: require('./types/boolean'),\n    date: require('./types/date'),\n    function: require('./types/function'),\n    link: require('./types/link'),\n    number: require('./types/number'),\n    object: require('./types/object'),\n    string: require('./types/string'),\n    symbol: require('./types/symbol')\n  },\n  aliases: {\n    alt: 'alternatives',\n    bool: 'boolean',\n    func: 'function'\n  }\n};\n\nif (Buffer) {\n  // $lab:coverage:ignore$\n  internals.types.binary = require('./types/binary');\n}\n\ninternals.root = function () {\n  const root = {\n    _types: new Set(Object.keys(internals.types))\n  }; // Types\n\n  for (const type of root._types) {\n    root[type] = function (...args) {\n      Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\n      return internals.generate(this, internals.types[type], args);\n    };\n  } // Shortcuts\n\n\n  for (const method of ['allow', 'custom', 'disallow', 'equal', 'exist', 'forbidden', 'invalid', 'not', 'only', 'optional', 'options', 'prefs', 'preferences', 'required', 'strip', 'valid', 'when']) {\n    root[method] = function (...args) {\n      return this.any()[method](...args);\n    };\n  } // Methods\n\n\n  Object.assign(root, internals.methods); // Aliases\n\n  for (const alias in internals.aliases) {\n    const target = internals.aliases[alias];\n    root[alias] = root[target];\n  }\n\n  root.x = root.expression; // Trace\n\n  if (Trace.setup) {\n    // $lab:coverage:ignore$\n    Trace.setup(root);\n  }\n\n  return root;\n};\n\ninternals.methods = {\n  ValidationError: Errors.ValidationError,\n  version: Common.version,\n  cache: Cache.provider,\n\n  assert(value, schema, ...args\n  /* [message], [options] */\n  ) {\n    internals.assert(value, schema, true, args);\n  },\n\n  attempt(value, schema, ...args\n  /* [message], [options] */\n  ) {\n    return internals.assert(value, schema, false, args);\n  },\n\n  build(desc) {\n    Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\n    return Manifest.build(this, desc);\n  },\n\n  checkPreferences(prefs) {\n    Common.checkPreferences(prefs);\n  },\n\n  compile(schema, options) {\n    return Compile.compile(this, schema, options);\n  },\n\n  defaults(modifier) {\n    Assert(typeof modifier === 'function', 'modifier must be a function');\n    const joi = Object.assign({}, this);\n\n    for (const type of joi._types) {\n      const schema = modifier(joi[type]());\n      Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\n\n      joi[type] = function (...args) {\n        return internals.generate(this, schema, args);\n      };\n    }\n\n    return joi;\n  },\n\n  expression(...args) {\n    return new Template(...args);\n  },\n\n  extend(...extensions) {\n    Common.verifyFlat(extensions, 'extend');\n    Schemas = Schemas || require('./schemas');\n    Assert(extensions.length, 'You need to provide at least one extension');\n    this.assert(extensions, Schemas.extensions);\n    const joi = Object.assign({}, this);\n    joi._types = new Set(joi._types);\n\n    for (let extension of extensions) {\n      if (typeof extension === 'function') {\n        extension = extension(joi);\n      }\n\n      this.assert(extension, Schemas.extension);\n      const expanded = internals.expandExtension(extension, joi);\n\n      for (const item of expanded) {\n        Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\n        const base = item.base || this.any();\n        const schema = Extend.type(base, item);\n\n        joi._types.add(item.type);\n\n        joi[item.type] = function (...args) {\n          return internals.generate(this, schema, args);\n        };\n      }\n    }\n\n    return joi;\n  },\n\n  isError: Errors.ValidationError.isError,\n  isExpression: Template.isTemplate,\n  isRef: Ref.isRef,\n  isSchema: Common.isSchema,\n\n  in(...args) {\n    return Ref.in(...args);\n  },\n\n  override: Common.symbols.override,\n\n  ref(...args) {\n    return Ref.create(...args);\n  },\n\n  types() {\n    const types = {};\n\n    for (const type of this._types) {\n      types[type] = this[type]();\n    }\n\n    for (const target in internals.aliases) {\n      types[target] = this[target]();\n    }\n\n    return types;\n  }\n\n}; // Helpers\n\ninternals.assert = function (value, schema, annotate, args\n/* [message], [options] */\n) {\n  const message = args[0] instanceof Error || typeof args[0] === 'string' ? args[0] : null;\n  const options = message ? args[1] : args[0];\n  const result = schema.validate(value, Common.preferences({\n    errors: {\n      stack: true\n    }\n  }, options || {}));\n  let error = result.error;\n\n  if (!error) {\n    return result.value;\n  }\n\n  if (message instanceof Error) {\n    throw message;\n  }\n\n  const display = annotate && typeof error.annotate === 'function' ? error.annotate() : error.message;\n\n  if (error instanceof Errors.ValidationError === false) {\n    error = Clone(error);\n  }\n\n  error.message = message ? `${message} ${display}` : display;\n  throw error;\n};\n\ninternals.generate = function (root, schema, args) {\n  Assert(root, 'Must be invoked on a Joi instance.');\n  schema.$_root = root;\n\n  if (!schema._definition.args || !args.length) {\n    return schema;\n  }\n\n  return schema._definition.args(schema, ...args);\n};\n\ninternals.expandExtension = function (extension, joi) {\n  if (typeof extension.type === 'string') {\n    return [extension];\n  }\n\n  const extended = [];\n\n  for (const type of joi._types) {\n    if (extension.type.test(type)) {\n      const item = Object.assign({}, extension);\n      item.type = type;\n      item.base = joi[type]();\n      extended.push(item);\n    }\n  }\n\n  return extended;\n};\n\nmodule.exports = internals.root();","map":{"version":3,"sources":["C:/scripting/jobs assignments/whist/backend/node_modules/joi/lib/index.js"],"names":["Assert","require","Clone","Cache","Common","Compile","Errors","Extend","Manifest","Ref","Template","Trace","Schemas","internals","types","alternatives","any","array","boolean","date","function","link","number","object","string","symbol","aliases","alt","bool","func","Buffer","binary","root","_types","Set","Object","keys","type","args","length","includes","generate","method","assign","methods","alias","target","x","expression","setup","ValidationError","version","cache","provider","assert","value","schema","attempt","build","desc","checkPreferences","prefs","compile","options","defaults","modifier","joi","isSchema","extend","extensions","verifyFlat","extension","expanded","expandExtension","item","undefined","has","base","add","isError","isExpression","isTemplate","isRef","in","override","symbols","ref","create","annotate","message","Error","result","validate","preferences","errors","stack","error","display","$_root","_definition","extended","test","push","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nconst Assert = require('@hapi/hoek/lib/assert');\nconst Clone = require('@hapi/hoek/lib/clone');\n\nconst Cache = require('./cache');\nconst Common = require('./common');\nconst Compile = require('./compile');\nconst Errors = require('./errors');\nconst Extend = require('./extend');\nconst Manifest = require('./manifest');\nconst Ref = require('./ref');\nconst Template = require('./template');\nconst Trace = require('./trace');\n\nlet Schemas;\n\n\nconst internals = {\n    types: {\n        alternatives: require('./types/alternatives'),\n        any: require('./types/any'),\n        array: require('./types/array'),\n        boolean: require('./types/boolean'),\n        date: require('./types/date'),\n        function: require('./types/function'),\n        link: require('./types/link'),\n        number: require('./types/number'),\n        object: require('./types/object'),\n        string: require('./types/string'),\n        symbol: require('./types/symbol')\n    },\n    aliases: {\n        alt: 'alternatives',\n        bool: 'boolean',\n        func: 'function'\n    }\n};\n\n\nif (Buffer) {                                                           // $lab:coverage:ignore$\n    internals.types.binary = require('./types/binary');\n}\n\n\ninternals.root = function () {\n\n    const root = {\n        _types: new Set(Object.keys(internals.types))\n    };\n\n    // Types\n\n    for (const type of root._types) {\n        root[type] = function (...args) {\n\n            Assert(!args.length || ['alternatives', 'link', 'object'].includes(type), 'The', type, 'type does not allow arguments');\n            return internals.generate(this, internals.types[type], args);\n        };\n    }\n\n    // Shortcuts\n\n    for (const method of ['allow', 'custom', 'disallow', 'equal', 'exist', 'forbidden', 'invalid', 'not', 'only', 'optional', 'options', 'prefs', 'preferences', 'required', 'strip', 'valid', 'when']) {\n        root[method] = function (...args) {\n\n            return this.any()[method](...args);\n        };\n    }\n\n    // Methods\n\n    Object.assign(root, internals.methods);\n\n    // Aliases\n\n    for (const alias in internals.aliases) {\n        const target = internals.aliases[alias];\n        root[alias] = root[target];\n    }\n\n    root.x = root.expression;\n\n    // Trace\n\n    if (Trace.setup) {                                          // $lab:coverage:ignore$\n        Trace.setup(root);\n    }\n\n    return root;\n};\n\n\ninternals.methods = {\n\n    ValidationError: Errors.ValidationError,\n    version: Common.version,\n    cache: Cache.provider,\n\n    assert(value, schema, ...args /* [message], [options] */) {\n\n        internals.assert(value, schema, true, args);\n    },\n\n    attempt(value, schema, ...args /* [message], [options] */) {\n\n        return internals.assert(value, schema, false, args);\n    },\n\n    build(desc) {\n\n        Assert(typeof Manifest.build === 'function', 'Manifest functionality disabled');\n        return Manifest.build(this, desc);\n    },\n\n    checkPreferences(prefs) {\n\n        Common.checkPreferences(prefs);\n    },\n\n    compile(schema, options) {\n\n        return Compile.compile(this, schema, options);\n    },\n\n    defaults(modifier) {\n\n        Assert(typeof modifier === 'function', 'modifier must be a function');\n\n        const joi = Object.assign({}, this);\n        for (const type of joi._types) {\n            const schema = modifier(joi[type]());\n            Assert(Common.isSchema(schema), 'modifier must return a valid schema object');\n\n            joi[type] = function (...args) {\n\n                return internals.generate(this, schema, args);\n            };\n        }\n\n        return joi;\n    },\n\n    expression(...args) {\n\n        return new Template(...args);\n    },\n\n    extend(...extensions) {\n\n        Common.verifyFlat(extensions, 'extend');\n\n        Schemas = Schemas || require('./schemas');\n\n        Assert(extensions.length, 'You need to provide at least one extension');\n        this.assert(extensions, Schemas.extensions);\n\n        const joi = Object.assign({}, this);\n        joi._types = new Set(joi._types);\n\n        for (let extension of extensions) {\n            if (typeof extension === 'function') {\n                extension = extension(joi);\n            }\n\n            this.assert(extension, Schemas.extension);\n\n            const expanded = internals.expandExtension(extension, joi);\n            for (const item of expanded) {\n                Assert(joi[item.type] === undefined || joi._types.has(item.type), 'Cannot override name', item.type);\n\n                const base = item.base || this.any();\n                const schema = Extend.type(base, item);\n\n                joi._types.add(item.type);\n                joi[item.type] = function (...args) {\n\n                    return internals.generate(this, schema, args);\n                };\n            }\n        }\n\n        return joi;\n    },\n\n    isError: Errors.ValidationError.isError,\n    isExpression: Template.isTemplate,\n    isRef: Ref.isRef,\n    isSchema: Common.isSchema,\n\n    in(...args) {\n\n        return Ref.in(...args);\n    },\n\n    override: Common.symbols.override,\n\n    ref(...args) {\n\n        return Ref.create(...args);\n    },\n\n    types() {\n\n        const types = {};\n        for (const type of this._types) {\n            types[type] = this[type]();\n        }\n\n        for (const target in internals.aliases) {\n            types[target] = this[target]();\n        }\n\n        return types;\n    }\n};\n\n\n// Helpers\n\ninternals.assert = function (value, schema, annotate, args /* [message], [options] */) {\n\n    const message = args[0] instanceof Error || typeof args[0] === 'string' ? args[0] : null;\n    const options = message ? args[1] : args[0];\n    const result = schema.validate(value, Common.preferences({ errors: { stack: true } }, options || {}));\n\n    let error = result.error;\n    if (!error) {\n        return result.value;\n    }\n\n    if (message instanceof Error) {\n        throw message;\n    }\n\n    const display = annotate && typeof error.annotate === 'function' ? error.annotate() : error.message;\n\n    if (error instanceof Errors.ValidationError === false) {\n        error = Clone(error);\n    }\n\n    error.message = message ? `${message} ${display}` : display;\n    throw error;\n};\n\n\ninternals.generate = function (root, schema, args) {\n\n    Assert(root, 'Must be invoked on a Joi instance.');\n\n    schema.$_root = root;\n\n    if (!schema._definition.args ||\n        !args.length) {\n\n        return schema;\n    }\n\n    return schema._definition.args(schema, ...args);\n};\n\n\ninternals.expandExtension = function (extension, joi) {\n\n    if (typeof extension.type === 'string') {\n        return [extension];\n    }\n\n    const extended = [];\n    for (const type of joi._types) {\n        if (extension.type.test(type)) {\n            const item = Object.assign({}, extension);\n            item.type = type;\n            item.base = joi[type]();\n            extended.push(item);\n        }\n    }\n\n    return extended;\n};\n\n\nmodule.exports = internals.root();\n"]},"metadata":{},"sourceType":"script"}