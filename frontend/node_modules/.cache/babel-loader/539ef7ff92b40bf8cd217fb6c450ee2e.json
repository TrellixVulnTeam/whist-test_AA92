{"ast":null,"code":"'use strict';\n\nconst Clone = require('@hapi/hoek/lib/clone');\n\nconst Reach = require('@hapi/hoek/lib/reach');\n\nconst Common = require('./common');\n\nconst internals = {\n  value: Symbol('value')\n};\nmodule.exports = internals.State = class {\n  constructor(path, ancestors, state) {\n    this.path = path;\n    this.ancestors = ancestors; // [parent, ..., root]\n\n    this.mainstay = state.mainstay;\n    this.schemas = state.schemas; // [current, ..., root]\n\n    this.debug = null;\n  }\n\n  localize(path, ancestors = null, schema = null) {\n    const state = new internals.State(path, ancestors, this);\n\n    if (schema && state.schemas) {\n      state.schemas = [internals.schemas(schema), ...state.schemas];\n    }\n\n    return state;\n  }\n\n  nest(schema, debug) {\n    const state = new internals.State(this.path, this.ancestors, this);\n    state.schemas = state.schemas && [internals.schemas(schema), ...state.schemas];\n    state.debug = debug;\n    return state;\n  }\n\n  shadow(value, reason) {\n    this.mainstay.shadow = this.mainstay.shadow || new internals.Shadow();\n    this.mainstay.shadow.set(this.path, value, reason);\n  }\n\n  snapshot() {\n    if (this.mainstay.shadow) {\n      this._snapshot = Clone(this.mainstay.shadow.node(this.path));\n    }\n  }\n\n  restore() {\n    if (this.mainstay.shadow) {\n      this.mainstay.shadow.override(this.path, this._snapshot);\n      this._snapshot = undefined;\n    }\n  }\n\n};\n\ninternals.schemas = function (schema) {\n  if (Common.isSchema(schema)) {\n    return {\n      schema\n    };\n  }\n\n  return schema;\n};\n\ninternals.Shadow = class {\n  constructor() {\n    this._values = null;\n  }\n\n  set(path, value, reason) {\n    if (!path.length) {\n      // No need to store root value\n      return;\n    }\n\n    if (reason === 'strip' && typeof path[path.length - 1] === 'number') {\n      // Cannot store stripped array values (due to shift)\n      return;\n    }\n\n    this._values = this._values || new Map();\n    let node = this._values;\n\n    for (let i = 0; i < path.length; ++i) {\n      const segment = path[i];\n      let next = node.get(segment);\n\n      if (!next) {\n        next = new Map();\n        node.set(segment, next);\n      }\n\n      node = next;\n    }\n\n    node[internals.value] = value;\n  }\n\n  get(path) {\n    const node = this.node(path);\n\n    if (node) {\n      return node[internals.value];\n    }\n  }\n\n  node(path) {\n    if (!this._values) {\n      return;\n    }\n\n    return Reach(this._values, path, {\n      iterables: true\n    });\n  }\n\n  override(path, node) {\n    if (!this._values) {\n      return;\n    }\n\n    const parents = path.slice(0, -1);\n    const own = path[path.length - 1];\n    const parent = Reach(this._values, parents, {\n      iterables: true\n    });\n\n    if (node) {\n      parent.set(own, node);\n      return;\n    }\n\n    if (parent) {\n      parent.delete(own);\n    }\n  }\n\n};","map":{"version":3,"sources":["C:/scripting/jobs assignments/whist/backend/node_modules/joi/lib/state.js"],"names":["Clone","require","Reach","Common","internals","value","Symbol","module","exports","State","constructor","path","ancestors","state","mainstay","schemas","debug","localize","schema","nest","shadow","reason","Shadow","set","snapshot","_snapshot","node","restore","override","undefined","isSchema","_values","length","Map","i","segment","next","get","iterables","parents","slice","own","parent","delete"],"mappings":"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","sourcesContent":["'use strict';\n\nconst Clone = require('@hapi/hoek/lib/clone');\nconst Reach = require('@hapi/hoek/lib/reach');\n\nconst Common = require('./common');\n\n\nconst internals = {\n    value: Symbol('value')\n};\n\n\nmodule.exports = internals.State = class {\n\n    constructor(path, ancestors, state) {\n\n        this.path = path;\n        this.ancestors = ancestors;                 // [parent, ..., root]\n\n        this.mainstay = state.mainstay;\n        this.schemas = state.schemas;               // [current, ..., root]\n        this.debug = null;\n    }\n\n    localize(path, ancestors = null, schema = null) {\n\n        const state = new internals.State(path, ancestors, this);\n\n        if (schema &&\n            state.schemas) {\n\n            state.schemas = [internals.schemas(schema), ...state.schemas];\n        }\n\n        return state;\n    }\n\n    nest(schema, debug) {\n\n        const state = new internals.State(this.path, this.ancestors, this);\n        state.schemas = state.schemas && [internals.schemas(schema), ...state.schemas];\n        state.debug = debug;\n        return state;\n    }\n\n    shadow(value, reason) {\n\n        this.mainstay.shadow = this.mainstay.shadow || new internals.Shadow();\n        this.mainstay.shadow.set(this.path, value, reason);\n    }\n\n    snapshot() {\n\n        if (this.mainstay.shadow) {\n            this._snapshot = Clone(this.mainstay.shadow.node(this.path));\n        }\n    }\n\n    restore() {\n\n        if (this.mainstay.shadow) {\n            this.mainstay.shadow.override(this.path, this._snapshot);\n            this._snapshot = undefined;\n        }\n    }\n};\n\n\ninternals.schemas = function (schema) {\n\n    if (Common.isSchema(schema)) {\n        return { schema };\n    }\n\n    return schema;\n};\n\n\ninternals.Shadow = class {\n\n    constructor() {\n\n        this._values = null;\n    }\n\n    set(path, value, reason) {\n\n        if (!path.length) {                                     // No need to store root value\n            return;\n        }\n\n        if (reason === 'strip' &&\n            typeof path[path.length - 1] === 'number') {        // Cannot store stripped array values (due to shift)\n\n            return;\n        }\n\n        this._values = this._values || new Map();\n\n        let node = this._values;\n        for (let i = 0; i < path.length; ++i) {\n            const segment = path[i];\n            let next = node.get(segment);\n            if (!next) {\n                next = new Map();\n                node.set(segment, next);\n            }\n\n            node = next;\n        }\n\n        node[internals.value] = value;\n    }\n\n    get(path) {\n\n        const node = this.node(path);\n        if (node) {\n            return node[internals.value];\n        }\n    }\n\n    node(path) {\n\n        if (!this._values) {\n            return;\n        }\n\n        return Reach(this._values, path, { iterables: true });\n    }\n\n    override(path, node) {\n\n        if (!this._values) {\n            return;\n        }\n\n        const parents = path.slice(0, -1);\n        const own = path[path.length - 1];\n        const parent = Reach(this._values, parents, { iterables: true });\n\n        if (node) {\n            parent.set(own, node);\n            return;\n        }\n\n        if (parent) {\n            parent.delete(own);\n        }\n    }\n};\n"]},"metadata":{},"sourceType":"script"}