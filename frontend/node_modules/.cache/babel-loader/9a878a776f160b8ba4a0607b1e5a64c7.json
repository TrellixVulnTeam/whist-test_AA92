{"ast":null,"code":"'use strict';\n\nconst Assert = require('@hapi/hoek/lib/assert');\n\nconst Merge = require('@hapi/hoek/lib/merge');\n\nconst Any = require('./any');\n\nconst Common = require('../common');\n\nconst Compile = require('../compile');\n\nconst Errors = require('../errors');\n\nconst Ref = require('../ref');\n\nconst internals = {};\nmodule.exports = Any.extend({\n  type: 'alternatives',\n  flags: {\n    match: {\n      default: 'any'\n    } // 'any', 'one', 'all'\n\n  },\n  terms: {\n    matches: {\n      init: [],\n      register: Ref.toSibling\n    }\n  },\n\n  args(schema, ...schemas) {\n    if (schemas.length === 1) {\n      if (Array.isArray(schemas[0])) {\n        return schema.try(...schemas[0]);\n      }\n    }\n\n    return schema.try(...schemas);\n  },\n\n  validate(value, helpers) {\n    const {\n      schema,\n      error,\n      state,\n      prefs\n    } = helpers; // Match all or one\n\n    if (schema._flags.match) {\n      const matched = [];\n\n      for (let i = 0; i < schema.$_terms.matches.length; ++i) {\n        const item = schema.$_terms.matches[i];\n        const localState = state.nest(item.schema, `match.${i}`);\n        localState.snapshot();\n        const result = item.schema.$_validate(value, localState, prefs);\n\n        if (!result.errors) {\n          matched.push(result.value);\n        } else {\n          localState.restore();\n        }\n      }\n\n      if (matched.length === 0) {\n        return {\n          errors: error('alternatives.any')\n        };\n      }\n\n      if (schema._flags.match === 'one') {\n        return matched.length === 1 ? {\n          value: matched[0]\n        } : {\n          errors: error('alternatives.one')\n        };\n      }\n\n      if (matched.length !== schema.$_terms.matches.length) {\n        return {\n          errors: error('alternatives.all')\n        };\n      }\n\n      const allobj = schema.$_terms.matches.reduce((acc, v) => acc && v.schema.type === 'object', true);\n      return allobj ? {\n        value: matched.reduce((acc, v) => Merge(acc, v, {\n          mergeArrays: false\n        }))\n      } : {\n        value: matched[matched.length - 1]\n      };\n    } // Match any\n\n\n    const errors = [];\n\n    for (let i = 0; i < schema.$_terms.matches.length; ++i) {\n      const item = schema.$_terms.matches[i]; // Try\n\n      if (item.schema) {\n        const localState = state.nest(item.schema, `match.${i}`);\n        localState.snapshot();\n        const result = item.schema.$_validate(value, localState, prefs);\n\n        if (!result.errors) {\n          return result;\n        }\n\n        localState.restore();\n        errors.push({\n          schema: item.schema,\n          reports: result.errors\n        });\n        continue;\n      } // Conditional\n\n\n      const input = item.ref ? item.ref.resolve(value, state, prefs) : value;\n      const tests = item.is ? [item] : item.switch;\n\n      for (let j = 0; j < tests.length; ++j) {\n        const test = tests[j];\n        const {\n          is,\n          then,\n          otherwise\n        } = test;\n        const id = `match.${i}${item.switch ? '.' + j : ''}`;\n\n        if (!is.$_match(input, state.nest(is, `${id}.is`), prefs)) {\n          if (otherwise) {\n            return otherwise.$_validate(value, state.nest(otherwise, `${id}.otherwise`), prefs);\n          }\n        } else if (then) {\n          return then.$_validate(value, state.nest(then, `${id}.then`), prefs);\n        }\n      }\n    }\n\n    return internals.errors(errors, helpers);\n  },\n\n  rules: {\n    conditional: {\n      method(condition, options) {\n        Assert(!this._flags._endedSwitch, 'Unreachable condition');\n        Assert(!this._flags.match, 'Cannot combine match mode', this._flags.match, 'with conditional rule');\n        Assert(options.break === undefined, 'Cannot use break option with alternatives conditional');\n        const obj = this.clone();\n        const match = Compile.when(obj, condition, options);\n        const conditions = match.is ? [match] : match.switch;\n\n        for (const item of conditions) {\n          if (item.then && item.otherwise) {\n            obj.$_setFlag('_endedSwitch', true, {\n              clone: false\n            });\n            break;\n          }\n        }\n\n        obj.$_terms.matches.push(match);\n        return obj.$_mutateRebuild();\n      }\n\n    },\n    match: {\n      method(mode) {\n        Assert(['any', 'one', 'all'].includes(mode), 'Invalid alternatives match mode', mode);\n\n        if (mode !== 'any') {\n          for (const match of this.$_terms.matches) {\n            Assert(match.schema, 'Cannot combine match mode', mode, 'with conditional rules');\n          }\n        }\n\n        return this.$_setFlag('match', mode);\n      }\n\n    },\n    try: {\n      method(...schemas) {\n        Assert(schemas.length, 'Missing alternative schemas');\n        Common.verifyFlat(schemas, 'try');\n        Assert(!this._flags._endedSwitch, 'Unreachable condition');\n        const obj = this.clone();\n\n        for (const schema of schemas) {\n          obj.$_terms.matches.push({\n            schema: obj.$_compile(schema)\n          });\n        }\n\n        return obj.$_mutateRebuild();\n      }\n\n    }\n  },\n  overrides: {\n    label(name) {\n      const obj = this.$_parent('label', name);\n\n      const each = (item, source) => source.path[0] !== 'is' ? item.label(name) : undefined;\n\n      return obj.$_modify({\n        each,\n        ref: false\n      });\n    }\n\n  },\n\n  rebuild(schema) {\n    // Flag when an alternative type is an array\n    const each = item => {\n      if (Common.isSchema(item) && item.type === 'array') {\n        schema.$_setFlag('_arrayItems', true, {\n          clone: false\n        });\n      }\n    };\n\n    schema.$_modify({\n      each\n    });\n  },\n\n  manifest: {\n    build(obj, desc) {\n      if (desc.matches) {\n        for (const match of desc.matches) {\n          const {\n            schema,\n            ref,\n            is,\n            not,\n            then,\n            otherwise\n          } = match;\n\n          if (schema) {\n            obj = obj.try(schema);\n          } else if (ref) {\n            obj = obj.conditional(ref, {\n              is,\n              then,\n              not,\n              otherwise,\n              switch: match.switch\n            });\n          } else {\n            obj = obj.conditional(is, {\n              then,\n              otherwise\n            });\n          }\n        }\n      }\n\n      return obj;\n    }\n\n  },\n  messages: {\n    'alternatives.all': '{{#label}} does not match all of the required types',\n    'alternatives.any': '{{#label}} does not match any of the allowed types',\n    'alternatives.match': '{{#label}} does not match any of the allowed types',\n    'alternatives.one': '{{#label}} matches more than one allowed type',\n    'alternatives.types': '{{#label}} must be one of {{#types}}'\n  }\n}); // Helpers\n\ninternals.errors = function (failures, {\n  error,\n  state\n}) {\n  // Nothing matched due to type criteria rules\n  if (!failures.length) {\n    return {\n      errors: error('alternatives.any')\n    };\n  } // Single error\n\n\n  if (failures.length === 1) {\n    return {\n      errors: failures[0].reports\n    };\n  } // Analyze reasons\n\n\n  const valids = new Set();\n  const complex = [];\n\n  for (const {\n    reports,\n    schema\n  } of failures) {\n    // Multiple errors (!abortEarly)\n    if (reports.length > 1) {\n      return internals.unmatched(failures, error);\n    } // Custom error\n\n\n    const report = reports[0];\n\n    if (report instanceof Errors.Report === false) {\n      return internals.unmatched(failures, error);\n    } // Internal object or array error\n\n\n    if (report.state.path.length !== state.path.length) {\n      complex.push({\n        type: schema.type,\n        report\n      });\n      continue;\n    } // Valids\n\n\n    if (report.code === 'any.only') {\n      for (const valid of report.local.valids) {\n        valids.add(valid);\n      }\n\n      continue;\n    } // Base type\n\n\n    const [type, code] = report.code.split('.');\n\n    if (code !== 'base') {\n      complex.push({\n        type: schema.type,\n        report\n      });\n      continue;\n    }\n\n    valids.add(type);\n  } // All errors are base types or valids\n\n\n  if (!complex.length) {\n    return {\n      errors: error('alternatives.types', {\n        types: [...valids]\n      })\n    };\n  } // Single complex error\n\n\n  if (complex.length === 1) {\n    return {\n      errors: complex[0].report\n    };\n  }\n\n  return internals.unmatched(failures, error);\n};\n\ninternals.unmatched = function (failures, error) {\n  const errors = [];\n\n  for (const failure of failures) {\n    errors.push(...failure.reports);\n  }\n\n  return {\n    errors: error('alternatives.match', Errors.details(errors, {\n      override: false\n    }))\n  };\n};","map":{"version":3,"sources":["C:/scripting/jobs assignments/whist/backend/node_modules/joi/lib/types/alternatives.js"],"names":["Assert","require","Merge","Any","Common","Compile","Errors","Ref","internals","module","exports","extend","type","flags","match","default","terms","matches","init","register","toSibling","args","schema","schemas","length","Array","isArray","try","validate","value","helpers","error","state","prefs","_flags","matched","i","$_terms","item","localState","nest","snapshot","result","$_validate","errors","push","restore","allobj","reduce","acc","v","mergeArrays","reports","input","ref","resolve","tests","is","switch","j","test","then","otherwise","id","$_match","rules","conditional","method","condition","options","_endedSwitch","break","undefined","obj","clone","when","conditions","$_setFlag","$_mutateRebuild","mode","includes","verifyFlat","$_compile","overrides","label","name","$_parent","each","source","path","$_modify","rebuild","isSchema","manifest","build","desc","not","messages","failures","valids","Set","complex","unmatched","report","Report","code","valid","local","add","split","types","failure","details","override"],"mappings":"AAAA;;AAEA,MAAMA,MAAM,GAAGC,OAAO,CAAC,uBAAD,CAAtB;;AACA,MAAMC,KAAK,GAAGD,OAAO,CAAC,sBAAD,CAArB;;AAEA,MAAME,GAAG,GAAGF,OAAO,CAAC,OAAD,CAAnB;;AACA,MAAMG,MAAM,GAAGH,OAAO,CAAC,WAAD,CAAtB;;AACA,MAAMI,OAAO,GAAGJ,OAAO,CAAC,YAAD,CAAvB;;AACA,MAAMK,MAAM,GAAGL,OAAO,CAAC,WAAD,CAAtB;;AACA,MAAMM,GAAG,GAAGN,OAAO,CAAC,QAAD,CAAnB;;AAGA,MAAMO,SAAS,GAAG,EAAlB;AAGAC,MAAM,CAACC,OAAP,GAAiBP,GAAG,CAACQ,MAAJ,CAAW;AAExBC,EAAAA,IAAI,EAAE,cAFkB;AAIxBC,EAAAA,KAAK,EAAE;AAEHC,IAAAA,KAAK,EAAE;AAAEC,MAAAA,OAAO,EAAE;AAAX,KAFJ,CAEuC;;AAFvC,GAJiB;AASxBC,EAAAA,KAAK,EAAE;AAEHC,IAAAA,OAAO,EAAE;AAAEC,MAAAA,IAAI,EAAE,EAAR;AAAYC,MAAAA,QAAQ,EAAEZ,GAAG,CAACa;AAA1B;AAFN,GATiB;;AAcxBC,EAAAA,IAAI,CAACC,MAAD,EAAS,GAAGC,OAAZ,EAAqB;AAErB,QAAIA,OAAO,CAACC,MAAR,KAAmB,CAAvB,EAA0B;AACtB,UAAIC,KAAK,CAACC,OAAN,CAAcH,OAAO,CAAC,CAAD,CAArB,CAAJ,EAA+B;AAC3B,eAAOD,MAAM,CAACK,GAAP,CAAW,GAAGJ,OAAO,CAAC,CAAD,CAArB,CAAP;AACH;AACJ;;AAED,WAAOD,MAAM,CAACK,GAAP,CAAW,GAAGJ,OAAd,CAAP;AACH,GAvBuB;;AAyBxBK,EAAAA,QAAQ,CAACC,KAAD,EAAQC,OAAR,EAAiB;AAErB,UAAM;AAAER,MAAAA,MAAF;AAAUS,MAAAA,KAAV;AAAiBC,MAAAA,KAAjB;AAAwBC,MAAAA;AAAxB,QAAkCH,OAAxC,CAFqB,CAIrB;;AAEA,QAAIR,MAAM,CAACY,MAAP,CAAcpB,KAAlB,EAAyB;AACrB,YAAMqB,OAAO,GAAG,EAAhB;;AAEA,WAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGd,MAAM,CAACe,OAAP,CAAepB,OAAf,CAAuBO,MAA3C,EAAmD,EAAEY,CAArD,EAAwD;AACpD,cAAME,IAAI,GAAGhB,MAAM,CAACe,OAAP,CAAepB,OAAf,CAAuBmB,CAAvB,CAAb;AACA,cAAMG,UAAU,GAAGP,KAAK,CAACQ,IAAN,CAAWF,IAAI,CAAChB,MAAhB,EAAyB,SAAQc,CAAE,EAAnC,CAAnB;AACAG,QAAAA,UAAU,CAACE,QAAX;AAEA,cAAMC,MAAM,GAAGJ,IAAI,CAAChB,MAAL,CAAYqB,UAAZ,CAAuBd,KAAvB,EAA8BU,UAA9B,EAA0CN,KAA1C,CAAf;;AACA,YAAI,CAACS,MAAM,CAACE,MAAZ,EAAoB;AAChBT,UAAAA,OAAO,CAACU,IAAR,CAAaH,MAAM,CAACb,KAApB;AACH,SAFD,MAGK;AACDU,UAAAA,UAAU,CAACO,OAAX;AACH;AACJ;;AAED,UAAIX,OAAO,CAACX,MAAR,KAAmB,CAAvB,EAA0B;AACtB,eAAO;AAAEoB,UAAAA,MAAM,EAAEb,KAAK,CAAC,kBAAD;AAAf,SAAP;AACH;;AAED,UAAIT,MAAM,CAACY,MAAP,CAAcpB,KAAd,KAAwB,KAA5B,EAAmC;AAC/B,eAAOqB,OAAO,CAACX,MAAR,KAAmB,CAAnB,GAAuB;AAAEK,UAAAA,KAAK,EAAEM,OAAO,CAAC,CAAD;AAAhB,SAAvB,GAA+C;AAAES,UAAAA,MAAM,EAAEb,KAAK,CAAC,kBAAD;AAAf,SAAtD;AACH;;AAED,UAAII,OAAO,CAACX,MAAR,KAAmBF,MAAM,CAACe,OAAP,CAAepB,OAAf,CAAuBO,MAA9C,EAAsD;AAClD,eAAO;AAAEoB,UAAAA,MAAM,EAAEb,KAAK,CAAC,kBAAD;AAAf,SAAP;AACH;;AAED,YAAMgB,MAAM,GAAGzB,MAAM,CAACe,OAAP,CAAepB,OAAf,CAAuB+B,MAAvB,CAA8B,CAACC,GAAD,EAAMC,CAAN,KAAYD,GAAG,IAAIC,CAAC,CAAC5B,MAAF,CAASV,IAAT,KAAkB,QAAnE,EAA6E,IAA7E,CAAf;AACA,aAAOmC,MAAM,GAAG;AAAElB,QAAAA,KAAK,EAAEM,OAAO,CAACa,MAAR,CAAe,CAACC,GAAD,EAAMC,CAAN,KAAYhD,KAAK,CAAC+C,GAAD,EAAMC,CAAN,EAAS;AAAEC,UAAAA,WAAW,EAAE;AAAf,SAAT,CAAhC;AAAT,OAAH,GAAkF;AAAEtB,QAAAA,KAAK,EAAEM,OAAO,CAACA,OAAO,CAACX,MAAR,GAAiB,CAAlB;AAAhB,OAA/F;AACH,KArCoB,CAuCrB;;;AAEA,UAAMoB,MAAM,GAAG,EAAf;;AACA,SAAK,IAAIR,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGd,MAAM,CAACe,OAAP,CAAepB,OAAf,CAAuBO,MAA3C,EAAmD,EAAEY,CAArD,EAAwD;AACpD,YAAME,IAAI,GAAGhB,MAAM,CAACe,OAAP,CAAepB,OAAf,CAAuBmB,CAAvB,CAAb,CADoD,CAGpD;;AAEA,UAAIE,IAAI,CAAChB,MAAT,EAAiB;AACb,cAAMiB,UAAU,GAAGP,KAAK,CAACQ,IAAN,CAAWF,IAAI,CAAChB,MAAhB,EAAyB,SAAQc,CAAE,EAAnC,CAAnB;AACAG,QAAAA,UAAU,CAACE,QAAX;AAEA,cAAMC,MAAM,GAAGJ,IAAI,CAAChB,MAAL,CAAYqB,UAAZ,CAAuBd,KAAvB,EAA8BU,UAA9B,EAA0CN,KAA1C,CAAf;;AACA,YAAI,CAACS,MAAM,CAACE,MAAZ,EAAoB;AAChB,iBAAOF,MAAP;AACH;;AAEDH,QAAAA,UAAU,CAACO,OAAX;AACAF,QAAAA,MAAM,CAACC,IAAP,CAAY;AAAEvB,UAAAA,MAAM,EAAEgB,IAAI,CAAChB,MAAf;AAAuB8B,UAAAA,OAAO,EAAEV,MAAM,CAACE;AAAvC,SAAZ;AACA;AACH,OAjBmD,CAmBpD;;;AAEA,YAAMS,KAAK,GAAGf,IAAI,CAACgB,GAAL,GAAWhB,IAAI,CAACgB,GAAL,CAASC,OAAT,CAAiB1B,KAAjB,EAAwBG,KAAxB,EAA+BC,KAA/B,CAAX,GAAmDJ,KAAjE;AACA,YAAM2B,KAAK,GAAGlB,IAAI,CAACmB,EAAL,GAAU,CAACnB,IAAD,CAAV,GAAmBA,IAAI,CAACoB,MAAtC;;AAEA,WAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,KAAK,CAAChC,MAA1B,EAAkC,EAAEmC,CAApC,EAAuC;AACnC,cAAMC,IAAI,GAAGJ,KAAK,CAACG,CAAD,CAAlB;AACA,cAAM;AAAEF,UAAAA,EAAF;AAAMI,UAAAA,IAAN;AAAYC,UAAAA;AAAZ,YAA0BF,IAAhC;AAEA,cAAMG,EAAE,GAAI,SAAQ3B,CAAE,GAAEE,IAAI,CAACoB,MAAL,GAAc,MAAMC,CAApB,GAAwB,EAAG,EAAnD;;AACA,YAAI,CAACF,EAAE,CAACO,OAAH,CAAWX,KAAX,EAAkBrB,KAAK,CAACQ,IAAN,CAAWiB,EAAX,EAAgB,GAAEM,EAAG,KAArB,CAAlB,EAA8C9B,KAA9C,CAAL,EAA2D;AACvD,cAAI6B,SAAJ,EAAe;AACX,mBAAOA,SAAS,CAACnB,UAAV,CAAqBd,KAArB,EAA4BG,KAAK,CAACQ,IAAN,CAAWsB,SAAX,EAAuB,GAAEC,EAAG,YAA5B,CAA5B,EAAsE9B,KAAtE,CAAP;AACH;AACJ,SAJD,MAKK,IAAI4B,IAAJ,EAAU;AACX,iBAAOA,IAAI,CAAClB,UAAL,CAAgBd,KAAhB,EAAuBG,KAAK,CAACQ,IAAN,CAAWqB,IAAX,EAAkB,GAAEE,EAAG,OAAvB,CAAvB,EAAuD9B,KAAvD,CAAP;AACH;AACJ;AACJ;;AAED,WAAOzB,SAAS,CAACoC,MAAV,CAAiBA,MAAjB,EAAyBd,OAAzB,CAAP;AACH,GA5GuB;;AA8GxBmC,EAAAA,KAAK,EAAE;AAEHC,IAAAA,WAAW,EAAE;AACTC,MAAAA,MAAM,CAACC,SAAD,EAAYC,OAAZ,EAAqB;AAEvBrE,QAAAA,MAAM,CAAC,CAAC,KAAKkC,MAAL,CAAYoC,YAAd,EAA4B,uBAA5B,CAAN;AACAtE,QAAAA,MAAM,CAAC,CAAC,KAAKkC,MAAL,CAAYpB,KAAd,EAAqB,2BAArB,EAAkD,KAAKoB,MAAL,CAAYpB,KAA9D,EAAqE,uBAArE,CAAN;AACAd,QAAAA,MAAM,CAACqE,OAAO,CAACE,KAAR,KAAkBC,SAAnB,EAA8B,uDAA9B,CAAN;AAEA,cAAMC,GAAG,GAAG,KAAKC,KAAL,EAAZ;AAEA,cAAM5D,KAAK,GAAGT,OAAO,CAACsE,IAAR,CAAaF,GAAb,EAAkBL,SAAlB,EAA6BC,OAA7B,CAAd;AACA,cAAMO,UAAU,GAAG9D,KAAK,CAAC2C,EAAN,GAAW,CAAC3C,KAAD,CAAX,GAAqBA,KAAK,CAAC4C,MAA9C;;AACA,aAAK,MAAMpB,IAAX,IAAmBsC,UAAnB,EAA+B;AAC3B,cAAItC,IAAI,CAACuB,IAAL,IACAvB,IAAI,CAACwB,SADT,EACoB;AAEhBW,YAAAA,GAAG,CAACI,SAAJ,CAAc,cAAd,EAA8B,IAA9B,EAAoC;AAAEH,cAAAA,KAAK,EAAE;AAAT,aAApC;AACA;AACH;AACJ;;AAEDD,QAAAA,GAAG,CAACpC,OAAJ,CAAYpB,OAAZ,CAAoB4B,IAApB,CAAyB/B,KAAzB;AACA,eAAO2D,GAAG,CAACK,eAAJ,EAAP;AACH;;AAtBQ,KAFV;AA2BHhE,IAAAA,KAAK,EAAE;AACHqD,MAAAA,MAAM,CAACY,IAAD,EAAO;AAET/E,QAAAA,MAAM,CAAC,CAAC,KAAD,EAAQ,KAAR,EAAe,KAAf,EAAsBgF,QAAtB,CAA+BD,IAA/B,CAAD,EAAuC,iCAAvC,EAA0EA,IAA1E,CAAN;;AAEA,YAAIA,IAAI,KAAK,KAAb,EAAoB;AAChB,eAAK,MAAMjE,KAAX,IAAoB,KAAKuB,OAAL,CAAapB,OAAjC,EAA0C;AACtCjB,YAAAA,MAAM,CAACc,KAAK,CAACQ,MAAP,EAAe,2BAAf,EAA4CyD,IAA5C,EAAkD,wBAAlD,CAAN;AACH;AACJ;;AAED,eAAO,KAAKF,SAAL,CAAe,OAAf,EAAwBE,IAAxB,CAAP;AACH;;AAZE,KA3BJ;AA0CHpD,IAAAA,GAAG,EAAE;AACDwC,MAAAA,MAAM,CAAC,GAAG5C,OAAJ,EAAa;AAEfvB,QAAAA,MAAM,CAACuB,OAAO,CAACC,MAAT,EAAiB,6BAAjB,CAAN;AACApB,QAAAA,MAAM,CAAC6E,UAAP,CAAkB1D,OAAlB,EAA2B,KAA3B;AAEAvB,QAAAA,MAAM,CAAC,CAAC,KAAKkC,MAAL,CAAYoC,YAAd,EAA4B,uBAA5B,CAAN;AAEA,cAAMG,GAAG,GAAG,KAAKC,KAAL,EAAZ;;AACA,aAAK,MAAMpD,MAAX,IAAqBC,OAArB,EAA8B;AAC1BkD,UAAAA,GAAG,CAACpC,OAAJ,CAAYpB,OAAZ,CAAoB4B,IAApB,CAAyB;AAAEvB,YAAAA,MAAM,EAAEmD,GAAG,CAACS,SAAJ,CAAc5D,MAAd;AAAV,WAAzB;AACH;;AAED,eAAOmD,GAAG,CAACK,eAAJ,EAAP;AACH;;AAdA;AA1CF,GA9GiB;AA0KxBK,EAAAA,SAAS,EAAE;AAEPC,IAAAA,KAAK,CAACC,IAAD,EAAO;AAER,YAAMZ,GAAG,GAAG,KAAKa,QAAL,CAAc,OAAd,EAAuBD,IAAvB,CAAZ;;AACA,YAAME,IAAI,GAAG,CAACjD,IAAD,EAAOkD,MAAP,KAAmBA,MAAM,CAACC,IAAP,CAAY,CAAZ,MAAmB,IAAnB,GAA0BnD,IAAI,CAAC8C,KAAL,CAAWC,IAAX,CAA1B,GAA6Cb,SAA7E;;AACA,aAAOC,GAAG,CAACiB,QAAJ,CAAa;AAAEH,QAAAA,IAAF;AAAQjC,QAAAA,GAAG,EAAE;AAAb,OAAb,CAAP;AACH;;AAPM,GA1Ka;;AAoLxBqC,EAAAA,OAAO,CAACrE,MAAD,EAAS;AAEZ;AAEA,UAAMiE,IAAI,GAAIjD,IAAD,IAAU;AAEnB,UAAIlC,MAAM,CAACwF,QAAP,CAAgBtD,IAAhB,KACAA,IAAI,CAAC1B,IAAL,KAAc,OADlB,EAC2B;AAEvBU,QAAAA,MAAM,CAACuD,SAAP,CAAiB,aAAjB,EAAgC,IAAhC,EAAsC;AAAEH,UAAAA,KAAK,EAAE;AAAT,SAAtC;AACH;AACJ,KAPD;;AASApD,IAAAA,MAAM,CAACoE,QAAP,CAAgB;AAAEH,MAAAA;AAAF,KAAhB;AACH,GAlMuB;;AAoMxBM,EAAAA,QAAQ,EAAE;AAENC,IAAAA,KAAK,CAACrB,GAAD,EAAMsB,IAAN,EAAY;AAEb,UAAIA,IAAI,CAAC9E,OAAT,EAAkB;AACd,aAAK,MAAMH,KAAX,IAAoBiF,IAAI,CAAC9E,OAAzB,EAAkC;AAC9B,gBAAM;AAAEK,YAAAA,MAAF;AAAUgC,YAAAA,GAAV;AAAeG,YAAAA,EAAf;AAAmBuC,YAAAA,GAAnB;AAAwBnC,YAAAA,IAAxB;AAA8BC,YAAAA;AAA9B,cAA4ChD,KAAlD;;AACA,cAAIQ,MAAJ,EAAY;AACRmD,YAAAA,GAAG,GAAGA,GAAG,CAAC9C,GAAJ,CAAQL,MAAR,CAAN;AACH,WAFD,MAGK,IAAIgC,GAAJ,EAAS;AACVmB,YAAAA,GAAG,GAAGA,GAAG,CAACP,WAAJ,CAAgBZ,GAAhB,EAAqB;AAAEG,cAAAA,EAAF;AAAMI,cAAAA,IAAN;AAAYmC,cAAAA,GAAZ;AAAiBlC,cAAAA,SAAjB;AAA4BJ,cAAAA,MAAM,EAAE5C,KAAK,CAAC4C;AAA1C,aAArB,CAAN;AACH,WAFI,MAGA;AACDe,YAAAA,GAAG,GAAGA,GAAG,CAACP,WAAJ,CAAgBT,EAAhB,EAAoB;AAAEI,cAAAA,IAAF;AAAQC,cAAAA;AAAR,aAApB,CAAN;AACH;AACJ;AACJ;;AAED,aAAOW,GAAP;AACH;;AApBK,GApMc;AA2NxBwB,EAAAA,QAAQ,EAAE;AACN,wBAAoB,qDADd;AAEN,wBAAoB,oDAFd;AAGN,0BAAsB,oDAHhB;AAIN,wBAAoB,+CAJd;AAKN,0BAAsB;AALhB;AA3Nc,CAAX,CAAjB,C,CAqOA;;AAEAzF,SAAS,CAACoC,MAAV,GAAmB,UAAUsD,QAAV,EAAoB;AAAEnE,EAAAA,KAAF;AAASC,EAAAA;AAAT,CAApB,EAAsC;AAErD;AAEA,MAAI,CAACkE,QAAQ,CAAC1E,MAAd,EAAsB;AAClB,WAAO;AAAEoB,MAAAA,MAAM,EAAEb,KAAK,CAAC,kBAAD;AAAf,KAAP;AACH,GANoD,CAQrD;;;AAEA,MAAImE,QAAQ,CAAC1E,MAAT,KAAoB,CAAxB,EAA2B;AACvB,WAAO;AAAEoB,MAAAA,MAAM,EAAEsD,QAAQ,CAAC,CAAD,CAAR,CAAY9C;AAAtB,KAAP;AACH,GAZoD,CAcrD;;;AAEA,QAAM+C,MAAM,GAAG,IAAIC,GAAJ,EAAf;AACA,QAAMC,OAAO,GAAG,EAAhB;;AAEA,OAAK,MAAM;AAAEjD,IAAAA,OAAF;AAAW9B,IAAAA;AAAX,GAAX,IAAkC4E,QAAlC,EAA4C;AAExC;AAEA,QAAI9C,OAAO,CAAC5B,MAAR,GAAiB,CAArB,EAAwB;AACpB,aAAOhB,SAAS,CAAC8F,SAAV,CAAoBJ,QAApB,EAA8BnE,KAA9B,CAAP;AACH,KANuC,CAQxC;;;AAEA,UAAMwE,MAAM,GAAGnD,OAAO,CAAC,CAAD,CAAtB;;AACA,QAAImD,MAAM,YAAYjG,MAAM,CAACkG,MAAzB,KAAoC,KAAxC,EAA+C;AAC3C,aAAOhG,SAAS,CAAC8F,SAAV,CAAoBJ,QAApB,EAA8BnE,KAA9B,CAAP;AACH,KAbuC,CAexC;;;AAEA,QAAIwE,MAAM,CAACvE,KAAP,CAAayD,IAAb,CAAkBjE,MAAlB,KAA6BQ,KAAK,CAACyD,IAAN,CAAWjE,MAA5C,EAAoD;AAChD6E,MAAAA,OAAO,CAACxD,IAAR,CAAa;AAAEjC,QAAAA,IAAI,EAAEU,MAAM,CAACV,IAAf;AAAqB2F,QAAAA;AAArB,OAAb;AACA;AACH,KApBuC,CAsBxC;;;AAEA,QAAIA,MAAM,CAACE,IAAP,KAAgB,UAApB,EAAgC;AAC5B,WAAK,MAAMC,KAAX,IAAoBH,MAAM,CAACI,KAAP,CAAaR,MAAjC,EAAyC;AACrCA,QAAAA,MAAM,CAACS,GAAP,CAAWF,KAAX;AACH;;AAED;AACH,KA9BuC,CAgCxC;;;AAEA,UAAM,CAAC9F,IAAD,EAAO6F,IAAP,IAAeF,MAAM,CAACE,IAAP,CAAYI,KAAZ,CAAkB,GAAlB,CAArB;;AACA,QAAIJ,IAAI,KAAK,MAAb,EAAqB;AACjBJ,MAAAA,OAAO,CAACxD,IAAR,CAAa;AAAEjC,QAAAA,IAAI,EAAEU,MAAM,CAACV,IAAf;AAAqB2F,QAAAA;AAArB,OAAb;AACA;AACH;;AAEDJ,IAAAA,MAAM,CAACS,GAAP,CAAWhG,IAAX;AACH,GA5DoD,CA8DrD;;;AAEA,MAAI,CAACyF,OAAO,CAAC7E,MAAb,EAAqB;AACjB,WAAO;AAAEoB,MAAAA,MAAM,EAAEb,KAAK,CAAC,oBAAD,EAAuB;AAAE+E,QAAAA,KAAK,EAAE,CAAC,GAAGX,MAAJ;AAAT,OAAvB;AAAf,KAAP;AACH,GAlEoD,CAoErD;;;AAEA,MAAIE,OAAO,CAAC7E,MAAR,KAAmB,CAAvB,EAA0B;AACtB,WAAO;AAAEoB,MAAAA,MAAM,EAAEyD,OAAO,CAAC,CAAD,CAAP,CAAWE;AAArB,KAAP;AACH;;AAED,SAAO/F,SAAS,CAAC8F,SAAV,CAAoBJ,QAApB,EAA8BnE,KAA9B,CAAP;AACH,CA3ED;;AA8EAvB,SAAS,CAAC8F,SAAV,GAAsB,UAAUJ,QAAV,EAAoBnE,KAApB,EAA2B;AAE7C,QAAMa,MAAM,GAAG,EAAf;;AACA,OAAK,MAAMmE,OAAX,IAAsBb,QAAtB,EAAgC;AAC5BtD,IAAAA,MAAM,CAACC,IAAP,CAAY,GAAGkE,OAAO,CAAC3D,OAAvB;AACH;;AAED,SAAO;AAAER,IAAAA,MAAM,EAAEb,KAAK,CAAC,oBAAD,EAAuBzB,MAAM,CAAC0G,OAAP,CAAepE,MAAf,EAAuB;AAAEqE,MAAAA,QAAQ,EAAE;AAAZ,KAAvB,CAAvB;AAAf,GAAP;AACH,CARD","sourcesContent":["'use strict';\n\nconst Assert = require('@hapi/hoek/lib/assert');\nconst Merge = require('@hapi/hoek/lib/merge');\n\nconst Any = require('./any');\nconst Common = require('../common');\nconst Compile = require('../compile');\nconst Errors = require('../errors');\nconst Ref = require('../ref');\n\n\nconst internals = {};\n\n\nmodule.exports = Any.extend({\n\n    type: 'alternatives',\n\n    flags: {\n\n        match: { default: 'any' }                 // 'any', 'one', 'all'\n    },\n\n    terms: {\n\n        matches: { init: [], register: Ref.toSibling }\n    },\n\n    args(schema, ...schemas) {\n\n        if (schemas.length === 1) {\n            if (Array.isArray(schemas[0])) {\n                return schema.try(...schemas[0]);\n            }\n        }\n\n        return schema.try(...schemas);\n    },\n\n    validate(value, helpers) {\n\n        const { schema, error, state, prefs } = helpers;\n\n        // Match all or one\n\n        if (schema._flags.match) {\n            const matched = [];\n\n            for (let i = 0; i < schema.$_terms.matches.length; ++i) {\n                const item = schema.$_terms.matches[i];\n                const localState = state.nest(item.schema, `match.${i}`);\n                localState.snapshot();\n\n                const result = item.schema.$_validate(value, localState, prefs);\n                if (!result.errors) {\n                    matched.push(result.value);\n                }\n                else {\n                    localState.restore();\n                }\n            }\n\n            if (matched.length === 0) {\n                return { errors: error('alternatives.any') };\n            }\n\n            if (schema._flags.match === 'one') {\n                return matched.length === 1 ? { value: matched[0] } : { errors: error('alternatives.one') };\n            }\n\n            if (matched.length !== schema.$_terms.matches.length) {\n                return { errors: error('alternatives.all') };\n            }\n\n            const allobj = schema.$_terms.matches.reduce((acc, v) => acc && v.schema.type === 'object', true);\n            return allobj ? { value: matched.reduce((acc, v) => Merge(acc, v, { mergeArrays: false })) } : { value: matched[matched.length - 1] };\n        }\n\n        // Match any\n\n        const errors = [];\n        for (let i = 0; i < schema.$_terms.matches.length; ++i) {\n            const item = schema.$_terms.matches[i];\n\n            // Try\n\n            if (item.schema) {\n                const localState = state.nest(item.schema, `match.${i}`);\n                localState.snapshot();\n\n                const result = item.schema.$_validate(value, localState, prefs);\n                if (!result.errors) {\n                    return result;\n                }\n\n                localState.restore();\n                errors.push({ schema: item.schema, reports: result.errors });\n                continue;\n            }\n\n            // Conditional\n\n            const input = item.ref ? item.ref.resolve(value, state, prefs) : value;\n            const tests = item.is ? [item] : item.switch;\n\n            for (let j = 0; j < tests.length; ++j) {\n                const test = tests[j];\n                const { is, then, otherwise } = test;\n\n                const id = `match.${i}${item.switch ? '.' + j : ''}`;\n                if (!is.$_match(input, state.nest(is, `${id}.is`), prefs)) {\n                    if (otherwise) {\n                        return otherwise.$_validate(value, state.nest(otherwise, `${id}.otherwise`), prefs);\n                    }\n                }\n                else if (then) {\n                    return then.$_validate(value, state.nest(then, `${id}.then`), prefs);\n                }\n            }\n        }\n\n        return internals.errors(errors, helpers);\n    },\n\n    rules: {\n\n        conditional: {\n            method(condition, options) {\n\n                Assert(!this._flags._endedSwitch, 'Unreachable condition');\n                Assert(!this._flags.match, 'Cannot combine match mode', this._flags.match, 'with conditional rule');\n                Assert(options.break === undefined, 'Cannot use break option with alternatives conditional');\n\n                const obj = this.clone();\n\n                const match = Compile.when(obj, condition, options);\n                const conditions = match.is ? [match] : match.switch;\n                for (const item of conditions) {\n                    if (item.then &&\n                        item.otherwise) {\n\n                        obj.$_setFlag('_endedSwitch', true, { clone: false });\n                        break;\n                    }\n                }\n\n                obj.$_terms.matches.push(match);\n                return obj.$_mutateRebuild();\n            }\n        },\n\n        match: {\n            method(mode) {\n\n                Assert(['any', 'one', 'all'].includes(mode), 'Invalid alternatives match mode', mode);\n\n                if (mode !== 'any') {\n                    for (const match of this.$_terms.matches) {\n                        Assert(match.schema, 'Cannot combine match mode', mode, 'with conditional rules');\n                    }\n                }\n\n                return this.$_setFlag('match', mode);\n            }\n        },\n\n        try: {\n            method(...schemas) {\n\n                Assert(schemas.length, 'Missing alternative schemas');\n                Common.verifyFlat(schemas, 'try');\n\n                Assert(!this._flags._endedSwitch, 'Unreachable condition');\n\n                const obj = this.clone();\n                for (const schema of schemas) {\n                    obj.$_terms.matches.push({ schema: obj.$_compile(schema) });\n                }\n\n                return obj.$_mutateRebuild();\n            }\n        }\n    },\n\n    overrides: {\n\n        label(name) {\n\n            const obj = this.$_parent('label', name);\n            const each = (item, source) => (source.path[0] !== 'is' ? item.label(name) : undefined);\n            return obj.$_modify({ each, ref: false });\n        }\n    },\n\n    rebuild(schema) {\n\n        // Flag when an alternative type is an array\n\n        const each = (item) => {\n\n            if (Common.isSchema(item) &&\n                item.type === 'array') {\n\n                schema.$_setFlag('_arrayItems', true, { clone: false });\n            }\n        };\n\n        schema.$_modify({ each });\n    },\n\n    manifest: {\n\n        build(obj, desc) {\n\n            if (desc.matches) {\n                for (const match of desc.matches) {\n                    const { schema, ref, is, not, then, otherwise } = match;\n                    if (schema) {\n                        obj = obj.try(schema);\n                    }\n                    else if (ref) {\n                        obj = obj.conditional(ref, { is, then, not, otherwise, switch: match.switch });\n                    }\n                    else {\n                        obj = obj.conditional(is, { then, otherwise });\n                    }\n                }\n            }\n\n            return obj;\n        }\n    },\n\n    messages: {\n        'alternatives.all': '{{#label}} does not match all of the required types',\n        'alternatives.any': '{{#label}} does not match any of the allowed types',\n        'alternatives.match': '{{#label}} does not match any of the allowed types',\n        'alternatives.one': '{{#label}} matches more than one allowed type',\n        'alternatives.types': '{{#label}} must be one of {{#types}}'\n    }\n});\n\n\n// Helpers\n\ninternals.errors = function (failures, { error, state }) {\n\n    // Nothing matched due to type criteria rules\n\n    if (!failures.length) {\n        return { errors: error('alternatives.any') };\n    }\n\n    // Single error\n\n    if (failures.length === 1) {\n        return { errors: failures[0].reports };\n    }\n\n    // Analyze reasons\n\n    const valids = new Set();\n    const complex = [];\n\n    for (const { reports, schema } of failures) {\n\n        // Multiple errors (!abortEarly)\n\n        if (reports.length > 1) {\n            return internals.unmatched(failures, error);\n        }\n\n        // Custom error\n\n        const report = reports[0];\n        if (report instanceof Errors.Report === false) {\n            return internals.unmatched(failures, error);\n        }\n\n        // Internal object or array error\n\n        if (report.state.path.length !== state.path.length) {\n            complex.push({ type: schema.type, report });\n            continue;\n        }\n\n        // Valids\n\n        if (report.code === 'any.only') {\n            for (const valid of report.local.valids) {\n                valids.add(valid);\n            }\n\n            continue;\n        }\n\n        // Base type\n\n        const [type, code] = report.code.split('.');\n        if (code !== 'base') {\n            complex.push({ type: schema.type, report });\n            continue;\n        }\n\n        valids.add(type);\n    }\n\n    // All errors are base types or valids\n\n    if (!complex.length) {\n        return { errors: error('alternatives.types', { types: [...valids] }) };\n    }\n\n    // Single complex error\n\n    if (complex.length === 1) {\n        return { errors: complex[0].report };\n    }\n\n    return internals.unmatched(failures, error);\n};\n\n\ninternals.unmatched = function (failures, error) {\n\n    const errors = [];\n    for (const failure of failures) {\n        errors.push(...failure.reports);\n    }\n\n    return { errors: error('alternatives.match', Errors.details(errors, { override: false })) };\n};\n"]},"metadata":{},"sourceType":"script"}