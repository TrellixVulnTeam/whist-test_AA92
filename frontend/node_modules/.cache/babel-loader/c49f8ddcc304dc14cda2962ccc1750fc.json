{"ast":null,"code":"'use strict';\n\nconst Assert = require('@hapi/hoek/lib/assert');\n\nconst Clone = require('@hapi/hoek/lib/clone');\n\nconst Common = require('./common');\n\nconst Messages = require('./messages');\n\nconst internals = {};\n\nexports.type = function (from, options) {\n  const base = Object.getPrototypeOf(from);\n  const prototype = Clone(base);\n\n  const schema = from._assign(Object.create(prototype));\n\n  const def = Object.assign({}, options); // Shallow cloned\n\n  delete def.base;\n  prototype._definition = def;\n  const parent = base._definition || {};\n  def.messages = Messages.merge(parent.messages, def.messages);\n  def.properties = Object.assign({}, parent.properties, def.properties); // Type\n\n  schema.type = def.type; // Flags\n\n  def.flags = Object.assign({}, parent.flags, def.flags); // Terms\n\n  const terms = Object.assign({}, parent.terms);\n\n  if (def.terms) {\n    for (const name in def.terms) {\n      // Only apply own terms\n      const term = def.terms[name];\n      Assert(schema.$_terms[name] === undefined, 'Invalid term override for', def.type, name);\n      schema.$_terms[name] = term.init;\n      terms[name] = term;\n    }\n  }\n\n  def.terms = terms; // Constructor arguments\n\n  if (!def.args) {\n    def.args = parent.args;\n  } // Prepare\n\n\n  def.prepare = internals.prepare(def.prepare, parent.prepare); // Coerce\n\n  if (def.coerce) {\n    if (typeof def.coerce === 'function') {\n      def.coerce = {\n        method: def.coerce\n      };\n    }\n\n    if (def.coerce.from && !Array.isArray(def.coerce.from)) {\n      def.coerce = {\n        method: def.coerce.method,\n        from: [].concat(def.coerce.from)\n      };\n    }\n  }\n\n  def.coerce = internals.coerce(def.coerce, parent.coerce); // Validate\n\n  def.validate = internals.validate(def.validate, parent.validate); // Rules\n\n  const rules = Object.assign({}, parent.rules);\n\n  if (def.rules) {\n    for (const name in def.rules) {\n      const rule = def.rules[name];\n      Assert(typeof rule === 'object', 'Invalid rule definition for', def.type, name);\n      let method = rule.method;\n\n      if (method === undefined) {\n        method = function () {\n          return this.$_addRule(name);\n        };\n      }\n\n      if (method) {\n        Assert(!prototype[name], 'Rule conflict in', def.type, name);\n        prototype[name] = method;\n      }\n\n      Assert(!rules[name], 'Rule conflict in', def.type, name);\n      rules[name] = rule;\n\n      if (rule.alias) {\n        const aliases = [].concat(rule.alias);\n\n        for (const alias of aliases) {\n          prototype[alias] = rule.method;\n        }\n      }\n\n      if (rule.args) {\n        rule.argsByName = new Map();\n        rule.args = rule.args.map(arg => {\n          if (typeof arg === 'string') {\n            arg = {\n              name: arg\n            };\n          }\n\n          Assert(!rule.argsByName.has(arg.name), 'Duplicated argument name', arg.name);\n\n          if (Common.isSchema(arg.assert)) {\n            arg.assert = arg.assert.strict().label(arg.name);\n          }\n\n          rule.argsByName.set(arg.name, arg);\n          return arg;\n        });\n      }\n    }\n  }\n\n  def.rules = rules; // Modifiers\n\n  const modifiers = Object.assign({}, parent.modifiers);\n\n  if (def.modifiers) {\n    for (const name in def.modifiers) {\n      Assert(!prototype[name], 'Rule conflict in', def.type, name);\n      const modifier = def.modifiers[name];\n      Assert(typeof modifier === 'function', 'Invalid modifier definition for', def.type, name);\n\n      const method = function (arg) {\n        return this.rule({\n          [name]: arg\n        });\n      };\n\n      prototype[name] = method;\n      modifiers[name] = modifier;\n    }\n  }\n\n  def.modifiers = modifiers; // Overrides\n\n  if (def.overrides) {\n    prototype._super = base;\n    schema.$_super = {}; // Backwards compatibility\n\n    for (const override in def.overrides) {\n      Assert(base[override], 'Cannot override missing', override);\n      def.overrides[override][Common.symbols.parent] = base[override];\n      schema.$_super[override] = base[override].bind(schema); // Backwards compatibility\n    }\n\n    Object.assign(prototype, def.overrides);\n  } // Casts\n\n\n  def.cast = Object.assign({}, parent.cast, def.cast); // Manifest\n\n  const manifest = Object.assign({}, parent.manifest, def.manifest);\n  manifest.build = internals.build(def.manifest && def.manifest.build, parent.manifest && parent.manifest.build);\n  def.manifest = manifest; // Rebuild\n\n  def.rebuild = internals.rebuild(def.rebuild, parent.rebuild);\n  return schema;\n}; // Helpers\n\n\ninternals.build = function (child, parent) {\n  if (!child || !parent) {\n    return child || parent;\n  }\n\n  return function (obj, desc) {\n    return parent(child(obj, desc), desc);\n  };\n};\n\ninternals.coerce = function (child, parent) {\n  if (!child || !parent) {\n    return child || parent;\n  }\n\n  return {\n    from: child.from && parent.from ? [...new Set([...child.from, ...parent.from])] : null,\n\n    method(value, helpers) {\n      let coerced;\n\n      if (!parent.from || parent.from.includes(typeof value)) {\n        coerced = parent.method(value, helpers);\n\n        if (coerced) {\n          if (coerced.errors || coerced.value === undefined) {\n            return coerced;\n          }\n\n          value = coerced.value;\n        }\n      }\n\n      if (!child.from || child.from.includes(typeof value)) {\n        const own = child.method(value, helpers);\n\n        if (own) {\n          return own;\n        }\n      }\n\n      return coerced;\n    }\n\n  };\n};\n\ninternals.prepare = function (child, parent) {\n  if (!child || !parent) {\n    return child || parent;\n  }\n\n  return function (value, helpers) {\n    const prepared = child(value, helpers);\n\n    if (prepared) {\n      if (prepared.errors || prepared.value === undefined) {\n        return prepared;\n      }\n\n      value = prepared.value;\n    }\n\n    return parent(value, helpers) || prepared;\n  };\n};\n\ninternals.rebuild = function (child, parent) {\n  if (!child || !parent) {\n    return child || parent;\n  }\n\n  return function (schema) {\n    parent(schema);\n    child(schema);\n  };\n};\n\ninternals.validate = function (child, parent) {\n  if (!child || !parent) {\n    return child || parent;\n  }\n\n  return function (value, helpers) {\n    const result = parent(value, helpers);\n\n    if (result) {\n      if (result.errors && (!Array.isArray(result.errors) || result.errors.length)) {\n        return result;\n      }\n\n      value = result.value;\n    }\n\n    return child(value, helpers) || result;\n  };\n};","map":{"version":3,"sources":["C:/scripting/jobs assignments/whist/backend/node_modules/joi/lib/extend.js"],"names":["Assert","require","Clone","Common","Messages","internals","exports","type","from","options","base","Object","getPrototypeOf","prototype","schema","_assign","create","def","assign","_definition","parent","messages","merge","properties","flags","terms","name","term","$_terms","undefined","init","args","prepare","coerce","method","Array","isArray","concat","validate","rules","rule","$_addRule","alias","aliases","argsByName","Map","map","arg","has","isSchema","assert","strict","label","set","modifiers","modifier","overrides","_super","$_super","override","symbols","bind","cast","manifest","build","rebuild","child","obj","desc","Set","value","helpers","coerced","includes","errors","own","prepared","result","length"],"mappings":"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","sourcesContent":["'use strict';\n\nconst Assert = require('@hapi/hoek/lib/assert');\nconst Clone = require('@hapi/hoek/lib/clone');\n\nconst Common = require('./common');\nconst Messages = require('./messages');\n\n\nconst internals = {};\n\n\nexports.type = function (from, options) {\n\n    const base = Object.getPrototypeOf(from);\n    const prototype = Clone(base);\n    const schema = from._assign(Object.create(prototype));\n    const def = Object.assign({}, options);                                 // Shallow cloned\n    delete def.base;\n\n    prototype._definition = def;\n\n    const parent = base._definition || {};\n    def.messages = Messages.merge(parent.messages, def.messages);\n    def.properties = Object.assign({}, parent.properties, def.properties);\n\n    // Type\n\n    schema.type = def.type;\n\n    // Flags\n\n    def.flags = Object.assign({}, parent.flags, def.flags);\n\n    // Terms\n\n    const terms = Object.assign({}, parent.terms);\n    if (def.terms) {\n        for (const name in def.terms) {                                     // Only apply own terms\n            const term = def.terms[name];\n            Assert(schema.$_terms[name] === undefined, 'Invalid term override for', def.type, name);\n            schema.$_terms[name] = term.init;\n            terms[name] = term;\n        }\n    }\n\n    def.terms = terms;\n\n    // Constructor arguments\n\n    if (!def.args) {\n        def.args = parent.args;\n    }\n\n    // Prepare\n\n    def.prepare = internals.prepare(def.prepare, parent.prepare);\n\n    // Coerce\n\n    if (def.coerce) {\n        if (typeof def.coerce === 'function') {\n            def.coerce = { method: def.coerce };\n        }\n\n        if (def.coerce.from &&\n            !Array.isArray(def.coerce.from)) {\n\n            def.coerce = { method: def.coerce.method, from: [].concat(def.coerce.from) };\n        }\n    }\n\n    def.coerce = internals.coerce(def.coerce, parent.coerce);\n\n    // Validate\n\n    def.validate = internals.validate(def.validate, parent.validate);\n\n    // Rules\n\n    const rules = Object.assign({}, parent.rules);\n    if (def.rules) {\n        for (const name in def.rules) {\n            const rule = def.rules[name];\n            Assert(typeof rule === 'object', 'Invalid rule definition for', def.type, name);\n\n            let method = rule.method;\n            if (method === undefined) {\n                method = function () {\n\n                    return this.$_addRule(name);\n                };\n            }\n\n            if (method) {\n                Assert(!prototype[name], 'Rule conflict in', def.type, name);\n                prototype[name] = method;\n            }\n\n            Assert(!rules[name], 'Rule conflict in', def.type, name);\n            rules[name] = rule;\n\n            if (rule.alias) {\n                const aliases = [].concat(rule.alias);\n                for (const alias of aliases) {\n                    prototype[alias] = rule.method;\n                }\n            }\n\n            if (rule.args) {\n                rule.argsByName = new Map();\n                rule.args = rule.args.map((arg) => {\n\n                    if (typeof arg === 'string') {\n                        arg = { name: arg };\n                    }\n\n                    Assert(!rule.argsByName.has(arg.name), 'Duplicated argument name', arg.name);\n\n                    if (Common.isSchema(arg.assert)) {\n                        arg.assert = arg.assert.strict().label(arg.name);\n                    }\n\n                    rule.argsByName.set(arg.name, arg);\n                    return arg;\n                });\n            }\n        }\n    }\n\n    def.rules = rules;\n\n    // Modifiers\n\n    const modifiers = Object.assign({}, parent.modifiers);\n    if (def.modifiers) {\n        for (const name in def.modifiers) {\n            Assert(!prototype[name], 'Rule conflict in', def.type, name);\n\n            const modifier = def.modifiers[name];\n            Assert(typeof modifier === 'function', 'Invalid modifier definition for', def.type, name);\n\n            const method = function (arg) {\n\n                return this.rule({ [name]: arg });\n            };\n\n            prototype[name] = method;\n            modifiers[name] = modifier;\n        }\n    }\n\n    def.modifiers = modifiers;\n\n    // Overrides\n\n    if (def.overrides) {\n        prototype._super = base;\n        schema.$_super = {};                                                            // Backwards compatibility\n        for (const override in def.overrides) {\n            Assert(base[override], 'Cannot override missing', override);\n            def.overrides[override][Common.symbols.parent] = base[override];\n            schema.$_super[override] = base[override].bind(schema);                     // Backwards compatibility\n        }\n\n        Object.assign(prototype, def.overrides);\n    }\n\n    // Casts\n\n    def.cast = Object.assign({}, parent.cast, def.cast);\n\n    // Manifest\n\n    const manifest = Object.assign({}, parent.manifest, def.manifest);\n    manifest.build = internals.build(def.manifest && def.manifest.build, parent.manifest && parent.manifest.build);\n    def.manifest = manifest;\n\n    // Rebuild\n\n    def.rebuild = internals.rebuild(def.rebuild, parent.rebuild);\n\n    return schema;\n};\n\n\n// Helpers\n\ninternals.build = function (child, parent) {\n\n    if (!child ||\n        !parent) {\n\n        return child || parent;\n    }\n\n    return function (obj, desc) {\n\n        return parent(child(obj, desc), desc);\n    };\n};\n\n\ninternals.coerce = function (child, parent) {\n\n    if (!child ||\n        !parent) {\n\n        return child || parent;\n    }\n\n    return {\n        from: child.from && parent.from ? [...new Set([...child.from, ...parent.from])] : null,\n        method(value, helpers) {\n\n            let coerced;\n            if (!parent.from ||\n                parent.from.includes(typeof value)) {\n\n                coerced = parent.method(value, helpers);\n                if (coerced) {\n                    if (coerced.errors ||\n                        coerced.value === undefined) {\n\n                        return coerced;\n                    }\n\n                    value = coerced.value;\n                }\n            }\n\n            if (!child.from ||\n                child.from.includes(typeof value)) {\n\n                const own = child.method(value, helpers);\n                if (own) {\n                    return own;\n                }\n            }\n\n            return coerced;\n        }\n    };\n};\n\n\ninternals.prepare = function (child, parent) {\n\n    if (!child ||\n        !parent) {\n\n        return child || parent;\n    }\n\n    return function (value, helpers) {\n\n        const prepared = child(value, helpers);\n        if (prepared) {\n            if (prepared.errors ||\n                prepared.value === undefined) {\n\n                return prepared;\n            }\n\n            value = prepared.value;\n        }\n\n        return parent(value, helpers) || prepared;\n    };\n};\n\n\ninternals.rebuild = function (child, parent) {\n\n    if (!child ||\n        !parent) {\n\n        return child || parent;\n    }\n\n    return function (schema) {\n\n        parent(schema);\n        child(schema);\n    };\n};\n\n\ninternals.validate = function (child, parent) {\n\n    if (!child ||\n        !parent) {\n\n        return child || parent;\n    }\n\n    return function (value, helpers) {\n\n        const result = parent(value, helpers);\n        if (result) {\n            if (result.errors &&\n                (!Array.isArray(result.errors) || result.errors.length)) {\n\n                return result;\n            }\n\n            value = result.value;\n        }\n\n        return child(value, helpers) || result;\n    };\n};\n"]},"metadata":{},"sourceType":"script"}