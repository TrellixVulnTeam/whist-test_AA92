{"ast":null,"code":"'use strict';\n\nconst Assert = require('@hapi/hoek/lib/assert');\n\nconst Clone = require('@hapi/hoek/lib/clone');\n\nconst Common = require('./common');\n\nconst Messages = require('./messages');\n\nconst Ref = require('./ref');\n\nconst Template = require('./template');\n\nlet Schemas;\nconst internals = {};\n\nexports.describe = function (schema) {\n  const def = schema._definition; // Type\n\n  const desc = {\n    type: schema.type,\n    flags: {},\n    rules: []\n  }; // Flags\n\n  for (const flag in schema._flags) {\n    if (flag[0] !== '_') {\n      desc.flags[flag] = internals.describe(schema._flags[flag]);\n    }\n  }\n\n  if (!Object.keys(desc.flags).length) {\n    delete desc.flags;\n  } // Preferences\n\n\n  if (schema._preferences) {\n    desc.preferences = Clone(schema._preferences, {\n      shallow: ['messages']\n    });\n    delete desc.preferences[Common.symbols.prefs];\n\n    if (desc.preferences.messages) {\n      desc.preferences.messages = Messages.decompile(desc.preferences.messages);\n    }\n  } // Allow / Invalid\n\n\n  if (schema._valids) {\n    desc.allow = schema._valids.describe();\n  }\n\n  if (schema._invalids) {\n    desc.invalid = schema._invalids.describe();\n  } // Rules\n\n\n  for (const rule of schema._rules) {\n    const ruleDef = def.rules[rule.name];\n\n    if (ruleDef.manifest === false) {\n      // Defaults to true\n      continue;\n    }\n\n    const item = {\n      name: rule.name\n    };\n\n    for (const custom in def.modifiers) {\n      if (rule[custom] !== undefined) {\n        item[custom] = internals.describe(rule[custom]);\n      }\n    }\n\n    if (rule.args) {\n      item.args = {};\n\n      for (const key in rule.args) {\n        const arg = rule.args[key];\n\n        if (key === 'options' && !Object.keys(arg).length) {\n          continue;\n        }\n\n        item.args[key] = internals.describe(arg, {\n          assign: key\n        });\n      }\n\n      if (!Object.keys(item.args).length) {\n        delete item.args;\n      }\n    }\n\n    desc.rules.push(item);\n  }\n\n  if (!desc.rules.length) {\n    delete desc.rules;\n  } // Terms (must be last to verify no name conflicts)\n\n\n  for (const term in schema.$_terms) {\n    if (term[0] === '_') {\n      continue;\n    }\n\n    Assert(!desc[term], 'Cannot describe schema due to internal name conflict with', term);\n    const items = schema.$_terms[term];\n\n    if (!items) {\n      continue;\n    }\n\n    if (items instanceof Map) {\n      if (items.size) {\n        desc[term] = [...items.entries()];\n      }\n\n      continue;\n    }\n\n    if (Common.isValues(items)) {\n      desc[term] = items.describe();\n      continue;\n    }\n\n    Assert(def.terms[term], 'Term', term, 'missing configuration');\n    const manifest = def.terms[term].manifest;\n    const mapped = typeof manifest === 'object';\n\n    if (!items.length && !mapped) {\n      continue;\n    }\n\n    const normalized = [];\n\n    for (const item of items) {\n      normalized.push(internals.describe(item));\n    } // Mapped\n\n\n    if (mapped) {\n      const {\n        from,\n        to\n      } = manifest.mapped;\n      desc[term] = {};\n\n      for (const item of normalized) {\n        desc[term][item[to]] = item[from];\n      }\n\n      continue;\n    } // Single\n\n\n    if (manifest === 'single') {\n      Assert(normalized.length === 1, 'Term', term, 'contains more than one item');\n      desc[term] = normalized[0];\n      continue;\n    } // Array\n\n\n    desc[term] = normalized;\n  }\n\n  internals.validate(schema.$_root, desc);\n  return desc;\n};\n\ninternals.describe = function (item, options = {}) {\n  if (Array.isArray(item)) {\n    return item.map(internals.describe);\n  }\n\n  if (item === Common.symbols.deepDefault) {\n    return {\n      special: 'deep'\n    };\n  }\n\n  if (typeof item !== 'object' || item === null) {\n    return item;\n  }\n\n  if (options.assign === 'options') {\n    return Clone(item);\n  }\n\n  if (Buffer && Buffer.isBuffer(item)) {\n    // $lab:coverage:ignore$\n    return {\n      buffer: item.toString('binary')\n    };\n  }\n\n  if (item instanceof Date) {\n    return item.toISOString();\n  }\n\n  if (item instanceof Error) {\n    return item;\n  }\n\n  if (item instanceof RegExp) {\n    if (options.assign === 'regex') {\n      return item.toString();\n    }\n\n    return {\n      regex: item.toString()\n    };\n  }\n\n  if (item[Common.symbols.literal]) {\n    return {\n      function: item.literal\n    };\n  }\n\n  if (typeof item.describe === 'function') {\n    if (options.assign === 'ref') {\n      return item.describe().ref;\n    }\n\n    return item.describe();\n  }\n\n  const normalized = {};\n\n  for (const key in item) {\n    const value = item[key];\n\n    if (value === undefined) {\n      continue;\n    }\n\n    normalized[key] = internals.describe(value, {\n      assign: key\n    });\n  }\n\n  return normalized;\n};\n\nexports.build = function (joi, desc) {\n  const builder = new internals.Builder(joi);\n  return builder.parse(desc);\n};\n\ninternals.Builder = class {\n  constructor(joi) {\n    this.joi = joi;\n  }\n\n  parse(desc) {\n    internals.validate(this.joi, desc); // Type\n\n    let schema = this.joi[desc.type]()._bare();\n\n    const def = schema._definition; // Flags\n\n    if (desc.flags) {\n      for (const flag in desc.flags) {\n        const setter = def.flags[flag] && def.flags[flag].setter || flag;\n        Assert(typeof schema[setter] === 'function', 'Invalid flag', flag, 'for type', desc.type);\n        schema = schema[setter](this.build(desc.flags[flag]));\n      }\n    } // Preferences\n\n\n    if (desc.preferences) {\n      schema = schema.preferences(this.build(desc.preferences));\n    } // Allow / Invalid\n\n\n    if (desc.allow) {\n      schema = schema.allow(...this.build(desc.allow));\n    }\n\n    if (desc.invalid) {\n      schema = schema.invalid(...this.build(desc.invalid));\n    } // Rules\n\n\n    if (desc.rules) {\n      for (const rule of desc.rules) {\n        Assert(typeof schema[rule.name] === 'function', 'Invalid rule', rule.name, 'for type', desc.type);\n        const args = [];\n\n        if (rule.args) {\n          const built = {};\n\n          for (const key in rule.args) {\n            built[key] = this.build(rule.args[key], {\n              assign: key\n            });\n          }\n\n          const keys = Object.keys(built);\n          const definition = def.rules[rule.name].args;\n\n          if (definition) {\n            Assert(keys.length <= definition.length, 'Invalid number of arguments for', desc.type, rule.name, '(expected up to', definition.length, ', found', keys.length, ')');\n\n            for (const {\n              name\n            } of definition) {\n              args.push(built[name]);\n            }\n          } else {\n            Assert(keys.length === 1, 'Invalid number of arguments for', desc.type, rule.name, '(expected up to 1, found', keys.length, ')');\n            args.push(built[keys[0]]);\n          }\n        } // Apply\n\n\n        schema = schema[rule.name](...args); // Ruleset\n\n        const options = {};\n\n        for (const custom in def.modifiers) {\n          if (rule[custom] !== undefined) {\n            options[custom] = this.build(rule[custom]);\n          }\n        }\n\n        if (Object.keys(options).length) {\n          schema = schema.rule(options);\n        }\n      }\n    } // Terms\n\n\n    const terms = {};\n\n    for (const key in desc) {\n      if (['allow', 'flags', 'invalid', 'whens', 'preferences', 'rules', 'type'].includes(key)) {\n        continue;\n      }\n\n      Assert(def.terms[key], 'Term', key, 'missing configuration');\n      const manifest = def.terms[key].manifest;\n\n      if (manifest === 'schema') {\n        terms[key] = desc[key].map(item => this.parse(item));\n        continue;\n      }\n\n      if (manifest === 'values') {\n        terms[key] = desc[key].map(item => this.build(item));\n        continue;\n      }\n\n      if (manifest === 'single') {\n        terms[key] = this.build(desc[key]);\n        continue;\n      }\n\n      if (typeof manifest === 'object') {\n        terms[key] = {};\n\n        for (const name in desc[key]) {\n          const value = desc[key][name];\n          terms[key][name] = this.parse(value);\n        }\n\n        continue;\n      }\n\n      terms[key] = this.build(desc[key]);\n    }\n\n    if (desc.whens) {\n      terms.whens = desc.whens.map(when => this.build(when));\n    }\n\n    schema = def.manifest.build(schema, terms);\n    schema.$_temp.ruleset = false;\n    return schema;\n  }\n\n  build(desc, options = {}) {\n    if (desc === null) {\n      return null;\n    }\n\n    if (Array.isArray(desc)) {\n      return desc.map(item => this.build(item));\n    }\n\n    if (desc instanceof Error) {\n      return desc;\n    }\n\n    if (options.assign === 'options') {\n      return Clone(desc);\n    }\n\n    if (options.assign === 'regex') {\n      return internals.regex(desc);\n    }\n\n    if (options.assign === 'ref') {\n      return Ref.build(desc);\n    }\n\n    if (typeof desc !== 'object') {\n      return desc;\n    }\n\n    if (Object.keys(desc).length === 1) {\n      if (desc.buffer) {\n        Assert(Buffer, 'Buffers are not supported');\n        return Buffer && Buffer.from(desc.buffer, 'binary'); // $lab:coverage:ignore$\n      }\n\n      if (desc.function) {\n        return {\n          [Common.symbols.literal]: true,\n          literal: desc.function\n        };\n      }\n\n      if (desc.override) {\n        return Common.symbols.override;\n      }\n\n      if (desc.ref) {\n        return Ref.build(desc.ref);\n      }\n\n      if (desc.regex) {\n        return internals.regex(desc.regex);\n      }\n\n      if (desc.special) {\n        Assert(['deep'].includes(desc.special), 'Unknown special value', desc.special);\n        return Common.symbols.deepDefault;\n      }\n\n      if (desc.value) {\n        return Clone(desc.value);\n      }\n    }\n\n    if (desc.type) {\n      return this.parse(desc);\n    }\n\n    if (desc.template) {\n      return Template.build(desc);\n    }\n\n    const normalized = {};\n\n    for (const key in desc) {\n      normalized[key] = this.build(desc[key], {\n        assign: key\n      });\n    }\n\n    return normalized;\n  }\n\n};\n\ninternals.regex = function (string) {\n  const end = string.lastIndexOf('/');\n  const exp = string.slice(1, end);\n  const flags = string.slice(end + 1);\n  return new RegExp(exp, flags);\n};\n\ninternals.validate = function (joi, desc) {\n  Schemas = Schemas || require('./schemas');\n  joi.assert(desc, Schemas.description);\n};","map":{"version":3,"sources":["C:/scripting/jobs assignments/whist/backend/node_modules/joi/lib/manifest.js"],"names":["Assert","require","Clone","Common","Messages","Ref","Template","Schemas","internals","exports","describe","schema","def","_definition","desc","type","flags","rules","flag","_flags","Object","keys","length","_preferences","preferences","shallow","symbols","prefs","messages","decompile","_valids","allow","_invalids","invalid","rule","_rules","ruleDef","name","manifest","item","custom","modifiers","undefined","args","key","arg","assign","push","term","$_terms","items","Map","size","entries","isValues","terms","mapped","normalized","from","to","validate","$_root","options","Array","isArray","map","deepDefault","special","Buffer","isBuffer","buffer","toString","Date","toISOString","Error","RegExp","regex","literal","function","ref","value","build","joi","builder","Builder","parse","constructor","_bare","setter","built","definition","includes","whens","when","$_temp","ruleset","override","template","string","end","lastIndexOf","exp","slice","assert","description"],"mappings":"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","sourcesContent":["'use strict';\n\nconst Assert = require('@hapi/hoek/lib/assert');\nconst Clone = require('@hapi/hoek/lib/clone');\n\nconst Common = require('./common');\nconst Messages = require('./messages');\nconst Ref = require('./ref');\nconst Template = require('./template');\n\nlet Schemas;\n\n\nconst internals = {};\n\n\nexports.describe = function (schema) {\n\n    const def = schema._definition;\n\n    // Type\n\n    const desc = {\n        type: schema.type,\n        flags: {},\n        rules: []\n    };\n\n    // Flags\n\n    for (const flag in schema._flags) {\n        if (flag[0] !== '_') {\n            desc.flags[flag] = internals.describe(schema._flags[flag]);\n        }\n    }\n\n    if (!Object.keys(desc.flags).length) {\n        delete desc.flags;\n    }\n\n    // Preferences\n\n    if (schema._preferences) {\n        desc.preferences = Clone(schema._preferences, { shallow: ['messages'] });\n        delete desc.preferences[Common.symbols.prefs];\n        if (desc.preferences.messages) {\n            desc.preferences.messages = Messages.decompile(desc.preferences.messages);\n        }\n    }\n\n    // Allow / Invalid\n\n    if (schema._valids) {\n        desc.allow = schema._valids.describe();\n    }\n\n    if (schema._invalids) {\n        desc.invalid = schema._invalids.describe();\n    }\n\n    // Rules\n\n    for (const rule of schema._rules) {\n        const ruleDef = def.rules[rule.name];\n        if (ruleDef.manifest === false) {                           // Defaults to true\n            continue;\n        }\n\n        const item = { name: rule.name };\n\n        for (const custom in def.modifiers) {\n            if (rule[custom] !== undefined) {\n                item[custom] = internals.describe(rule[custom]);\n            }\n        }\n\n        if (rule.args) {\n            item.args = {};\n            for (const key in rule.args) {\n                const arg = rule.args[key];\n                if (key === 'options' &&\n                    !Object.keys(arg).length) {\n\n                    continue;\n                }\n\n                item.args[key] = internals.describe(arg, { assign: key });\n            }\n\n            if (!Object.keys(item.args).length) {\n                delete item.args;\n            }\n        }\n\n        desc.rules.push(item);\n    }\n\n    if (!desc.rules.length) {\n        delete desc.rules;\n    }\n\n    // Terms (must be last to verify no name conflicts)\n\n    for (const term in schema.$_terms) {\n        if (term[0] === '_') {\n            continue;\n        }\n\n        Assert(!desc[term], 'Cannot describe schema due to internal name conflict with', term);\n\n        const items = schema.$_terms[term];\n        if (!items) {\n            continue;\n        }\n\n        if (items instanceof Map) {\n            if (items.size) {\n                desc[term] = [...items.entries()];\n            }\n\n            continue;\n        }\n\n        if (Common.isValues(items)) {\n            desc[term] = items.describe();\n            continue;\n        }\n\n        Assert(def.terms[term], 'Term', term, 'missing configuration');\n        const manifest = def.terms[term].manifest;\n        const mapped = typeof manifest === 'object';\n        if (!items.length &&\n            !mapped) {\n\n            continue;\n        }\n\n        const normalized = [];\n        for (const item of items) {\n            normalized.push(internals.describe(item));\n        }\n\n        // Mapped\n\n        if (mapped) {\n            const { from, to } = manifest.mapped;\n            desc[term] = {};\n            for (const item of normalized) {\n                desc[term][item[to]] = item[from];\n            }\n\n            continue;\n        }\n\n        // Single\n\n        if (manifest === 'single') {\n            Assert(normalized.length === 1, 'Term', term, 'contains more than one item');\n            desc[term] = normalized[0];\n            continue;\n        }\n\n        // Array\n\n        desc[term] = normalized;\n    }\n\n    internals.validate(schema.$_root, desc);\n    return desc;\n};\n\n\ninternals.describe = function (item, options = {}) {\n\n    if (Array.isArray(item)) {\n        return item.map(internals.describe);\n    }\n\n    if (item === Common.symbols.deepDefault) {\n        return { special: 'deep' };\n    }\n\n    if (typeof item !== 'object' ||\n        item === null) {\n\n        return item;\n    }\n\n    if (options.assign === 'options') {\n        return Clone(item);\n    }\n\n    if (Buffer && Buffer.isBuffer(item)) {                          // $lab:coverage:ignore$\n        return { buffer: item.toString('binary') };\n    }\n\n    if (item instanceof Date) {\n        return item.toISOString();\n    }\n\n    if (item instanceof Error) {\n        return item;\n    }\n\n    if (item instanceof RegExp) {\n        if (options.assign === 'regex') {\n            return item.toString();\n        }\n\n        return { regex: item.toString() };\n    }\n\n    if (item[Common.symbols.literal]) {\n        return { function: item.literal };\n    }\n\n    if (typeof item.describe === 'function') {\n        if (options.assign === 'ref') {\n            return item.describe().ref;\n        }\n\n        return item.describe();\n    }\n\n    const normalized = {};\n    for (const key in item) {\n        const value = item[key];\n        if (value === undefined) {\n            continue;\n        }\n\n        normalized[key] = internals.describe(value, { assign: key });\n    }\n\n    return normalized;\n};\n\n\nexports.build = function (joi, desc) {\n\n    const builder = new internals.Builder(joi);\n    return builder.parse(desc);\n};\n\n\ninternals.Builder = class {\n\n    constructor(joi) {\n\n        this.joi = joi;\n    }\n\n    parse(desc) {\n\n        internals.validate(this.joi, desc);\n\n        // Type\n\n        let schema = this.joi[desc.type]()._bare();\n        const def = schema._definition;\n\n        // Flags\n\n        if (desc.flags) {\n            for (const flag in desc.flags) {\n                const setter = def.flags[flag] && def.flags[flag].setter || flag;\n                Assert(typeof schema[setter] === 'function', 'Invalid flag', flag, 'for type', desc.type);\n                schema = schema[setter](this.build(desc.flags[flag]));\n            }\n        }\n\n        // Preferences\n\n        if (desc.preferences) {\n            schema = schema.preferences(this.build(desc.preferences));\n        }\n\n        // Allow / Invalid\n\n        if (desc.allow) {\n            schema = schema.allow(...this.build(desc.allow));\n        }\n\n        if (desc.invalid) {\n            schema = schema.invalid(...this.build(desc.invalid));\n        }\n\n        // Rules\n\n        if (desc.rules) {\n            for (const rule of desc.rules) {\n                Assert(typeof schema[rule.name] === 'function', 'Invalid rule', rule.name, 'for type', desc.type);\n\n                const args = [];\n                if (rule.args) {\n                    const built = {};\n                    for (const key in rule.args) {\n                        built[key] = this.build(rule.args[key], { assign: key });\n                    }\n\n                    const keys = Object.keys(built);\n                    const definition = def.rules[rule.name].args;\n                    if (definition) {\n                        Assert(keys.length <= definition.length, 'Invalid number of arguments for', desc.type, rule.name, '(expected up to', definition.length, ', found', keys.length, ')');\n                        for (const { name } of definition) {\n                            args.push(built[name]);\n                        }\n                    }\n                    else {\n                        Assert(keys.length === 1, 'Invalid number of arguments for', desc.type, rule.name, '(expected up to 1, found', keys.length, ')');\n                        args.push(built[keys[0]]);\n                    }\n                }\n\n                // Apply\n\n                schema = schema[rule.name](...args);\n\n                // Ruleset\n\n                const options = {};\n                for (const custom in def.modifiers) {\n                    if (rule[custom] !== undefined) {\n                        options[custom] = this.build(rule[custom]);\n                    }\n                }\n\n                if (Object.keys(options).length) {\n                    schema = schema.rule(options);\n                }\n            }\n        }\n\n        // Terms\n\n        const terms = {};\n        for (const key in desc) {\n            if (['allow', 'flags', 'invalid', 'whens', 'preferences', 'rules', 'type'].includes(key)) {\n                continue;\n            }\n\n            Assert(def.terms[key], 'Term', key, 'missing configuration');\n            const manifest = def.terms[key].manifest;\n\n            if (manifest === 'schema') {\n                terms[key] = desc[key].map((item) => this.parse(item));\n                continue;\n            }\n\n            if (manifest === 'values') {\n                terms[key] = desc[key].map((item) => this.build(item));\n                continue;\n            }\n\n            if (manifest === 'single') {\n                terms[key] = this.build(desc[key]);\n                continue;\n            }\n\n            if (typeof manifest === 'object') {\n                terms[key] = {};\n                for (const name in desc[key]) {\n                    const value = desc[key][name];\n                    terms[key][name] = this.parse(value);\n                }\n\n                continue;\n            }\n\n            terms[key] = this.build(desc[key]);\n        }\n\n        if (desc.whens) {\n            terms.whens = desc.whens.map((when) => this.build(when));\n        }\n\n        schema = def.manifest.build(schema, terms);\n        schema.$_temp.ruleset = false;\n        return schema;\n    }\n\n    build(desc, options = {}) {\n\n        if (desc === null) {\n            return null;\n        }\n\n        if (Array.isArray(desc)) {\n            return desc.map((item) => this.build(item));\n        }\n\n        if (desc instanceof Error) {\n            return desc;\n        }\n\n        if (options.assign === 'options') {\n            return Clone(desc);\n        }\n\n        if (options.assign === 'regex') {\n            return internals.regex(desc);\n        }\n\n        if (options.assign === 'ref') {\n            return Ref.build(desc);\n        }\n\n        if (typeof desc !== 'object') {\n            return desc;\n        }\n\n        if (Object.keys(desc).length === 1) {\n            if (desc.buffer) {\n                Assert(Buffer, 'Buffers are not supported');\n                return Buffer && Buffer.from(desc.buffer, 'binary');                    // $lab:coverage:ignore$\n            }\n\n            if (desc.function) {\n                return { [Common.symbols.literal]: true, literal: desc.function };\n            }\n\n            if (desc.override) {\n                return Common.symbols.override;\n            }\n\n            if (desc.ref) {\n                return Ref.build(desc.ref);\n            }\n\n            if (desc.regex) {\n                return internals.regex(desc.regex);\n            }\n\n            if (desc.special) {\n                Assert(['deep'].includes(desc.special), 'Unknown special value', desc.special);\n                return Common.symbols.deepDefault;\n            }\n\n            if (desc.value) {\n                return Clone(desc.value);\n            }\n        }\n\n        if (desc.type) {\n            return this.parse(desc);\n        }\n\n        if (desc.template) {\n            return Template.build(desc);\n        }\n\n        const normalized = {};\n        for (const key in desc) {\n            normalized[key] = this.build(desc[key], { assign: key });\n        }\n\n        return normalized;\n    }\n};\n\n\ninternals.regex = function (string) {\n\n    const end = string.lastIndexOf('/');\n    const exp = string.slice(1, end);\n    const flags = string.slice(end + 1);\n    return new RegExp(exp, flags);\n};\n\n\ninternals.validate = function (joi, desc) {\n\n    Schemas = Schemas || require('./schemas');\n\n    joi.assert(desc, Schemas.description);\n};\n"]},"metadata":{},"sourceType":"script"}